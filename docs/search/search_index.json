{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to INScore INScore is an environment for the design of interactive augmented music scores oriented towards unconventional uses of music notation and representation, including real-time symbolic music notation capabilities. INScore native version is fully controllable using Open Sound Control [OSC] messages. INScore scripting language is an extended textual version of theses messages that allows you to design scores in a modular and incremental way. To test the system, you can go to the online INScore editor . This site documents the INScore messages and the scripting language. Note : All the features described in this document are not available with the online editor. A section entitled INScore Web is dedicated to the specific features and differences of the Javascript version of INScore. To get an idea of INScore features, you can have a look at the INScore Overview . To understand the principles of the scripting language, it is recommended to look first at the Introduction to INScore Programming . INscore is a research project developped by GRAME-CNCM","title":"Home"},{"location":"#welcome-to-inscore","text":"INScore is an environment for the design of interactive augmented music scores oriented towards unconventional uses of music notation and representation, including real-time symbolic music notation capabilities. INScore native version is fully controllable using Open Sound Control [OSC] messages. INScore scripting language is an extended textual version of theses messages that allows you to design scores in a modular and incremental way. To test the system, you can go to the online INScore editor . This site documents the INScore messages and the scripting language. Note : All the features described in this document are not available with the online editor. A section entitled INScore Web is dedicated to the specific features and differences of the Javascript version of INScore. To get an idea of INScore features, you can have a look at the INScore Overview . To understand the principles of the scripting language, it is recommended to look first at the Introduction to INScore Programming . INscore is a research project developped by GRAME-CNCM","title":"Welcome to INScore"},{"location":"about/","text":"The INScore Project The INScore Project is an open source project hosted on github . INScore is an environment for the design of interactive augmented music scores that runs on Linux, MacOS, Windows, iOS and Android. Recently, an online version of the environment is also available. This site documents the version 1.32 of the INScore scripting language. INScore was initiated in the Interlude project, funded by the French National Research Agency [ANR- 08-CORD-010]. I would like to thank all the people who have been contributing to INScore design and development, and especially: Julien Aldon, Kevin Bardotti, Christophe Daudin, Sarah Denoux, Martin Carl\u00e9, Guillaume Gouilloux, Joachim Heintz, Camille Le Roi, Gabriel Lepetit-Aimon, Arnaud Margaillan, Eric Ravel. Many thanks also to the Interlude team - Fr\u00e9d\u00e9ric Bevilacqua, Norbert Schnell, Nicolas Rasamimanana, Emmanuel Fl\u00e9ty, Fabrice Gu\u00e9dy, Jean-Louis Frechin, Uros Petrevski, Bernard Garab\u00e9dian, R\u00e9mi Dury, Bruno Verbrugghe - who contributed to the elaboration of the project foundations. And of course, warmest thanks to my colleagues and friends St\u00e9phane Letz and Yann Orlarey. Dominique Fober","title":"About"},{"location":"about/#the-inscore-project","text":"The INScore Project is an open source project hosted on github . INScore is an environment for the design of interactive augmented music scores that runs on Linux, MacOS, Windows, iOS and Android. Recently, an online version of the environment is also available. This site documents the version 1.32 of the INScore scripting language. INScore was initiated in the Interlude project, funded by the French National Research Agency [ANR- 08-CORD-010]. I would like to thank all the people who have been contributing to INScore design and development, and especially: Julien Aldon, Kevin Bardotti, Christophe Daudin, Sarah Denoux, Martin Carl\u00e9, Guillaume Gouilloux, Joachim Heintz, Camille Le Roi, Gabriel Lepetit-Aimon, Arnaud Margaillan, Eric Ravel. Many thanks also to the Interlude team - Fr\u00e9d\u00e9ric Bevilacqua, Norbert Schnell, Nicolas Rasamimanana, Emmanuel Fl\u00e9ty, Fabrice Gu\u00e9dy, Jean-Louis Frechin, Uros Petrevski, Bernard Garab\u00e9dian, R\u00e9mi Dury, Bruno Verbrugghe - who contributed to the elaboration of the project foundations. And of course, warmest thanks to my colleagues and friends St\u00e9phane Letz and Yann Orlarey. Dominique Fober","title":"The INScore Project"},{"location":"papers/","text":"Academic publications related to INScore","title":"Papers"},{"location":"papers/#academic-publications-related-to-inscore","text":"","title":"Academic publications related to INScore"},{"location":"lang/1-scripting/","text":"INScore Scripting Language Introduction INScore scripting language is based on a textual version of OSC messages, extended with variables, Javascript sections and Mathematical expressions. INScore scripts files are expected to carry a .inscore extension. You can drop them to the INScoreViewer application or to any opened INScore scene. The application or scene state can be saved (using the save message) as files containing textual OSC messages. These files can be edited or created from scratch using any text editor. Statements An INScore file is a list of textual expressions. An expression is: a message: basically a textual OSC message extended to support URL like addresses and variables as parameters. a variable declaration. a javascript section that may generate messages as output. comments. an end marker ' \\inscoreend ' to declare a script end. After the marker, the remaining part of the script will be ignored. expression ComplexDiagram( Choice (0, Sequence (NonTerminal('message'), \";\"), Sequence (NonTerminal('variabledecl'), \";\"), NonTerminal('javascript'), NonTerminal('comments'), NonTerminal('end')) ).addTo() Messages and variables declarations must be followed by a semicolon that is used as statements separator. Messages Messages are basic OSC messages that support an OSC address extension scheme and relative addresses that are described below. Messages parameters can be replaced by variables that are evaluated at parsing level. Variables are described in section scriptvar . Extended OSC addresses OSC addresses can be extended to target other applications, including on other hosts. address ComplexDiagram( Sequence (Optional ( Sequence (Choice (0, NonTerminal('IPAddress'), NonTerminal('hostname')), ':', NonTerminal('port'))), NonTerminal('OSCAddress')) ).addTo() Using the address extension scheme, a script may be designed to initialize an INScore scene and external applications as well, including on remote hosts. Example Initializing a score and an external application listening on port 12000 and running on a remote host named host.adomain.net . /ITL/scene/score set gmnf 'myscore.gmn'; host.adomain.net:12000/run 1; Relative addresses Relative addresses have been introduced to provide more flexibility in the score design process. A relative address starts with ' ./ '. It is evaluated in the context of the message receiver: a legal OSC address is dynamically constructed using the receiver address to prefix the relative address. Example the relative address ./score addressed to /ITL/scene/layer will be evaluted as /ITL/scene/layer/score The receiver context may be: the INScore application address (i.e. /ITL ) for messages enclosed in a file loaded at application level (using the load message addressed to the application) or for files dropped to the application or given as arguments of the INScoreViewer application. a scene address for messages enclosed in a file loaded at scene level (using the load message addressed to a scene) or for files or messages dropped to a scene window. any object address when the messages are passed as arguments of an eval message (see OSCMsg reference ). Example Using a set of messages in different contexts: score = ( ./score set gmn '[a f g]', ./score scale 2. ); /ITL/scene/l1 eval $score; /ITL/scene/l2 eval $score; Note: Legal OSC addresses (i.e. addresses that start with '/') that are given as argument of an eval message are not affected by the address evaluation. Types The message parameters types are constrained by the OSC protocol: any parameter is converted to an OSC type (i.e. int32, float or string) at parsing level. A special attention must be given to strings in order to discriminate addresses and parameters. Strings intended as parameters must: be quoted, using single or double quotes. Note that an ambiguous quote included in a string can be escaped using a '\\'. or avoid any special characters i.e. any other character than [_-a-zA-Z0-9] . Note: text objects are permissive with the above rules: spaces don't have to be quoted, they accept also numbers as input arguments (they are converted to strings). Example Different string parameters /ITL/scene/text set txt \"Hello world\"; # string including a space can be quoted /ITL/scene/text set txt Hello world; # text objects support stream like parameters /ITL/scene/img set file 'anImage.png'; # dots must be quoted too /ITL/scene/foo set txt no_quotes_needed; Variables A variable declaration associates a name with a list of parameters or a list of messages. Parameters must follow the rules given in section scripttypes . They may include previously declared variables. A message list must be enclosed in parenthesis and a comma must be used as messages separator. variabledecl ComplexDiagram( Sequence ('ident', '=', Choice (0, OneOrMore (Choice (0, NonTerminal('param'), NonTerminal('variable'))), Sequence ('(', OneOrMore (NonTerminal('message'), ','), ')')), ';') ).addTo() Example Variables declarations color = 200 200 200; colorwithalpha = $color 100; # using another variable msgsvar= ( # a variable referring to a message list localhost:7001/world \"Hello world\", localhost:7001/world \"how are you ?\" ); A variable may be used in place of any message parameter. A reference to a variable must have the form $ident where ident is a previously declared variable. A variable is evaluated at parsing level and replaced by its content. Example Using a variable to share a common position: x = 0.5; /ITL/scene/a x $x; /ITL/scene/b x $x; Variables can be used in interaction messages as well, which may also use the variables available from events context. To differentiate between a script and an interaction variable, the latter must be quoted to be passed as strings and to prevent their evaluation by the parser. Example Using variables in interaction messages: $sx is evaluated at event occurrence and $y is evaluated at parsing level. y = 0.5; /ITL/scene/foo watch mouseDown (/ITL/scene/foo \"$sx\" $y); Environnement variables Environnement variables are predefined variables available in a script context. They provide information related to the current context. Current environment variables are: OSName : gives the current operating system name. The value is among \"MacOS\" , \"Windows\" , \"Linux\" , \"Android\" , \"iOS\" and \"Web\" . OSId : gives the current operating system as a numeric identifier. Returned value is (in alphabetic order): 1 for Android 2 for iOS 3 for Linux 4 for MacOS 5 for Windows 6 for the Web environment Note: There is nothing to prevent overriding of an environment variable. It's the script responsibility to handle variable names collisions. Message based parameters A message parameter may also use the result of a get message as parameter specified like a message based variable. The message must be enclosed in parenthesis with a leading $ sign. msgparam ComplexDiagram( Sequence (NonTerminal('dollar'), '(', NonTerminal('message'), ')') ).addTo() Example Displaying INScore version using a message parameter: /ITL/scene/version set txt \"INScore version is\" $(/ITL get version); Note: Message based parameters are evaluated by the parser. Thus when the system state is modified by a script before a message parameter, these modifications won't be visible at the time of the parameter evaluation because all the messages will be processed by the next time task. For example: /ITL/scene/obj x 0.1; /ITL/scene/foo x $(/ITL/scene/foo get x); x position of /ITL/scene/foo will be set to x position of /ITL/scene/obj at the time of the script evaluation (that may be different to 0.1). Javascript INScore supports Javascript as scripting languages. Javascript is embedded using the Qt Javascript engine. A script section is indicated similarly to a Javascript section in html i.e. enclosed in an opening <? and a closing ?> . script ComplexDiagram( Sequence ('<?', 'javascript', NonTerminal('script'), '?>') ).addTo() The principle of using Javascript sections in INScore files is the following: the Javascript sections are passed to the Javascript engine and are expected to produce textual INScore messages on output. These messages are then parsed as if replacing the corresponding script section. INScore variables are exported to the Javascript environment. Note: A Javascript section may produce not output, for example when it declares functions to be used later. Example <? javascript \"/ITL/scene/version set txt 'Javascript v. \" + version() + \"';\" ?> A single persistent Javascript context is created at application level and shared with each scene. The Javascript object The Javascript engine is available at runtime at the address /ITL/ scene /javascript . It has a run method that takes a javascript string as parameter. javascript ComplexDiagram( Sequence ('run', 'code') ).addTo() The run method evaluates the code. Similarly to javascript sections in scripts, the output of the evaluation is expected to be a string containing valid INScore messages that are next executed. Actually, including a javascript section in a script is equivalent to send the run message with the same code as parameter to the javascript object. The Javascript engine is based on the Qt5 Javascrip engine, extended with INScore specific functions: version() : gives the javascript engine version number as a string. print(val1 [, val2 [, ...]]) : print the arguments to the OSC standard output. The arguments list is prefixed by 'javascript:'. The function is provided for debug purpose. readfile(file) : read a file and returns its content as a string. The file name could be specified as an absolute or relative path. When relative, the file is searched in the application current rootPath . post(address [,...]) : build an OSC message and post it for delayed processing i.e. to be processed by the next time task. address is an OSC or an extended OSC address. Optional arguments are the message parameters. osname() : gives the current operating system name. osid() : gives the current operating system as a numeric identifiant. Returned value is (in alphabetic order): 1 for Android 2 for iOS. 3 for Linux, 4 for MacOS, 5 for Windows Example Posting a message from a Javascript section: <?javascript post (\"/ITL/scene/obj\", \"dalpha\", -1);\"; // The message /ITL/scene/obj dalpha -1 // will be evaluated by the next time task. ?> Declaration of a Javascript function to be used later: <?javascript // declare a function foo() function foo(arg) { return \"/ITL/scene/obj set txt foo called with \" + arg + \";\"; } ?> # call the foo function <?javascript foo(1)?> # or call the foo function using the run message /ITL/scene/javascript run \"foo(1)\"; Comments There are two ways to comment code inside a script: line comments: the '#' character is used for line comments, anything after a '#' is ignored. section comments: section comments start with '( ' and end with ' )', anything between them is ignored. Example # this is a line comment /ITL/scene/* del; (* here is a section comment section comments are multi-lines comments {*}) /ITL/scene/hello set txt \"Hello world!\"; # the preceding message is not commented \\inscoreend and everything below the \\inscoreend marker is also ignored","title":"Language"},{"location":"lang/1-scripting/#inscore-scripting-language","text":"","title":"INScore Scripting Language"},{"location":"lang/1-scripting/#introduction","text":"INScore scripting language is based on a textual version of OSC messages, extended with variables, Javascript sections and Mathematical expressions. INScore scripts files are expected to carry a .inscore extension. You can drop them to the INScoreViewer application or to any opened INScore scene. The application or scene state can be saved (using the save message) as files containing textual OSC messages. These files can be edited or created from scratch using any text editor.","title":"Introduction"},{"location":"lang/1-scripting/#statements","text":"An INScore file is a list of textual expressions. An expression is: a message: basically a textual OSC message extended to support URL like addresses and variables as parameters. a variable declaration. a javascript section that may generate messages as output. comments. an end marker ' \\inscoreend ' to declare a script end. After the marker, the remaining part of the script will be ignored. expression ComplexDiagram( Choice (0, Sequence (NonTerminal('message'), \";\"), Sequence (NonTerminal('variabledecl'), \";\"), NonTerminal('javascript'), NonTerminal('comments'), NonTerminal('end')) ).addTo() Messages and variables declarations must be followed by a semicolon that is used as statements separator.","title":"Statements"},{"location":"lang/1-scripting/#messages","text":"Messages are basic OSC messages that support an OSC address extension scheme and relative addresses that are described below. Messages parameters can be replaced by variables that are evaluated at parsing level. Variables are described in section scriptvar .","title":"Messages"},{"location":"lang/1-scripting/#extended-osc-addresses","text":"OSC addresses can be extended to target other applications, including on other hosts. address ComplexDiagram( Sequence (Optional ( Sequence (Choice (0, NonTerminal('IPAddress'), NonTerminal('hostname')), ':', NonTerminal('port'))), NonTerminal('OSCAddress')) ).addTo() Using the address extension scheme, a script may be designed to initialize an INScore scene and external applications as well, including on remote hosts. Example Initializing a score and an external application listening on port 12000 and running on a remote host named host.adomain.net . /ITL/scene/score set gmnf 'myscore.gmn'; host.adomain.net:12000/run 1;","title":"Extended OSC addresses"},{"location":"lang/1-scripting/#relative-addresses","text":"Relative addresses have been introduced to provide more flexibility in the score design process. A relative address starts with ' ./ '. It is evaluated in the context of the message receiver: a legal OSC address is dynamically constructed using the receiver address to prefix the relative address. Example the relative address ./score addressed to /ITL/scene/layer will be evaluted as /ITL/scene/layer/score The receiver context may be: the INScore application address (i.e. /ITL ) for messages enclosed in a file loaded at application level (using the load message addressed to the application) or for files dropped to the application or given as arguments of the INScoreViewer application. a scene address for messages enclosed in a file loaded at scene level (using the load message addressed to a scene) or for files or messages dropped to a scene window. any object address when the messages are passed as arguments of an eval message (see OSCMsg reference ). Example Using a set of messages in different contexts: score = ( ./score set gmn '[a f g]', ./score scale 2. ); /ITL/scene/l1 eval $score; /ITL/scene/l2 eval $score; Note: Legal OSC addresses (i.e. addresses that start with '/') that are given as argument of an eval message are not affected by the address evaluation.","title":"Relative addresses"},{"location":"lang/1-scripting/#types","text":"The message parameters types are constrained by the OSC protocol: any parameter is converted to an OSC type (i.e. int32, float or string) at parsing level. A special attention must be given to strings in order to discriminate addresses and parameters. Strings intended as parameters must: be quoted, using single or double quotes. Note that an ambiguous quote included in a string can be escaped using a '\\'. or avoid any special characters i.e. any other character than [_-a-zA-Z0-9] . Note: text objects are permissive with the above rules: spaces don't have to be quoted, they accept also numbers as input arguments (they are converted to strings). Example Different string parameters /ITL/scene/text set txt \"Hello world\"; # string including a space can be quoted /ITL/scene/text set txt Hello world; # text objects support stream like parameters /ITL/scene/img set file 'anImage.png'; # dots must be quoted too /ITL/scene/foo set txt no_quotes_needed;","title":"Types"},{"location":"lang/1-scripting/#variables","text":"A variable declaration associates a name with a list of parameters or a list of messages. Parameters must follow the rules given in section scripttypes . They may include previously declared variables. A message list must be enclosed in parenthesis and a comma must be used as messages separator. variabledecl ComplexDiagram( Sequence ('ident', '=', Choice (0, OneOrMore (Choice (0, NonTerminal('param'), NonTerminal('variable'))), Sequence ('(', OneOrMore (NonTerminal('message'), ','), ')')), ';') ).addTo() Example Variables declarations color = 200 200 200; colorwithalpha = $color 100; # using another variable msgsvar= ( # a variable referring to a message list localhost:7001/world \"Hello world\", localhost:7001/world \"how are you ?\" ); A variable may be used in place of any message parameter. A reference to a variable must have the form $ident where ident is a previously declared variable. A variable is evaluated at parsing level and replaced by its content. Example Using a variable to share a common position: x = 0.5; /ITL/scene/a x $x; /ITL/scene/b x $x; Variables can be used in interaction messages as well, which may also use the variables available from events context. To differentiate between a script and an interaction variable, the latter must be quoted to be passed as strings and to prevent their evaluation by the parser. Example Using variables in interaction messages: $sx is evaluated at event occurrence and $y is evaluated at parsing level. y = 0.5; /ITL/scene/foo watch mouseDown (/ITL/scene/foo \"$sx\" $y);","title":"Variables"},{"location":"lang/1-scripting/#environnement-variables","text":"Environnement variables are predefined variables available in a script context. They provide information related to the current context. Current environment variables are: OSName : gives the current operating system name. The value is among \"MacOS\" , \"Windows\" , \"Linux\" , \"Android\" , \"iOS\" and \"Web\" . OSId : gives the current operating system as a numeric identifier. Returned value is (in alphabetic order): 1 for Android 2 for iOS 3 for Linux 4 for MacOS 5 for Windows 6 for the Web environment Note: There is nothing to prevent overriding of an environment variable. It's the script responsibility to handle variable names collisions.","title":"Environnement variables"},{"location":"lang/1-scripting/#message-based-parameters","text":"A message parameter may also use the result of a get message as parameter specified like a message based variable. The message must be enclosed in parenthesis with a leading $ sign. msgparam ComplexDiagram( Sequence (NonTerminal('dollar'), '(', NonTerminal('message'), ')') ).addTo() Example Displaying INScore version using a message parameter: /ITL/scene/version set txt \"INScore version is\" $(/ITL get version); Note: Message based parameters are evaluated by the parser. Thus when the system state is modified by a script before a message parameter, these modifications won't be visible at the time of the parameter evaluation because all the messages will be processed by the next time task. For example: /ITL/scene/obj x 0.1; /ITL/scene/foo x $(/ITL/scene/foo get x); x position of /ITL/scene/foo will be set to x position of /ITL/scene/obj at the time of the script evaluation (that may be different to 0.1).","title":"Message based parameters"},{"location":"lang/1-scripting/#javascript","text":"INScore supports Javascript as scripting languages. Javascript is embedded using the Qt Javascript engine. A script section is indicated similarly to a Javascript section in html i.e. enclosed in an opening <? and a closing ?> . script ComplexDiagram( Sequence ('<?', 'javascript', NonTerminal('script'), '?>') ).addTo() The principle of using Javascript sections in INScore files is the following: the Javascript sections are passed to the Javascript engine and are expected to produce textual INScore messages on output. These messages are then parsed as if replacing the corresponding script section. INScore variables are exported to the Javascript environment. Note: A Javascript section may produce not output, for example when it declares functions to be used later. Example <? javascript \"/ITL/scene/version set txt 'Javascript v. \" + version() + \"';\" ?> A single persistent Javascript context is created at application level and shared with each scene.","title":"Javascript"},{"location":"lang/1-scripting/#the-javascript-object","text":"The Javascript engine is available at runtime at the address /ITL/ scene /javascript . It has a run method that takes a javascript string as parameter. javascript ComplexDiagram( Sequence ('run', 'code') ).addTo() The run method evaluates the code. Similarly to javascript sections in scripts, the output of the evaluation is expected to be a string containing valid INScore messages that are next executed. Actually, including a javascript section in a script is equivalent to send the run message with the same code as parameter to the javascript object. The Javascript engine is based on the Qt5 Javascrip engine, extended with INScore specific functions: version() : gives the javascript engine version number as a string. print(val1 [, val2 [, ...]]) : print the arguments to the OSC standard output. The arguments list is prefixed by 'javascript:'. The function is provided for debug purpose. readfile(file) : read a file and returns its content as a string. The file name could be specified as an absolute or relative path. When relative, the file is searched in the application current rootPath . post(address [,...]) : build an OSC message and post it for delayed processing i.e. to be processed by the next time task. address is an OSC or an extended OSC address. Optional arguments are the message parameters. osname() : gives the current operating system name. osid() : gives the current operating system as a numeric identifiant. Returned value is (in alphabetic order): 1 for Android 2 for iOS. 3 for Linux, 4 for MacOS, 5 for Windows Example Posting a message from a Javascript section: <?javascript post (\"/ITL/scene/obj\", \"dalpha\", -1);\"; // The message /ITL/scene/obj dalpha -1 // will be evaluated by the next time task. ?> Declaration of a Javascript function to be used later: <?javascript // declare a function foo() function foo(arg) { return \"/ITL/scene/obj set txt foo called with \" + arg + \";\"; } ?> # call the foo function <?javascript foo(1)?> # or call the foo function using the run message /ITL/scene/javascript run \"foo(1)\";","title":"The Javascript object"},{"location":"lang/1-scripting/#comments","text":"There are two ways to comment code inside a script: line comments: the '#' character is used for line comments, anything after a '#' is ignored. section comments: section comments start with '( ' and end with ' )', anything between them is ignored. Example # this is a line comment /ITL/scene/* del; (* here is a section comment section comments are multi-lines comments {*}) /ITL/scene/hello set txt \"Hello world!\"; # the preceding message is not commented \\inscoreend and everything below the \\inscoreend marker is also ignored","title":"Comments"},{"location":"lang/2-mathExpr/","text":"Mathematical expressions Since INScore version 1.20, mathematical expressions have been introduced as messages arguments. These expressions allows to compute values at parsing time. Operators Basic mathematical expressions are supported. They are listed below. mathexpr ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('matharg'), '+', NonTerminal('matharg')), Sequence (Comment ('2'), NonTerminal('matharg'), '-', NonTerminal('matharg')), Sequence (Comment ('3'), '-', NonTerminal('matharg')), Sequence (Comment ('4'), NonTerminal('matharg'), '*', NonTerminal('matharg')), Sequence (Comment ('5'), NonTerminal('matharg'), '/', NonTerminal('matharg')), Sequence (Comment ('6'), NonTerminal('matharg'), '%', NonTerminal('matharg')), Sequence (Comment ('7'), '(', NonTerminal('mathexpr'), ')'), Sequence (Comment ('8'), 'max', '(', OneOrMore (NonTerminal('matharg')), ')'), Sequence (Comment ('9'), 'min', '(', OneOrMore (NonTerminal('matharg')), ')'), Sequence (Comment ('10'), '(', NonTerminal('mathbool'), '?', NonTerminal('matharg'), ':', NonTerminal('matharg'), ')')) ).addTo() Note that matharg could be a mathexpr as well (see section mathargs ). 1 : addition. 2 : substraction. 3 : negation. 4 : multiplication. 5 : division. 6 : modulo. 7 : parenthesis, to be used for evaluation order. 8 : gives the maximum value. 9 : gives the minimum value. 10 : conditional form: returns the first matharg if mathbool is true, otherwise returns the second one. Example Some simple mathematical expressions used as message parameters: /ITL/scene/myObject x 0.5 * 0.2; /ITL/scene/myObject y ($var ? 1 : -1); Boolean operations are the following: mathbool ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('arg')), Sequence (Comment ('2'), '!', NonTerminal('arg')), Sequence (Comment ('3'), NonTerminal('arg'), '==', NonTerminal('arg')), Sequence (Comment ('4'), NonTerminal('arg'), '>', NonTerminal('arg')), Sequence (Comment ('5'), NonTerminal('arg'), '>=', NonTerminal('arg')), Sequence (Comment ('6'), NonTerminal('arg'), '<', NonTerminal('arg')), Sequence (Comment ('7'), NonTerminal('arg'), '<=', NonTerminal('arg'))) ).addTo() 1 : evaluate the argument as a boolean value. 2 : evaluate the argument as a boolean value and negates the result. 3 : check if the arguments are equal. 4 : check if the first argument is greater than the second one. 5 : check if the first argument is greater or equel to the second one. 6 : check if the first argument is less than the second one. 7 : check if the first argument is less or equal to the second one. Example Compare two variables: /ITL/scene/myObject x ($var1 > $var2 ? 1 : -1); Arguments Arguments of mathematical operations are the following: matharg ComplexDiagram( Choice (0, Sequence (Comment ('1'), 'param'), Sequence (Comment ('2'), 'variable'), Sequence (Comment ('3'), 'variable', Choice (0, '++', '--')), Sequence (Comment ('4'), Choice (0, '++', '- -'), 'variable'), Sequence (Comment ('5'), 'msgvariable'), Sequence (Comment ('6'), NonTerminal('mathexpr'))) ).addTo() 1 : any message parameter. 2 : a variable value. 3 : a variable that is post incremented or post decremented. 4 : a variable that is pre incremented or pre decremented. 5 : a message based variable. 6 : a mathematical expression. Polymorphism Since INScore's parameters are polymorphic, the semantic of the operations are to be defined notably when applied to non numeric arguments. Actually, a basic OSC message parameter type is between int32 , float32 and string . However, due to the extension of the scripting language, parameters could also be arrays of any type, including mixed types (e.g. resulting from variable declarations). Numeric values For numeric arguments, automatic type conversion is applied with a precedence of float32 i.e. when one of the argument's type is float32 , the result is also float32 (see Table table:mathopnum ). arg1 arg2 output int32 int32 int32 float32 int32 float32 int32 float32 float32 float32 float32 float32 Numeric operations output Strings For string parameters, operations that have an obvious semantic (like + applied to two strings) are defined (see Table table:mathopstr ) , the others are undefined and generate an error (see Table table:mathnoopstr ). operation evaluates to comment string + string string concatenate the two strings string + num string + string (num) num is converted to string num + string string (num) + string \" @max( string string ) string select the largest string @min( string string ) string select the smallest string Supported operations on strings operation comment string op string where op is in [- * / string op num \" num op string \" - string prefixed or postfixed string Non supported operations on strings Boolean operations are supported on string only when both arguments are strings (see Table table:mathboolstr ). Other types combination generate an error. boolean operation evaluated as string == string regular strings comparison string > string alphabetical strings comparison string >= string \" string < string \" string <= string \" Supported boolean operations on strings Arrays For arrays, the operation is distributed inside the array elements: arg op[v_1\\ ...\\ v_n] := [arg\\ op\\ v_1\\ ...\\ arg\\ op\\ v_n] or [v_1 ...v_n]\\ op\\ arg := [v_1\\ op\\ arg\\ ...\\ v_n\\ op\\ arg] When both parameters are arrays, the operation is distributed from one array elements to the other array elements when the arrays have the same size and it generates an error when the sizes differ: [a_1 ...a_i]\\ op\\ [b_1\\ ...\\ b_i] := [a_1\\ op\\ b_1\\ ...\\ a_i\\ op\\ b_i\\ ] Boolean operations on arrays are evaluated as the logical and of it's element's boolean values and generate an error when the arrays sizes differ.","title":"Math. expressions"},{"location":"lang/2-mathExpr/#mathematical-expressions","text":"Since INScore version 1.20, mathematical expressions have been introduced as messages arguments. These expressions allows to compute values at parsing time.","title":"Mathematical expressions"},{"location":"lang/2-mathExpr/#operators","text":"Basic mathematical expressions are supported. They are listed below. mathexpr ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('matharg'), '+', NonTerminal('matharg')), Sequence (Comment ('2'), NonTerminal('matharg'), '-', NonTerminal('matharg')), Sequence (Comment ('3'), '-', NonTerminal('matharg')), Sequence (Comment ('4'), NonTerminal('matharg'), '*', NonTerminal('matharg')), Sequence (Comment ('5'), NonTerminal('matharg'), '/', NonTerminal('matharg')), Sequence (Comment ('6'), NonTerminal('matharg'), '%', NonTerminal('matharg')), Sequence (Comment ('7'), '(', NonTerminal('mathexpr'), ')'), Sequence (Comment ('8'), 'max', '(', OneOrMore (NonTerminal('matharg')), ')'), Sequence (Comment ('9'), 'min', '(', OneOrMore (NonTerminal('matharg')), ')'), Sequence (Comment ('10'), '(', NonTerminal('mathbool'), '?', NonTerminal('matharg'), ':', NonTerminal('matharg'), ')')) ).addTo() Note that matharg could be a mathexpr as well (see section mathargs ). 1 : addition. 2 : substraction. 3 : negation. 4 : multiplication. 5 : division. 6 : modulo. 7 : parenthesis, to be used for evaluation order. 8 : gives the maximum value. 9 : gives the minimum value. 10 : conditional form: returns the first matharg if mathbool is true, otherwise returns the second one. Example Some simple mathematical expressions used as message parameters: /ITL/scene/myObject x 0.5 * 0.2; /ITL/scene/myObject y ($var ? 1 : -1); Boolean operations are the following: mathbool ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('arg')), Sequence (Comment ('2'), '!', NonTerminal('arg')), Sequence (Comment ('3'), NonTerminal('arg'), '==', NonTerminal('arg')), Sequence (Comment ('4'), NonTerminal('arg'), '>', NonTerminal('arg')), Sequence (Comment ('5'), NonTerminal('arg'), '>=', NonTerminal('arg')), Sequence (Comment ('6'), NonTerminal('arg'), '<', NonTerminal('arg')), Sequence (Comment ('7'), NonTerminal('arg'), '<=', NonTerminal('arg'))) ).addTo() 1 : evaluate the argument as a boolean value. 2 : evaluate the argument as a boolean value and negates the result. 3 : check if the arguments are equal. 4 : check if the first argument is greater than the second one. 5 : check if the first argument is greater or equel to the second one. 6 : check if the first argument is less than the second one. 7 : check if the first argument is less or equal to the second one. Example Compare two variables: /ITL/scene/myObject x ($var1 > $var2 ? 1 : -1);","title":"Operators"},{"location":"lang/2-mathExpr/#arguments","text":"Arguments of mathematical operations are the following: matharg ComplexDiagram( Choice (0, Sequence (Comment ('1'), 'param'), Sequence (Comment ('2'), 'variable'), Sequence (Comment ('3'), 'variable', Choice (0, '++', '--')), Sequence (Comment ('4'), Choice (0, '++', '- -'), 'variable'), Sequence (Comment ('5'), 'msgvariable'), Sequence (Comment ('6'), NonTerminal('mathexpr'))) ).addTo() 1 : any message parameter. 2 : a variable value. 3 : a variable that is post incremented or post decremented. 4 : a variable that is pre incremented or pre decremented. 5 : a message based variable. 6 : a mathematical expression.","title":"Arguments"},{"location":"lang/2-mathExpr/#polymorphism","text":"Since INScore's parameters are polymorphic, the semantic of the operations are to be defined notably when applied to non numeric arguments. Actually, a basic OSC message parameter type is between int32 , float32 and string . However, due to the extension of the scripting language, parameters could also be arrays of any type, including mixed types (e.g. resulting from variable declarations).","title":"Polymorphism"},{"location":"lang/2-mathExpr/#numeric-values","text":"For numeric arguments, automatic type conversion is applied with a precedence of float32 i.e. when one of the argument's type is float32 , the result is also float32 (see Table table:mathopnum ). arg1 arg2 output int32 int32 int32 float32 int32 float32 int32 float32 float32 float32 float32 float32 Numeric operations output","title":"Numeric values"},{"location":"lang/2-mathExpr/#strings","text":"For string parameters, operations that have an obvious semantic (like + applied to two strings) are defined (see Table table:mathopstr ) , the others are undefined and generate an error (see Table table:mathnoopstr ). operation evaluates to comment string + string string concatenate the two strings string + num string + string (num) num is converted to string num + string string (num) + string \" @max( string string ) string select the largest string @min( string string ) string select the smallest string Supported operations on strings operation comment string op string where op is in [- * / string op num \" num op string \" - string prefixed or postfixed string Non supported operations on strings Boolean operations are supported on string only when both arguments are strings (see Table table:mathboolstr ). Other types combination generate an error. boolean operation evaluated as string == string regular strings comparison string > string alphabetical strings comparison string >= string \" string < string \" string <= string \" Supported boolean operations on strings","title":"Strings"},{"location":"lang/2-mathExpr/#arrays","text":"For arrays, the operation is distributed inside the array elements: arg op[v_1\\ ...\\ v_n] := [arg\\ op\\ v_1\\ ...\\ arg\\ op\\ v_n] or [v_1 ...v_n]\\ op\\ arg := [v_1\\ op\\ arg\\ ...\\ v_n\\ op\\ arg] When both parameters are arrays, the operation is distributed from one array elements to the other array elements when the arrays have the same size and it generates an error when the sizes differ: [a_1 ...a_i]\\ op\\ [b_1\\ ...\\ b_i] := [a_1\\ op\\ b_1\\ ...\\ a_i\\ op\\ b_i\\ ] Boolean operations on arrays are evaluated as the logical and of it's element's boolean values and generate an error when the arrays sizes differ.","title":"Arrays"},{"location":"lang/3-appendices/","text":"Appendices Grammar definition //_______________________________________________ // relaxed simple ITL format specification //_______________________________________________ start : expr | start expr ; //_______________________________________________ // expression of the script language //_______________________________________________ expr : message ENDEXPR | variabledecl ENDEXPR | script | ENDSCRIPT ; //_______________________________________________ // javascript and support //_______________________________________________ script : JSCRIPT ; //_______________________________________________ // messages specification (extends osc spec.) //_______________________________________________ message : address | address params | address eval LEFTPAR messagelist RIGHTPAR | address eval variable ; messagelist : message | messagelist messagelistseparator message ; messagelistseparator : COMMA | COLON ; //_______________________________________________ // address specification (extends osc spec.) address : oscaddress | relativeaddress | urlprefix oscaddress ; oscaddress : OSCADDRESS ; relativeaddress : POINT oscaddress ; urlprefix : hostname UINT | STRING COLON UINT | IPNUM COLON UINT ; hostname : HOSTNAME ; identifier : IDENTIFIER | HOSTNAME | REGEXP ; //_______________________________________________ // parameters definitions // eval need a special case since messages are expected as argument eval : EVAL | variable | params variable | params param ; params : sparam | params sparam | mathexpr | params mathexpr ; variable : VARIABLE | VARIABLEPOSTINC | VARIABLEPOSTDEC | VARIABLEPREINC | VARIABLEPREDEC ; msgvariable : VARSTART LEFTPAR message RIGHTPAR ; param : number | FLOAT | identifier | STRING ; sparam : expression | LEFTPAR messagelist RIGHTPAR | script ; //_______________________________________________ // math expressions mathexpr : param | variable | msgvariable | mathexpr ADD mathexpr | mathexpr SUB mathexpr | MINUS mathexpr | mathexpr MULT mathexpr | mathexpr DIV mathexpr | mathexpr MODULO mathexpr | LEFTPAR mathexpr RIGHTPAR | MIN LEFTPAR mathmin RIGHTPAR | MAX LEFTPAR mathmax RIGHTPAR | LEFTPAR mathbool QUEST mathexpr COLON mathexpr RIGHTPAR ; mathmin : mathexpr | mathmin mathexpr ; mathmax : mathexpr | mathmax mathexpr ; mathbool : mathexpr | NEG mathexpr | mathexpr EQ mathexpr | mathexpr NEQ mathexpr | mathexpr GREATER mathexpr | mathexpr GREATEREQ mathexpr | mathexpr LESS mathexpr | mathexpr LESSEQ mathexpr ; //_______________________________________________ // variable declaration variabledecl : varname EQUAL params ; varname : IDENTIFIER ; //_______________________________________________ // misc number : UINT | INT ; //_______________________________________________ // expression declaration expression : EXPRESSION ; Lexical tokens //_______________________________________________ // numbers //_______________________________________________ INT a signed integer UINT an unsigned integer FLOAT a floating point number //_______________________________________________ // hosts addresses //_______________________________________________ // allowed character set for host names (see RFC952 and RFC1123) HOSTNAME : [-a-zA-Z0-9]+ IPNUM : {DIGIT}+\".\"{DIGIT}+\".\"{DIGIT}+\".\"{DIGIT}+ //_______________________________________________ // OSC addresses //_______________________________________________ // allowed characters for identifiers IDENTIFIER : [_a-zA-Z][_a-zA-Z0-9]* REGEXP see OSC doc for regular expressions OSCADDRESS //_______________________________________________ // strings //_______________________________________________ STRING : (\"/\"|(\".\"\".\"?\"/\")*)([^ \\t/?:*><|\"';=]+\"/\"?)+\".\"[_a-zA-Z0-9]+ or quoted strings that can include any character quotes could be single (') or double quotes (\") //_______________________________________________ // scripting //_______________________________________________ JSCRIPT : <?javascript ...any javascript code... ?> VARIABLE : the name of a variable //_______________________________________________ // misc. //_______________________________________________ POINT : '.' VARSTART : '$' COLON : ':' COMMA : ',' LEFTPAR : '(' RIGHTPAR : ')' EQUAL : '=' ENDEXPR : ';' ENDSCRIPT : \"__END__\" EVAL : \"eval\" //_______________________________________________ // score expressions //_______________________________________________ EXPRESSION expr( a valid score expression ) see 'Score expressions grammar' //_______________________________________________ // math expressions //_______________________________________________ ADD : '+' DIV : '/' EQ : '==' GREATER : '>' GREATEREQ : '>=' LESS : '<' LESSEQ : '<=' MINUS : '-' MODULO : ' MULT : '*' NEG : '!' QUEST : ' ? ' SUB : '- ' MAX : '@max' MIN : '@min' VARIABLEPOSTDEC : $VAR-- VARIABLEPOSTINC : $VAR++ VARIABLEPREDEC : --$VAR VARIABLEPREINC : ++$VAR","title":"Grammar"},{"location":"lang/3-appendices/#appendices","text":"","title":"Appendices"},{"location":"lang/3-appendices/#grammar-definition","text":"//_______________________________________________ // relaxed simple ITL format specification //_______________________________________________ start : expr | start expr ; //_______________________________________________ // expression of the script language //_______________________________________________ expr : message ENDEXPR | variabledecl ENDEXPR | script | ENDSCRIPT ; //_______________________________________________ // javascript and support //_______________________________________________ script : JSCRIPT ; //_______________________________________________ // messages specification (extends osc spec.) //_______________________________________________ message : address | address params | address eval LEFTPAR messagelist RIGHTPAR | address eval variable ; messagelist : message | messagelist messagelistseparator message ; messagelistseparator : COMMA | COLON ; //_______________________________________________ // address specification (extends osc spec.) address : oscaddress | relativeaddress | urlprefix oscaddress ; oscaddress : OSCADDRESS ; relativeaddress : POINT oscaddress ; urlprefix : hostname UINT | STRING COLON UINT | IPNUM COLON UINT ; hostname : HOSTNAME ; identifier : IDENTIFIER | HOSTNAME | REGEXP ; //_______________________________________________ // parameters definitions // eval need a special case since messages are expected as argument eval : EVAL | variable | params variable | params param ; params : sparam | params sparam | mathexpr | params mathexpr ; variable : VARIABLE | VARIABLEPOSTINC | VARIABLEPOSTDEC | VARIABLEPREINC | VARIABLEPREDEC ; msgvariable : VARSTART LEFTPAR message RIGHTPAR ; param : number | FLOAT | identifier | STRING ; sparam : expression | LEFTPAR messagelist RIGHTPAR | script ; //_______________________________________________ // math expressions mathexpr : param | variable | msgvariable | mathexpr ADD mathexpr | mathexpr SUB mathexpr | MINUS mathexpr | mathexpr MULT mathexpr | mathexpr DIV mathexpr | mathexpr MODULO mathexpr | LEFTPAR mathexpr RIGHTPAR | MIN LEFTPAR mathmin RIGHTPAR | MAX LEFTPAR mathmax RIGHTPAR | LEFTPAR mathbool QUEST mathexpr COLON mathexpr RIGHTPAR ; mathmin : mathexpr | mathmin mathexpr ; mathmax : mathexpr | mathmax mathexpr ; mathbool : mathexpr | NEG mathexpr | mathexpr EQ mathexpr | mathexpr NEQ mathexpr | mathexpr GREATER mathexpr | mathexpr GREATEREQ mathexpr | mathexpr LESS mathexpr | mathexpr LESSEQ mathexpr ; //_______________________________________________ // variable declaration variabledecl : varname EQUAL params ; varname : IDENTIFIER ; //_______________________________________________ // misc number : UINT | INT ; //_______________________________________________ // expression declaration expression : EXPRESSION ;","title":"Grammar definition"},{"location":"lang/3-appendices/#lexical-tokens","text":"//_______________________________________________ // numbers //_______________________________________________ INT a signed integer UINT an unsigned integer FLOAT a floating point number //_______________________________________________ // hosts addresses //_______________________________________________ // allowed character set for host names (see RFC952 and RFC1123) HOSTNAME : [-a-zA-Z0-9]+ IPNUM : {DIGIT}+\".\"{DIGIT}+\".\"{DIGIT}+\".\"{DIGIT}+ //_______________________________________________ // OSC addresses //_______________________________________________ // allowed characters for identifiers IDENTIFIER : [_a-zA-Z][_a-zA-Z0-9]* REGEXP see OSC doc for regular expressions OSCADDRESS //_______________________________________________ // strings //_______________________________________________ STRING : (\"/\"|(\".\"\".\"?\"/\")*)([^ \\t/?:*><|\"';=]+\"/\"?)+\".\"[_a-zA-Z0-9]+ or quoted strings that can include any character quotes could be single (') or double quotes (\") //_______________________________________________ // scripting //_______________________________________________ JSCRIPT : <?javascript ...any javascript code... ?> VARIABLE : the name of a variable //_______________________________________________ // misc. //_______________________________________________ POINT : '.' VARSTART : '$' COLON : ':' COMMA : ',' LEFTPAR : '(' RIGHTPAR : ')' EQUAL : '=' ENDEXPR : ';' ENDSCRIPT : \"__END__\" EVAL : \"eval\" //_______________________________________________ // score expressions //_______________________________________________ EXPRESSION expr( a valid score expression ) see 'Score expressions grammar' //_______________________________________________ // math expressions //_______________________________________________ ADD : '+' DIV : '/' EQ : '==' GREATER : '>' GREATEREQ : '>=' LESS : '<' LESSEQ : '<=' MINUS : '-' MODULO : ' MULT : '*' NEG : '!' QUEST : ' ? ' SUB : '- ' MAX : '@max' MIN : '@min' VARIABLEPOSTDEC : $VAR-- VARIABLEPOSTINC : $VAR++ VARIABLEPREDEC : --$VAR VARIABLEPREINC : ++$VAR","title":"Lexical tokens"},{"location":"refs/","text":"Index Common messages map map+ mapf event alias alpha angle blue brightness color color del dx dy dz edit export exportAll green hsb hue lock name red saturation save scale show x y z set set get map name Effect messages blur colorize none shadow Faust Processor in max min out set (dsp file) set (dsp) set (plugin) File Watcher watch watch+ Forwarding accept cacert cert forward get key reject Gesture follower Gesture follower clear follow get gfActive gfEnter gfIdle gfLeave gflikelihood gfpos gfspeed learn learn likelihoodThreshold likelihoodwindow set size stop tolerance watch Graphic signal dimension fastgraph graph radialgraph set Httpd Server set status ITL debug osc ITL log clear level save scale show wrap ITL messages IP browse compatibility defaultShow errorAddress errport guido-version hello load mouse musicxml-version outport port preprocess quit rate read require rootPath scenes scount ticks time version ITL plugin path reset ITL stat get reset Interaction absx absy address cancel controlKey date doubleClick durEnter durLeave end endPaint error error event export keyDown keyUp mouseDown mouseEnter mouseLeave mouseMove mouseUp name newData newElement pageCount pop push rdate ready scene success sx sy timeEnter timeLeave touchBegin touchEnd touchUpdate watch watch+ x y Misc messages eval map pop push watch Position messages angle dalpha dangle dblue dbrightness dcolor dgreen dhsb dhue dred drotatex drotatey drotatez dsaturation dscale dx dxorigin dy dyorigin dz scale x xorigin y yorigin z Scene messages Scene messages absolutexy del foreground frameless fullscreen load new opengl preprocess reset rootPath Scene query Scene query count rcount sheight swidth Sensors accelerometer ambientlight autoscale calibrate compass gyroscope hasZ light magnetometer mode mode mode orientation proximity reset rotation run scale smooth tilt Set type arc audio curve ellipse fastgraph faust faustdsp file gmn gmnf gmnstream graph grid html htmlf httpd img layer line memimg musicxml musicxmlf pianoroll pianorollf pianorollstream polygon rect svg svgf txt txtf url video websocket Signal Signal connect connection default del disconnect get get parallel signal projection string reset size Specific messages dash dashDot dashDotDot dot penAlpha penColor penStyle penWidth pendAlpha solid animate animated arrows autoVoicesColoration bdiag black bold brushStyle clear clear clipPitch clipTime close columns cross demibold dense dense2 dense3 dense4 dense5 dense6 dense7 diagCross dpage drange dstart fdiag fontFamily fontSize fontStyle fontWeight height hor italic keyboard light linearCross measureBars none normal normal oblique page pageCount pageFormat pitchLines play play radius range rate rate rows solid start systemCount vdate vdate vduration vduration ver voiceColor volume volume width write write write Synchronization Guido map page staff system systemflat voice syncIdentifier Synchronization absolute get h hv relative syncBottom syncFrame syncHow syncOver syncPos syncStretch syncTop syncmode v Time messages clock date date\\%a date\\%f ddate dduration durClock duration tempo Transform messages dshear rotate shear","title":"Index"},{"location":"refs/#index","text":"","title":"Index"},{"location":"refs/#common-messages","text":"map map+ mapf event alias alpha angle blue brightness color color del dx dy dz edit export exportAll green hsb hue lock name red saturation save scale show x y z set set get map name","title":"Common messages"},{"location":"refs/#effect-messages","text":"blur colorize none shadow","title":"Effect messages"},{"location":"refs/#faust-processor","text":"in max min out set (dsp file) set (dsp) set (plugin)","title":"Faust Processor"},{"location":"refs/#file-watcher","text":"watch watch+","title":"File Watcher"},{"location":"refs/#forwarding","text":"accept cacert cert forward get key reject","title":"Forwarding"},{"location":"refs/#gesture-follower","text":"Gesture follower clear follow get gfActive gfEnter gfIdle gfLeave gflikelihood gfpos gfspeed learn learn likelihoodThreshold likelihoodwindow set size stop tolerance watch","title":"Gesture follower"},{"location":"refs/#graphic-signal","text":"dimension fastgraph graph radialgraph set","title":"Graphic signal"},{"location":"refs/#httpd-server","text":"set status","title":"Httpd Server"},{"location":"refs/#itl-debug","text":"osc","title":"ITL debug"},{"location":"refs/#itl-log","text":"clear level save scale show wrap","title":"ITL log"},{"location":"refs/#itl-messages","text":"IP browse compatibility defaultShow errorAddress errport guido-version hello load mouse musicxml-version outport port preprocess quit rate read require rootPath scenes scount ticks time version","title":"ITL messages"},{"location":"refs/#itl-plugin","text":"path reset","title":"ITL plugin"},{"location":"refs/#itl-stat","text":"get reset","title":"ITL stat"},{"location":"refs/#interaction","text":"absx absy address cancel controlKey date doubleClick durEnter durLeave end endPaint error error event export keyDown keyUp mouseDown mouseEnter mouseLeave mouseMove mouseUp name newData newElement pageCount pop push rdate ready scene success sx sy timeEnter timeLeave touchBegin touchEnd touchUpdate watch watch+ x y","title":"Interaction"},{"location":"refs/#misc-messages","text":"eval map pop push watch","title":"Misc messages"},{"location":"refs/#position-messages","text":"angle dalpha dangle dblue dbrightness dcolor dgreen dhsb dhue dred drotatex drotatey drotatez dsaturation dscale dx dxorigin dy dyorigin dz scale x xorigin y yorigin z","title":"Position messages"},{"location":"refs/#scene-messages","text":"Scene messages absolutexy del foreground frameless fullscreen load new opengl preprocess reset rootPath","title":"Scene messages"},{"location":"refs/#scene-query","text":"Scene query count rcount sheight swidth","title":"Scene query"},{"location":"refs/#sensors","text":"accelerometer ambientlight autoscale calibrate compass gyroscope hasZ light magnetometer mode mode mode orientation proximity reset rotation run scale smooth tilt","title":"Sensors"},{"location":"refs/#set-type","text":"arc audio curve ellipse fastgraph faust faustdsp file gmn gmnf gmnstream graph grid html htmlf httpd img layer line memimg musicxml musicxmlf pianoroll pianorollf pianorollstream polygon rect svg svgf txt txtf url video websocket","title":"Set type"},{"location":"refs/#signal","text":"Signal connect connection default del disconnect get get parallel signal projection string reset size","title":"Signal"},{"location":"refs/#specific-messages","text":"dash dashDot dashDotDot dot penAlpha penColor penStyle penWidth pendAlpha solid animate animated arrows autoVoicesColoration bdiag black bold brushStyle clear clear clipPitch clipTime close columns cross demibold dense dense2 dense3 dense4 dense5 dense6 dense7 diagCross dpage drange dstart fdiag fontFamily fontSize fontStyle fontWeight height hor italic keyboard light linearCross measureBars none normal normal oblique page pageCount pageFormat pitchLines play play radius range rate rate rows solid start systemCount vdate vdate vduration vduration ver voiceColor volume volume width write write write","title":"Specific messages"},{"location":"refs/#synchronization","text":"Guido map page staff system systemflat voice syncIdentifier Synchronization absolute get h hv relative syncBottom syncFrame syncHow syncOver syncPos syncStretch syncTop syncmode v","title":"Synchronization"},{"location":"refs/#time-messages","text":"clock date date\\%a date\\%f ddate dduration durClock duration tempo","title":"Time messages"},{"location":"refs/#transform-messages","text":"dshear rotate shear","title":"Transform messages"},{"location":"refs/1-introduction/","text":"Introduction INScore is an environment for the design of augmented, interactive, dynamic musical scores, oriented towards unconventional uses of music notation and representation, including real-time symbolic notation capabilities. This environment is fully controllable using Open Sound Control [OSC] messages. This document presents all the messages supported by the system. A scripting language has been defined as an extended textual version of OSC messages that allows you to design scores in a modular and incremental way. This language is close to the present specification. Its syntax and grammar are described in a separate document. Note Throughout the documentation, the sample code are given using scripting syntax i.e. that OSC messages are suffixed with a semi-colon ';'. This semi-colon is used as a message separator in INScore scripts and is not needed when sending messages over a network. See the INScore language reference for more information.","title":"Introduction"},{"location":"refs/1-introduction/#introduction","text":"INScore is an environment for the design of augmented, interactive, dynamic musical scores, oriented towards unconventional uses of music notation and representation, including real-time symbolic notation capabilities. This environment is fully controllable using Open Sound Control [OSC] messages. This document presents all the messages supported by the system. A scripting language has been defined as an extended textual version of OSC messages that allows you to design scores in a modular and incremental way. This language is close to the present specification. Its syntax and grammar are described in a separate document. Note Throughout the documentation, the sample code are given using scripting syntax i.e. that OSC messages are suffixed with a semi-colon ';'. This semi-colon is used as a message separator in INScore scripts and is not needed when sending messages over a network. See the INScore language reference for more information.","title":"Introduction"},{"location":"refs/10-scene/","text":"Scene messages A scene may be viewed as a window on the score elements. Its address is /ITL/ sceneIdentifier where sceneIdentifier is a user defined scene name. A scene named scene is created on startup. Scene control The following messages are available at scene level, to control the scene appearance and behaviour: sceneMsg ComplexDiagram( Choice (0, 'new', 'del', 'reset', 'foreground', Sequence ('rootPath', Optional (NonTerminal('path')) ), Sequence ('preprocess', NonTerminal('file')), Sequence ('load', NonTerminal('filePath')), Sequence ('fullscreen', NonTerminal('int32')), Sequence ('frameless', NonTerminal('int32')), Sequence ('absolutexy', NonTerminal('int32')), Sequence ('windowOpacity', NonTerminal('int32')), NonTerminal('commonMsg'), NonTerminal('forwardingMsg')) ).addTo() new : creates a new scene and opens it in a new window. del : deletes a scene and closes the corresponding window. reset : clears the scene (i.e. delete all components) and resets the scene to its default state (position, size and color). foreground : display scene window in foreground of all other windows in the system windows manager. rootPath : rootPath of a scene is the default path where the scene reads or writes a file when a relative path is used for this file. When no value has been specified, the application rootPath is used. Calling rootPath without argument clears the scene rootPath . preprocess : evaluates the input file script and print the result to the log window. load : loads an INScore file to the scene. Note that the OSC addresses are translated to the scene OSC address. fullscreen : requests the scene to switch to full screen or normal screen. The parameter is interpreted as a boolean value. Default value is 0 . frameless : requests the scene to switch to frameless or normal window. The parameter is interpreted as a boolean value. Default value is 0 . absolutexy : requests the scene to absolute or relative coordinates. Absolute coordinates are in pixels relative to the top left corner of the screen. Relative coordinates are in the range [-1, 1] where [0,0] is the center of the screen. The message parameter is interpreted as a boolean value. Default value is 0 . windowOpacity : switch the scene window to opaque or transparent mode. When in transparent mode, the scene alpha channel controls the window opacity (from completely opaque to completely transparent). In opaque mode, the scene alpha channel controls the background brush only. Default value is 0 (transparent). commonMsg : a scene support the common graphic attributes. See section common . forwardingMsg : a scene support message forwading and filtering. See section \\fullref{forwarding}. Example Setting a scene current path: /ITL/scene rootPath \"/path/to/my/folder\"; Loading an INScore file: /ITL/scene load \"myscript.inscore\"; will load /path/to/my/folder/myscript.inscore into the scene. Setting a scene to fullscreen: /ITL/scene fullscreen 1; Creating a new score named myScore : /ITL/myScore new; OpenGl rendering A scene supports optional OpenGl rendering. openglMsg ComplexDiagram( Sequence ('opengl', NonTerminal('int32')) ).addTo() opengl : requests the scene to switch to OpenGl or normal rendering. The parameter is interpreted as a boolean value. Default value is 0 . Note: OpenGl rendering improves significantly the performance of graphic operations but at the cost of dirty rendering for text and scores. Scene queries A scene may respond to queries regarding its elements: sceneQuery ComplexDiagram( Sequence ('get', Choice (0, 'count', 'rcount', 'swidth', 'sheight')) ).addTo() count : count the number of elements in the scene. rcount : recursively count the number of elements in the scene. swidth : gives the scene width from objects viewpoint (see the note about scene dimensions below). sheight : gives the scene height from objects viewpoint (see the note about scene dimensions below). Example Counting the elements in a scene: /ITL/scene get count; will give a message like the following as output: /ITL/scene count 200; Note: About the scene dimensions Similarly to any object, the scene width and height (set using the width and height messages) are expressed regarding its parent (i.e. the screen). The swidth and sheight messages give the scene dimensions as seen by embedded objects. They are provided for convenience since the returned values can be computed from the current width and height. Example Fill a scene with a rectangle: /ITL/scene/r set rect $(/ITL/scene get swidth) $(/ITL/scene get sheight);","title":"Scene Messages"},{"location":"refs/10-scene/#scene-messages","text":"A scene may be viewed as a window on the score elements. Its address is /ITL/ sceneIdentifier where sceneIdentifier is a user defined scene name. A scene named scene is created on startup.","title":"Scene messages"},{"location":"refs/10-scene/#scene-control","text":"The following messages are available at scene level, to control the scene appearance and behaviour: sceneMsg ComplexDiagram( Choice (0, 'new', 'del', 'reset', 'foreground', Sequence ('rootPath', Optional (NonTerminal('path')) ), Sequence ('preprocess', NonTerminal('file')), Sequence ('load', NonTerminal('filePath')), Sequence ('fullscreen', NonTerminal('int32')), Sequence ('frameless', NonTerminal('int32')), Sequence ('absolutexy', NonTerminal('int32')), Sequence ('windowOpacity', NonTerminal('int32')), NonTerminal('commonMsg'), NonTerminal('forwardingMsg')) ).addTo() new : creates a new scene and opens it in a new window. del : deletes a scene and closes the corresponding window. reset : clears the scene (i.e. delete all components) and resets the scene to its default state (position, size and color). foreground : display scene window in foreground of all other windows in the system windows manager. rootPath : rootPath of a scene is the default path where the scene reads or writes a file when a relative path is used for this file. When no value has been specified, the application rootPath is used. Calling rootPath without argument clears the scene rootPath . preprocess : evaluates the input file script and print the result to the log window. load : loads an INScore file to the scene. Note that the OSC addresses are translated to the scene OSC address. fullscreen : requests the scene to switch to full screen or normal screen. The parameter is interpreted as a boolean value. Default value is 0 . frameless : requests the scene to switch to frameless or normal window. The parameter is interpreted as a boolean value. Default value is 0 . absolutexy : requests the scene to absolute or relative coordinates. Absolute coordinates are in pixels relative to the top left corner of the screen. Relative coordinates are in the range [-1, 1] where [0,0] is the center of the screen. The message parameter is interpreted as a boolean value. Default value is 0 . windowOpacity : switch the scene window to opaque or transparent mode. When in transparent mode, the scene alpha channel controls the window opacity (from completely opaque to completely transparent). In opaque mode, the scene alpha channel controls the background brush only. Default value is 0 (transparent). commonMsg : a scene support the common graphic attributes. See section common . forwardingMsg : a scene support message forwading and filtering. See section \\fullref{forwarding}. Example Setting a scene current path: /ITL/scene rootPath \"/path/to/my/folder\"; Loading an INScore file: /ITL/scene load \"myscript.inscore\"; will load /path/to/my/folder/myscript.inscore into the scene. Setting a scene to fullscreen: /ITL/scene fullscreen 1; Creating a new score named myScore : /ITL/myScore new;","title":"Scene control"},{"location":"refs/10-scene/#opengl-rendering","text":"A scene supports optional OpenGl rendering. openglMsg ComplexDiagram( Sequence ('opengl', NonTerminal('int32')) ).addTo() opengl : requests the scene to switch to OpenGl or normal rendering. The parameter is interpreted as a boolean value. Default value is 0 . Note: OpenGl rendering improves significantly the performance of graphic operations but at the cost of dirty rendering for text and scores.","title":"OpenGl rendering"},{"location":"refs/10-scene/#scene-queries","text":"A scene may respond to queries regarding its elements: sceneQuery ComplexDiagram( Sequence ('get', Choice (0, 'count', 'rcount', 'swidth', 'sheight')) ).addTo() count : count the number of elements in the scene. rcount : recursively count the number of elements in the scene. swidth : gives the scene width from objects viewpoint (see the note about scene dimensions below). sheight : gives the scene height from objects viewpoint (see the note about scene dimensions below). Example Counting the elements in a scene: /ITL/scene get count; will give a message like the following as output: /ITL/scene count 200; Note: About the scene dimensions Similarly to any object, the scene width and height (set using the width and height messages) are expressed regarding its parent (i.e. the screen). The swidth and sheight messages give the scene dimensions as seen by embedded objects. They are provided for convenience since the returned values can be computed from the current width and height. Example Fill a scene with a rectangle: /ITL/scene/r set rect $(/ITL/scene get swidth) $(/ITL/scene get sheight);","title":"Scene queries"},{"location":"refs/11-forwarding/","text":"Messages forwarding The messages handled by the application or by a scene can be forwarded to arbitrary remote hosts. A filtering mecanism can be used to have a fine control of forwarded messages. Remote hosts list Remote hosts lists can be set using the forward message at scene or application level. Hosts lists of the application and of each scene are independent. At scene level, only messages handle by the scene are forwarded (ie message for the scene itself or for one of his children object). The forward message itself can't be forwarded. A message from a host cannot be forwarded to him to avoid direct loop. ITLMsgForward ComplexDiagram( Sequence ('forward', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('ForwardDest'))))) ).addTo() 1) removes the set of forward destinations, 2) set or extends the list of remote hosts for forwarding. ForwardDest ComplexDiagram( OneOrMore (Sequence (Choice (0, Sequence (Comment ('1'), NonTerminal('hostname')), Sequence (Comment ('2'), 'osc://', NonTerminal('hostname')), Sequence (Comment ('3'), 'http://', NonTerminal('hostname')), Sequence (Comment ('4'), 'https://', NonTerminal('hostname')), Sequence (Comment ('5'), 'ws://', NonTerminal('hostname'))), Optional ( Sequence (':', NonTerminal('portnum'))))) ).addTo() The forwarding mechanism can use different protocols, expressed by the destination in the form of an url, optionally followed by a port number separated by a semi-colon. By default, when no port number is specified, the default application listening port number is used (7000). 1) obsolete form preserved for compatibility: it's equivalent to 2). 2) messages are forwarded using the OSC protocol. 3) messages are forwarded in textual form using the HTTP protocol. 3) messages are forwarded in textual form using the HTTPS protocol. See section SSL about additional requirements for encrypted connections. 5) messages are forwarded in textual form using WebSockets. Example Forwards messages at application level to host1.adomain.org using OSC and the default application listening port number (7000) and to host2.adomain.org using HTTP on port number 5100 . /ITL forward osc://host1.adomain.org http://host2.adomain.org:5100; SSL support When you use https as a communication protocol, a digital certificate and an encryption key are required to establish connections between INScore and the client stations. The certificate must be signed by a trusted certificate authority. Short term certificates are freely available on the internet. Before issuing a forward message on an encrypted communication channel, the key and certificate must be loaded by INScore. For this purpose, a set of messages is provided by the application ssl node /ITL/ssl : SslSetup ComplexDiagram( Sequence (Choice (0, 'key', 'cert', 'cacert'), NonTerminal('file')) ).addTo() key load 'file' as private key cert load 'file' as digital certificate cacert load 'file' as intermediate certificate used as certificate authority file is a path to a file that can be absolute or relative. Resolution of relative paths differs from the approach used with rootPath : a path expressed as relative will always refer to the .ssh folder located at the root of the user directory ($HOME). Filters The messages forwarded to arbitrary remote hosts using the forward message can be filtered to send only wanted messages. The static filter node is use manage the filter. A static filter node is created for each scene and one at application level. The filter can be construct with OSC address and messages. ITLFilteringForward ComplexDiagram( Choice (0, Sequence (Comment ('1'), Sequence ('accept', Optional ( OneOrMore (NonTerminal('item'))))), Sequence (Comment ('2'), Sequence ('reject', Optional ( OneOrMore (NonTerminal('item')))))) ).addTo() 1) Replace the current accepted list by the new list or by an empty list. Item in accepted list are not filtered by the reject item list. 2) Replace the current accepted list by the new list or by an empty list. Item in reject list are filtered if they not match the accept list. When a new message is incoming, if they match to an accepted item, filter is not apply. Example Filter at application level : /ITL/filter reject /ITL/scene/line* /ITL/scene/rect; /ITL/filter accept /ITL/scene/line2 scale arrows; Messages with address starting with /ITL/scene/line or addressed to /ITL/scene/rect are filtered only if message address is not /ITL/scene/line2 or if the content is not scale or arrows . Filter at scene level : /ITL/scene1/filter reject fontWeight /ITL/scene1/rect; The fontWeight message and message for /ITL/scene1/rect are rejected. Note: INScore is message based in a consistent way: all actions are triggered by messages (including, for example, quitting the application). Some messages are generated internally. This is the case of ddate : an object sends ddate messages to itself when its tempo is not zero. It is therefore recommended to filter ddate : in the absence of a filter, a recipient who receives a tempo message will generate these messages internally, but will also receive those that have been forwarded. Its actual tempo will then be twice the one set. Specific queries When using connection oriented protocols with the forward message ( http , https , ws ), you can query the number of connected clients: ITLClientsQuery ComplexDiagram( Sequence ('get', 'clients') ).addTo() The message must be addressed at the application level ( /ITL ). The answer is detailed for each type of connection-oriented protocol in service.","title":"Messages Forwarding"},{"location":"refs/11-forwarding/#messages-forwarding","text":"The messages handled by the application or by a scene can be forwarded to arbitrary remote hosts. A filtering mecanism can be used to have a fine control of forwarded messages.","title":"Messages forwarding"},{"location":"refs/11-forwarding/#remote-hosts-list","text":"Remote hosts lists can be set using the forward message at scene or application level. Hosts lists of the application and of each scene are independent. At scene level, only messages handle by the scene are forwarded (ie message for the scene itself or for one of his children object). The forward message itself can't be forwarded. A message from a host cannot be forwarded to him to avoid direct loop. ITLMsgForward ComplexDiagram( Sequence ('forward', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('ForwardDest'))))) ).addTo() 1) removes the set of forward destinations, 2) set or extends the list of remote hosts for forwarding. ForwardDest ComplexDiagram( OneOrMore (Sequence (Choice (0, Sequence (Comment ('1'), NonTerminal('hostname')), Sequence (Comment ('2'), 'osc://', NonTerminal('hostname')), Sequence (Comment ('3'), 'http://', NonTerminal('hostname')), Sequence (Comment ('4'), 'https://', NonTerminal('hostname')), Sequence (Comment ('5'), 'ws://', NonTerminal('hostname'))), Optional ( Sequence (':', NonTerminal('portnum'))))) ).addTo() The forwarding mechanism can use different protocols, expressed by the destination in the form of an url, optionally followed by a port number separated by a semi-colon. By default, when no port number is specified, the default application listening port number is used (7000). 1) obsolete form preserved for compatibility: it's equivalent to 2). 2) messages are forwarded using the OSC protocol. 3) messages are forwarded in textual form using the HTTP protocol. 3) messages are forwarded in textual form using the HTTPS protocol. See section SSL about additional requirements for encrypted connections. 5) messages are forwarded in textual form using WebSockets. Example Forwards messages at application level to host1.adomain.org using OSC and the default application listening port number (7000) and to host2.adomain.org using HTTP on port number 5100 . /ITL forward osc://host1.adomain.org http://host2.adomain.org:5100;","title":"Remote hosts list"},{"location":"refs/11-forwarding/#ssl-support","text":"When you use https as a communication protocol, a digital certificate and an encryption key are required to establish connections between INScore and the client stations. The certificate must be signed by a trusted certificate authority. Short term certificates are freely available on the internet. Before issuing a forward message on an encrypted communication channel, the key and certificate must be loaded by INScore. For this purpose, a set of messages is provided by the application ssl node /ITL/ssl : SslSetup ComplexDiagram( Sequence (Choice (0, 'key', 'cert', 'cacert'), NonTerminal('file')) ).addTo() key load 'file' as private key cert load 'file' as digital certificate cacert load 'file' as intermediate certificate used as certificate authority file is a path to a file that can be absolute or relative. Resolution of relative paths differs from the approach used with rootPath : a path expressed as relative will always refer to the .ssh folder located at the root of the user directory ($HOME).","title":"SSL support"},{"location":"refs/11-forwarding/#filters","text":"The messages forwarded to arbitrary remote hosts using the forward message can be filtered to send only wanted messages. The static filter node is use manage the filter. A static filter node is created for each scene and one at application level. The filter can be construct with OSC address and messages. ITLFilteringForward ComplexDiagram( Choice (0, Sequence (Comment ('1'), Sequence ('accept', Optional ( OneOrMore (NonTerminal('item'))))), Sequence (Comment ('2'), Sequence ('reject', Optional ( OneOrMore (NonTerminal('item')))))) ).addTo() 1) Replace the current accepted list by the new list or by an empty list. Item in accepted list are not filtered by the reject item list. 2) Replace the current accepted list by the new list or by an empty list. Item in reject list are filtered if they not match the accept list. When a new message is incoming, if they match to an accepted item, filter is not apply. Example Filter at application level : /ITL/filter reject /ITL/scene/line* /ITL/scene/rect; /ITL/filter accept /ITL/scene/line2 scale arrows; Messages with address starting with /ITL/scene/line or addressed to /ITL/scene/rect are filtered only if message address is not /ITL/scene/line2 or if the content is not scale or arrows . Filter at scene level : /ITL/scene1/filter reject fontWeight /ITL/scene1/rect; The fontWeight message and message for /ITL/scene1/rect are rejected. Note: INScore is message based in a consistent way: all actions are triggered by messages (including, for example, quitting the application). Some messages are generated internally. This is the case of ddate : an object sends ddate messages to itself when its tempo is not zero. It is therefore recommended to filter ddate : in the absence of a filter, a recipient who receives a tempo message will generate these messages internally, but will also receive those that have been forwarded. Its actual tempo will then be twice the one set.","title":"Filters"},{"location":"refs/11-forwarding/#specific-queries","text":"When using connection oriented protocols with the forward message ( http , https , ws ), you can query the number of connected clients: ITLClientsQuery ComplexDiagram( Sequence ('get', 'clients') ).addTo() The message must be addressed at the application level ( /ITL ). The answer is detailed for each type of connection-oriented protocol in service.","title":"Specific queries"},{"location":"refs/12-layers/","text":"Layers Layers may be viewed as containers or as groups. They represent a way to structure both the address space and the graphic space. From graphic viewpoint, a layer is a scene inside a scene. All the properties of 'rect' components are available to layers: position, scale, color, transparency, etc.). By default, a layer is not visible: it has no brush and no pen, but changing the brush style (see section brush ) - e.g. to solid - makes it visible. From time viewpoint, a layer has the common time attributes i.e. a date, a duration. A layer may be synchronized to other objects, including other layers. It includes a sync node and supports synhcronization of the enclosed objects. However, synchronization is restricted to objects from the same layer and cannot cross the border of a layer. Example Creating a layer and its content: /ITL/scene/layer1 set layer; /ITL/scene/layer1/score set gmnf 'myscore.gmn'; /ITL/scene/layer1/cursor set rect 0.01 0.1; Synchronizing 2 components of a layer : #'score' and 'cursor' must be enclosed in layer1 /ITL/scene/layer1/sync cursor score; Making a layer visible : /ITL/scene/layer1 brushStyle solid; /ITL/scene/layer1 color 120 120 120; Layers generalization The idea of layer is generalized to all the type of objects: any INScore object can be a container without depth limitation. Layers but also any object respond to the count and rcount queries described in section scenequery .","title":"Layers"},{"location":"refs/12-layers/#layers","text":"Layers may be viewed as containers or as groups. They represent a way to structure both the address space and the graphic space. From graphic viewpoint, a layer is a scene inside a scene. All the properties of 'rect' components are available to layers: position, scale, color, transparency, etc.). By default, a layer is not visible: it has no brush and no pen, but changing the brush style (see section brush ) - e.g. to solid - makes it visible. From time viewpoint, a layer has the common time attributes i.e. a date, a duration. A layer may be synchronized to other objects, including other layers. It includes a sync node and supports synhcronization of the enclosed objects. However, synchronization is restricted to objects from the same layer and cannot cross the border of a layer. Example Creating a layer and its content: /ITL/scene/layer1 set layer; /ITL/scene/layer1/score set gmnf 'myscore.gmn'; /ITL/scene/layer1/cursor set rect 0.01 0.1; Synchronizing 2 components of a layer : #'score' and 'cursor' must be enclosed in layer1 /ITL/scene/layer1/sync cursor score; Making a layer visible : /ITL/scene/layer1 brushStyle solid; /ITL/scene/layer1 color 120 120 120;","title":"Layers"},{"location":"refs/12-layers/#layers-generalization","text":"The idea of layer is generalized to all the type of objects: any INScore object can be a container without depth limitation. Layers but also any object respond to the count and rcount queries described in section scenequery .","title":"Layers generalization"},{"location":"refs/13-mapping/","text":"Mapping graphic space to time space Time to space mapping refers to the description of relationship between an object local graphic space and its time space. A mapping consists in a set of relations between the two spaces. INScore provides specific messages to describes mappings and to synchronize arbitrary objects i.e. to display their time relationships in the graphic space. The 'map' message The map messages can be sent to any address with the form /ITL/ scene /\\textit{identifier }. It is intended to describe the target object relation to time and sets a relation between an object segmentation and a time segmentation. The global form of the message is: mapMsg ComplexDiagram( Sequence ('map', Optional ( NonTerminal('mapName')), Choice (0, NonTerminal('relation'), NonTerminal('del'))) ).addTo() The relation parameter must be sent as a single string which format is described below. It consists in a list of associations between the object local space and its time space expressed as segments. relation ComplexDiagram( Choice (0, OneOrMore (Sequence (Comment ('1'), NonTerminal('float2DSegment'), NonTerminal('timeSegment'))), OneOrMore (Sequence (Comment ('2'), NonTerminal('int2DSegment'), NonTerminal('timeSegment'))), OneOrMore (Sequence (Comment ('3'), NonTerminal('int1DSegment'), NonTerminal('timeSegment')))) ).addTo() Segments are expressed as a list of intervals. For a 1 dimension resource, a segment is a made of a single interval. For a 2 dimensions resource, a segment is a made of 2 intervals: an interval on the x -axis and one on the y -axis for graphic based resource, or an interval on columns and one on lines for text based resources. Intervals are right-opened. The different kind of relations corresponds to: [1] a relation between a 2 dimensions segmentation expressed in float values and a relative time segmentation. These segmentations are used by rect, ellipse, polygon, curve, line components. [2] a relation between a 2 dimensions segmentation expressed in integer values and a relative time segmentation. These segmentations are used by txt, txtf, img components. [3] a relation between a 1 dimension segmentation expressed in integer values and a relative time segmentation. These segmentations are used by the graph component and express a relation between a signal space and time. Table maptable summarizes the specific local segmentation used by each component type. The specified map can be named with an optional mapName string; this name can be further reused, during object synchronization, to specify the mapping to use. When mapName is not specified, the mapping has a default empty name . The del command deletes the mapping specified with mapName , or the 'empty name' mapping if no map name is specified. component type segmentation type txt, txtf int2DSegments img int2DSegments rect, ellipse, polygon, curve float2DSegments graph int1DSegments Local segmentation type for each component Segments definitions timeSegment ComplexDiagram( Choice (0, NonTerminal('relativeTimeSegment'), NonTerminal('absoluteTimeSegment')) ).addTo() relativeTimeSegment ComplexDiagram( Sequence ('(', NonTerminal('relativeTimeInterval'), ')') ).addTo() absoluteTimeSegment ComplexDiagram( Sequence ('(', NonTerminal('absoluteTimeInterval'), ')') ).addTo() float2DSegment ComplexDiagram( Sequence ('(', NonTerminal('floatInterval'), NonTerminal('floatInterval'), ')') ).addTo() int2DSegment ComplexDiagram( Sequence ('(', NonTerminal('intInterval'), NonTerminal('intInterval'), ')') ).addTo() int1DSegment ComplexDiagram( Sequence ('(', NonTerminal('intInterval'), ')') ).addTo() relativeTimeInterval ComplexDiagram( Sequence ('[', NonTerminal('rational'), ',', NonTerminal('rational'), '[') ).addTo() absoluteTimeInterval ComplexDiagram( Sequence ('[', NonTerminal('absoluteTime'), ',', NonTerminal('absoluteTime'), '[') ).addTo() floatInterval ComplexDiagram( Sequence ('[', NonTerminal('float32'), ',', NonTerminal('float32'), '[') ).addTo() intInterval ComplexDiagram( Sequence ('[', NonTerminal('int32'), ',', NonTerminal('int32'), '[') ).addTo() Relative time is expressed as rational values where 1 represents a whole note. rational ComplexDiagram( Sequence (NonTerminal('int32'), '/', NonTerminal('int32')) ).addTo() Absolute time is expressed in minutes, seconds and cents. It is automatically converted to relative time, assuming that the tempo is 60 quarter notes per minute. absoluteTime ComplexDiagram( Sequence (\"min\", \":\", \"sec\", \":\", \"cents\") ).addTo() Example Mapping an image graphic space to time: /ITL/scene/myImage map \"( [0, 67[ [0, 86[ ) ( [0/2, 1/2[ ) ( [67, 113[ [0, 86[ ) ( [1/2, 1/1[ ) ( [113, 153[ [0, 86[ ) ( [1/1, 3/2[ ) ( [153, 190[ [0, 86[ ) ( [3/2, 2/1[ ) ( [190, 235[ [0, 86[ ) ( [2/1, 5/2[ )\" ; the image is horizontally segmented into 5 different graphic segments that express pixel positions. The vertical dimension of the segments remains the same and corresponds to the interval [0, 86[ . Each graphic segment is associated to a time interval which duration is 1/2 (a half note). The same mapping using absolute time assumes that 1 second is equal to 1 quarter note: /ITL/scene/myImage map \"( [0, 67[ [0, 86[ ) ( [0:0:0, 0:2:0[ ) ( [67, 113[ [0, 86[ ) ( [0:2:0, 0:4:0[ ) ( [113, 153[ [0, 86[ ) ( [0:4:0, 0:6:0[ ) ( [153, 190[ [0, 86[ ) ( [0:6:0, 0:8:0[ ) ( [190, 235[ [0, 86[ ) ( [0:8:0, 0:10:0[ )\" ; Note: about local spaces Text objects ( txt txtf ) local space is expressed by intervals on columns and rows. Html object ( html, htmlf ) do not support mapping because there is not correspondence between the text and the graphic space. Vectorial objects ( rect, ellipse, polygon, curve, svg,... ) express their local graphic space in internal coordinates system i.e. on the [-1.,1.] interval. Bitmap objects ( img ) express their local graphic space in pixels. The 'map+' message The map+ messages is similar to the map message but doesn't replace the existing mapping data: the specified relations are added to the existing one. mapAddMsg ComplexDiagram( Sequence ('map+', Optional ( NonTerminal('mapName')), NonTerminal('relation')) ).addTo() Mapping files The mapf messages is similar to the map message but gives the path name of a file containing the mapping data, along with the optional map name. mapfMsg ComplexDiagram( Sequence ('mapf', Optional ( NonTerminal('mapName')), NonTerminal('mapFilePath')) ).addTo() Symbolic score mappings Mapping between the graphic and time space is automatically computed for symbolic score gmn, gmnstream, gmnf . However and depending on the application, the graphic space may be segmented in different ways, for instance: different graphic segments for different staves, a single graphic segment traversing all a system, etc. Thus for a symbolic score, the map message different and is only intended to select one king mapping supported by the system. scoreMap ComplexDiagram( Sequence ('map', Choice (0, 'page', 'system', 'systemflat', 'staffn', 'voicen')) ).addTo() page : a page level mapping system : a system level mapping systemflat : a system level mapping without system subdivision (one graphic segment per system) staff_n _: a staff level mapping: the staff number is indicated by n , a number between 1 and the score staves count. voice_n _: a voice level mapping: the voice number is indicated by n , a number between 1 and the score voices count. The default mapping for a symbolic score is unnamed but equivalent to staff1 . Example Requesting the mapping of the third staff of a score: /ITL/scene/myScore map staff3; Requesting the system mapping : /ITL/scene/myScore map system; Note: A voice may be distributed on several staves and thus a staff may contain several voices.","title":"Mapping"},{"location":"refs/13-mapping/#mapping-graphic-space-to-time-space","text":"Time to space mapping refers to the description of relationship between an object local graphic space and its time space. A mapping consists in a set of relations between the two spaces. INScore provides specific messages to describes mappings and to synchronize arbitrary objects i.e. to display their time relationships in the graphic space.","title":"Mapping graphic space to time space"},{"location":"refs/13-mapping/#the-map-message","text":"The map messages can be sent to any address with the form /ITL/ scene /\\textit{identifier }. It is intended to describe the target object relation to time and sets a relation between an object segmentation and a time segmentation. The global form of the message is: mapMsg ComplexDiagram( Sequence ('map', Optional ( NonTerminal('mapName')), Choice (0, NonTerminal('relation'), NonTerminal('del'))) ).addTo() The relation parameter must be sent as a single string which format is described below. It consists in a list of associations between the object local space and its time space expressed as segments. relation ComplexDiagram( Choice (0, OneOrMore (Sequence (Comment ('1'), NonTerminal('float2DSegment'), NonTerminal('timeSegment'))), OneOrMore (Sequence (Comment ('2'), NonTerminal('int2DSegment'), NonTerminal('timeSegment'))), OneOrMore (Sequence (Comment ('3'), NonTerminal('int1DSegment'), NonTerminal('timeSegment')))) ).addTo() Segments are expressed as a list of intervals. For a 1 dimension resource, a segment is a made of a single interval. For a 2 dimensions resource, a segment is a made of 2 intervals: an interval on the x -axis and one on the y -axis for graphic based resource, or an interval on columns and one on lines for text based resources. Intervals are right-opened. The different kind of relations corresponds to: [1] a relation between a 2 dimensions segmentation expressed in float values and a relative time segmentation. These segmentations are used by rect, ellipse, polygon, curve, line components. [2] a relation between a 2 dimensions segmentation expressed in integer values and a relative time segmentation. These segmentations are used by txt, txtf, img components. [3] a relation between a 1 dimension segmentation expressed in integer values and a relative time segmentation. These segmentations are used by the graph component and express a relation between a signal space and time. Table maptable summarizes the specific local segmentation used by each component type. The specified map can be named with an optional mapName string; this name can be further reused, during object synchronization, to specify the mapping to use. When mapName is not specified, the mapping has a default empty name . The del command deletes the mapping specified with mapName , or the 'empty name' mapping if no map name is specified. component type segmentation type txt, txtf int2DSegments img int2DSegments rect, ellipse, polygon, curve float2DSegments graph int1DSegments Local segmentation type for each component","title":"The 'map' message"},{"location":"refs/13-mapping/#segments-definitions","text":"timeSegment ComplexDiagram( Choice (0, NonTerminal('relativeTimeSegment'), NonTerminal('absoluteTimeSegment')) ).addTo() relativeTimeSegment ComplexDiagram( Sequence ('(', NonTerminal('relativeTimeInterval'), ')') ).addTo() absoluteTimeSegment ComplexDiagram( Sequence ('(', NonTerminal('absoluteTimeInterval'), ')') ).addTo() float2DSegment ComplexDiagram( Sequence ('(', NonTerminal('floatInterval'), NonTerminal('floatInterval'), ')') ).addTo() int2DSegment ComplexDiagram( Sequence ('(', NonTerminal('intInterval'), NonTerminal('intInterval'), ')') ).addTo() int1DSegment ComplexDiagram( Sequence ('(', NonTerminal('intInterval'), ')') ).addTo() relativeTimeInterval ComplexDiagram( Sequence ('[', NonTerminal('rational'), ',', NonTerminal('rational'), '[') ).addTo() absoluteTimeInterval ComplexDiagram( Sequence ('[', NonTerminal('absoluteTime'), ',', NonTerminal('absoluteTime'), '[') ).addTo() floatInterval ComplexDiagram( Sequence ('[', NonTerminal('float32'), ',', NonTerminal('float32'), '[') ).addTo() intInterval ComplexDiagram( Sequence ('[', NonTerminal('int32'), ',', NonTerminal('int32'), '[') ).addTo() Relative time is expressed as rational values where 1 represents a whole note. rational ComplexDiagram( Sequence (NonTerminal('int32'), '/', NonTerminal('int32')) ).addTo() Absolute time is expressed in minutes, seconds and cents. It is automatically converted to relative time, assuming that the tempo is 60 quarter notes per minute. absoluteTime ComplexDiagram( Sequence (\"min\", \":\", \"sec\", \":\", \"cents\") ).addTo() Example Mapping an image graphic space to time: /ITL/scene/myImage map \"( [0, 67[ [0, 86[ ) ( [0/2, 1/2[ ) ( [67, 113[ [0, 86[ ) ( [1/2, 1/1[ ) ( [113, 153[ [0, 86[ ) ( [1/1, 3/2[ ) ( [153, 190[ [0, 86[ ) ( [3/2, 2/1[ ) ( [190, 235[ [0, 86[ ) ( [2/1, 5/2[ )\" ; the image is horizontally segmented into 5 different graphic segments that express pixel positions. The vertical dimension of the segments remains the same and corresponds to the interval [0, 86[ . Each graphic segment is associated to a time interval which duration is 1/2 (a half note). The same mapping using absolute time assumes that 1 second is equal to 1 quarter note: /ITL/scene/myImage map \"( [0, 67[ [0, 86[ ) ( [0:0:0, 0:2:0[ ) ( [67, 113[ [0, 86[ ) ( [0:2:0, 0:4:0[ ) ( [113, 153[ [0, 86[ ) ( [0:4:0, 0:6:0[ ) ( [153, 190[ [0, 86[ ) ( [0:6:0, 0:8:0[ ) ( [190, 235[ [0, 86[ ) ( [0:8:0, 0:10:0[ )\" ; Note: about local spaces Text objects ( txt txtf ) local space is expressed by intervals on columns and rows. Html object ( html, htmlf ) do not support mapping because there is not correspondence between the text and the graphic space. Vectorial objects ( rect, ellipse, polygon, curve, svg,... ) express their local graphic space in internal coordinates system i.e. on the [-1.,1.] interval. Bitmap objects ( img ) express their local graphic space in pixels.","title":"Segments definitions"},{"location":"refs/13-mapping/#the-map-message_1","text":"The map+ messages is similar to the map message but doesn't replace the existing mapping data: the specified relations are added to the existing one. mapAddMsg ComplexDiagram( Sequence ('map+', Optional ( NonTerminal('mapName')), NonTerminal('relation')) ).addTo()","title":"The 'map+' message"},{"location":"refs/13-mapping/#mapping-files","text":"The mapf messages is similar to the map message but gives the path name of a file containing the mapping data, along with the optional map name. mapfMsg ComplexDiagram( Sequence ('mapf', Optional ( NonTerminal('mapName')), NonTerminal('mapFilePath')) ).addTo()","title":"Mapping files"},{"location":"refs/13-mapping/#symbolic-score-mappings","text":"Mapping between the graphic and time space is automatically computed for symbolic score gmn, gmnstream, gmnf . However and depending on the application, the graphic space may be segmented in different ways, for instance: different graphic segments for different staves, a single graphic segment traversing all a system, etc. Thus for a symbolic score, the map message different and is only intended to select one king mapping supported by the system. scoreMap ComplexDiagram( Sequence ('map', Choice (0, 'page', 'system', 'systemflat', 'staffn', 'voicen')) ).addTo() page : a page level mapping system : a system level mapping systemflat : a system level mapping without system subdivision (one graphic segment per system) staff_n _: a staff level mapping: the staff number is indicated by n , a number between 1 and the score staves count. voice_n _: a voice level mapping: the voice number is indicated by n , a number between 1 and the score voices count. The default mapping for a symbolic score is unnamed but equivalent to staff1 . Example Requesting the mapping of the third staff of a score: /ITL/scene/myScore map staff3; Requesting the system mapping : /ITL/scene/myScore map system; Note: A voice may be distributed on several staves and thus a staff may contain several voices.","title":"Symbolic score mappings"},{"location":"refs/14-syncmsg/","text":"Synchronization Synchronization between components is in charge of the static sync node, automatically embedded in each object. Its address is /ITL/.../ object /sync and it supports messages to add or remove a master / slave relation between components or to query the synchronizations state. Note: A master can naturally have several slaves, but a slave can have several masters as well. In this case, it will be drawn several times, corresponding to each master's space. sync ComplexDiagram( Choice (0, Sequence (NonTerminal('syncIdentifier'), Choice (0, Sequence (Comment ('1'), NonTerminal('syncIdentifier'), Optional ( OneOrMore (NonTerminal('syncmode')))), Sequence (Comment ('2'), NonTerminal('syncIdentifier'), 'del'), Comment ('3'))), Sequence (Comment ('4'), 'get', Optional ( NonTerminal('target')))) ).addTo() [1] the slave master form is followed by an optional synchronization mode (see below). It adds a slave / master relation between the first and the second component. [2] the slave master del form removes the specified slave/master relation. [3] the slave form without master removes all synchronizations with the slave. [4] the get message is intended to query the synchronization state. The optional parameter is the identifier of a component. The get message without parameter is equivalent to a get message addressed to each object declared in the sync node. syncIdentifier ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('identifier')), Sequence (Comment ('2'), NonTerminal('identifier'), ':', NonTerminal('mapName'))) ).addTo() Synchronization identifiers indicates 1) the name of an object. Note that you can use regular expressions to refer to a set of objects. 2) the name of an object associated to a mapping name. Using the first form (i.e. without explicit mapping name), the system uses the default unnamed mapping (see section mapMsg mappings and named mappings). Synchronization between components has no effect if any of the required mapping is missing (see table maptable ). Example Synchronizing an object on several masters: /ITL/scene/myParent/sync mySlave myMaster1; /ITL/scene/myParent/sync mySlave myMaster2; Synchronizing two objects using a specific mapping (the second object is assumed to be a symbolic score ( gmn , gmnstream or gmnf ) which system mapping has been previously requested): /ITL/scene/myParent/sync mySlave myMaster:system; Synchronization modes Synchronizing a slave component A to a master component B has the following effect: A position (x) is modified to match the B time position corresponding to A date. depending on the optional syncStretch option, A width and/or height is modified to match the corresponding B dimension (see below). depending on the optional syncPos option, A vertical position (y) is modified. Note that the y position remains free and could always be modified using a dy message. if A date has no graphic correspondence in B mapping (the date is not mapped, or out of B mapping bounds ), A won't be visible. syncmode ComplexDiagram( Choice (0, NonTerminal('syncHow'), NonTerminal('syncStretch'), NonTerminal('syncPos'), NonTerminal('mapName')) ).addTo() Using the master date syncHow ComplexDiagram( Choice (0, 'relative', 'absolute') ).addTo() The synchronization mode makes use of the master time to graphic mapping to compute the slave position. It may also use the master current date, depending on the following options: relative : the time position where the slave appears is relative to the mapping AND to the master current date (actually, it shifts the mapping from the master current date). The relative mode is used by default. absolute : the time position where the slave appears corresponds to the mapping date only. Note: Use of the absolute mode may take sense with nested synchronizations: let's consider an object A , slave of B , which is slave of C . In relative mode and if A and B receive the same clock messages, A will remain at a fixed position on B although it is moving in time. Example Describing nested synchronizations, the first one using the absolute mode: /ITL/scene/sync slave masterSlave absolute ; /ITL/scene/sync masterSlave master ; Synchronizing an object duration syncStretch ComplexDiagram( Choice (0, 'h', 'v', 'hv') ).addTo() The synchronization stretch mode has the following effect on the slave dimensions: h : the slave is horizontally stretched to align its begin and end dates to the corresponding master locations. v : the slave is vertically stretched to the master map vertical dimension. hv : combines the above parameters. By default, no stretching is applied. Example Synchronizing two objects, aligning the slave duration to the corresponding master space and stretching the slave to the master map vertical dimension: /ITL/scene/sync mySlave myMaster hv ; Controlling the slave position syncPos ComplexDiagram( Choice (0, 'syncOver', 'syncTop', 'syncBottom', 'syncFrame') ).addTo() The synchronization position mode has the following effects on the slave y position: syncOver : the center of the slave is aligned to the master center. syncTop : the bottom of the slave is aligned to the top of the master. syncBottom : the top of the slave is aligned to the bottom of the master. syncFrame : used to browse the master frame (see the next section). The default position mode is syncOver . The y attribute of the slave remains available to displacement ( dy ). Note: The y position of a synchronized object remains a free attribute. To control this position, you should send dy messages. Example Synchronizing two objects, aligning the slave duration to the corresponding master space, the slave being below the master map: /ITL/scene/sync mySlave myMaster h syncBottom; The syncFrame mode When the syncFrame mode is used, the slave is placed on the frame of the master. Typically, this frame corresponds to the object bounding box that is also the object default mapping. For ellipses, arcs, lines, polygons, the frame corresponds to the border of the object. The frame duration is the object duration. Mappings and stretch options are ignored in syncFrame mode.","title":"Synchronization"},{"location":"refs/14-syncmsg/#synchronization","text":"Synchronization between components is in charge of the static sync node, automatically embedded in each object. Its address is /ITL/.../ object /sync and it supports messages to add or remove a master / slave relation between components or to query the synchronizations state. Note: A master can naturally have several slaves, but a slave can have several masters as well. In this case, it will be drawn several times, corresponding to each master's space. sync ComplexDiagram( Choice (0, Sequence (NonTerminal('syncIdentifier'), Choice (0, Sequence (Comment ('1'), NonTerminal('syncIdentifier'), Optional ( OneOrMore (NonTerminal('syncmode')))), Sequence (Comment ('2'), NonTerminal('syncIdentifier'), 'del'), Comment ('3'))), Sequence (Comment ('4'), 'get', Optional ( NonTerminal('target')))) ).addTo() [1] the slave master form is followed by an optional synchronization mode (see below). It adds a slave / master relation between the first and the second component. [2] the slave master del form removes the specified slave/master relation. [3] the slave form without master removes all synchronizations with the slave. [4] the get message is intended to query the synchronization state. The optional parameter is the identifier of a component. The get message without parameter is equivalent to a get message addressed to each object declared in the sync node. syncIdentifier ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('identifier')), Sequence (Comment ('2'), NonTerminal('identifier'), ':', NonTerminal('mapName'))) ).addTo() Synchronization identifiers indicates 1) the name of an object. Note that you can use regular expressions to refer to a set of objects. 2) the name of an object associated to a mapping name. Using the first form (i.e. without explicit mapping name), the system uses the default unnamed mapping (see section mapMsg mappings and named mappings). Synchronization between components has no effect if any of the required mapping is missing (see table maptable ). Example Synchronizing an object on several masters: /ITL/scene/myParent/sync mySlave myMaster1; /ITL/scene/myParent/sync mySlave myMaster2; Synchronizing two objects using a specific mapping (the second object is assumed to be a symbolic score ( gmn , gmnstream or gmnf ) which system mapping has been previously requested): /ITL/scene/myParent/sync mySlave myMaster:system;","title":"Synchronization"},{"location":"refs/14-syncmsg/#synchronization-modes","text":"Synchronizing a slave component A to a master component B has the following effect: A position (x) is modified to match the B time position corresponding to A date. depending on the optional syncStretch option, A width and/or height is modified to match the corresponding B dimension (see below). depending on the optional syncPos option, A vertical position (y) is modified. Note that the y position remains free and could always be modified using a dy message. if A date has no graphic correspondence in B mapping (the date is not mapped, or out of B mapping bounds ), A won't be visible. syncmode ComplexDiagram( Choice (0, NonTerminal('syncHow'), NonTerminal('syncStretch'), NonTerminal('syncPos'), NonTerminal('mapName')) ).addTo()","title":"Synchronization modes"},{"location":"refs/14-syncmsg/#using-the-master-date","text":"syncHow ComplexDiagram( Choice (0, 'relative', 'absolute') ).addTo() The synchronization mode makes use of the master time to graphic mapping to compute the slave position. It may also use the master current date, depending on the following options: relative : the time position where the slave appears is relative to the mapping AND to the master current date (actually, it shifts the mapping from the master current date). The relative mode is used by default. absolute : the time position where the slave appears corresponds to the mapping date only. Note: Use of the absolute mode may take sense with nested synchronizations: let's consider an object A , slave of B , which is slave of C . In relative mode and if A and B receive the same clock messages, A will remain at a fixed position on B although it is moving in time. Example Describing nested synchronizations, the first one using the absolute mode: /ITL/scene/sync slave masterSlave absolute ; /ITL/scene/sync masterSlave master ;","title":"Using the master date"},{"location":"refs/14-syncmsg/#synchronizing-an-object-duration","text":"syncStretch ComplexDiagram( Choice (0, 'h', 'v', 'hv') ).addTo() The synchronization stretch mode has the following effect on the slave dimensions: h : the slave is horizontally stretched to align its begin and end dates to the corresponding master locations. v : the slave is vertically stretched to the master map vertical dimension. hv : combines the above parameters. By default, no stretching is applied. Example Synchronizing two objects, aligning the slave duration to the corresponding master space and stretching the slave to the master map vertical dimension: /ITL/scene/sync mySlave myMaster hv ;","title":"Synchronizing an object duration"},{"location":"refs/14-syncmsg/#controlling-the-slave-position","text":"syncPos ComplexDiagram( Choice (0, 'syncOver', 'syncTop', 'syncBottom', 'syncFrame') ).addTo() The synchronization position mode has the following effects on the slave y position: syncOver : the center of the slave is aligned to the master center. syncTop : the bottom of the slave is aligned to the top of the master. syncBottom : the top of the slave is aligned to the bottom of the master. syncFrame : used to browse the master frame (see the next section). The default position mode is syncOver . The y attribute of the slave remains available to displacement ( dy ). Note: The y position of a synchronized object remains a free attribute. To control this position, you should send dy messages. Example Synchronizing two objects, aligning the slave duration to the corresponding master space, the slave being below the master map: /ITL/scene/sync mySlave myMaster h syncBottom;","title":"Controlling the slave position"},{"location":"refs/14-syncmsg/#the-syncframe-mode","text":"When the syncFrame mode is used, the slave is placed on the frame of the master. Typically, this frame corresponds to the object bounding box that is also the object default mapping. For ellipses, arcs, lines, polygons, the frame corresponds to the border of the object. The frame duration is the object duration. Mappings and stretch options are ignored in syncFrame mode.","title":"The syncFrame mode"},{"location":"refs/15-graphsig/","text":"Signals and graphic signals The graphic representation of a signal is approached with graphic signals . As illustrated in figure graphimg , the graphic representation of a signal could be viewed as a stream of a limited set of parameters : the y coordinate at a time t , a thickness h and a color c . A graphic signal is a composite signal including a set of 3 parallel signals that control these parameters. Thus the INScore library provides messages to create signals and to combine them into graphic signals . A simple graphic signal, defined at time t by a coordinate y, a thickness h and a color c The 'signal' static node. A scene includes a static signal node, which OSC address is /ITL/ scene /signal which may be viewed as a container for signals. It is also used for composing signals in parallel . The signal node supports the get message that gives the list of the defined signals and also the get connect message that gives a list of all connections, but doesn't take any argument. Example Querying the signal node: /ITL/scene/signal get; will give the enclosed signals definitions: /ITL/scene/signal/y size 200 ; /ITL/scene/signal/h size 200 ; And : /ITL/scene/signal get connect; will give the signal connections : /ITL/scene/signal connect cos object1:method1 ; /ITL/scene/signal connect sin object2:method2 ; Signal messages. Signal messages can be sent to any address with the form /ITL/ scene /signal/\\textit{identifier }, where identifier is a unique signal identifier. The set of messages supported by a signal is the following: simpleSignal ComplexDiagram( Choice (0, Sequence (Comment ('1'), OneOrMore (NonTerminal('float32'))), Sequence (Comment ('2'), Sequence ('size', NonTerminal('int32'))), Sequence (Comment ('3'), Sequence ('default', NonTerminal('float32'))), Sequence (Comment ('4'), 'get', Optional ( Choice (0, 'size', 'default'))), Sequence (Comment ('5'), 'reset'), Sequence (Comment ('6'), 'del')) ).addTo() [1] push an arbitrary data count into the signal buffer. The expected data range is [-1,1] . Note that the internal data buffer is a ring buffer, thus data are wrapped when the data count if greater than the buffer size. [2] the size message sets the signal buffer size. When not specified, the buffer size value is the size of the first data message. [3] the default message sets the default signal value . A signal default value is the value returned when a query asks for data past the available values. [4] the get message without parameter gives the signal current values. The size and default parameters are used to query the signal size and default values. [5] the reset message clears the signal data. [6] the del message deletes the signal from the signal space. Note that it is safe to delete a signal even when used by a graphic signal. Example Creating a signal with a given buffer size: /ITL/scene/signal/mySig size 200; Creating a signal with a given set of data (the buffer size will be the data size): /ITL/scene/signal/mySig 0. 0.10.2\\ 0.3\\ 0.4\\ 0.5\\ 0.4\\ 0.3\\ 0.2\\ 0.1\\ 0.\\ -0.1\\ -0.2 ; Composing signals in parallel. Composing signals in parallel produces a signal which value at a time t is a vector of the composed signals values. Thus an additional read-only attribute is defined on parallel signals : the signal dimension which is size of the signals vector. Note that the dimension property holds also for simple signals. The format of the messages for parallel signals is the following: parallelSignal ComplexDiagram( Choice (0, Sequence (Comment ('1'), 'set', OneOrMore (NonTerminal('signal'))), Sequence (Comment ('2'), Optional ( NonTerminal('projectionString')), OneOrMore (NonTerminal('float32'))), Sequence (Comment ('3'), Sequence ('get', 'dimension'))) ).addTo() where signal ComplexDiagram( Choice (0, Sequence (Comment ('4'), NonTerminal('identifier')), Sequence (Comment ('5'), NonTerminal('float32'))) ).addTo() [1] defines a new signal composed of the signals given as parameters. A signal parameter is defined as: [4] an identifier i.e. a signal name referring to an existing signal in the signal node. [5] or as a float value. This form is equivalent to an anonymous constant signal holding the given value. [2] sets the values of the signals using a projection string. See section sigproj . [3] in addition to the get format defined for signals, a parallel signal supports the get dimension message, that gives the number of simple signals in parallel. The dimension of a simple signal is 1. Example Putting a signal y and constant signals 0.01 0. 1. 1. 1. in parallel: /ITL/scene/signal/mySig set y 0.01 0. 1. 1. 1. ; Querying the previously defined parallel signal: /ITL/scene/signal/mySig get ; # will give the following output: /ITL/scene/signal/mySig set y 0.01 0. 1. 1. 1. Note: For a parallel signal: the get size message gives the maximum of the components size. the get default message gives the default value of the first signal. Distributing data to signals in parallel When signals are in parallel, a projection string may be used to distribute data over each signal. Individual components of a parallel signal may be addressed using a projection string that is defined as follows: projectionString ComplexDiagram( Sequence ('[', NonTerminal('int32'), Optional ( Sequence ('~', Optional ( NonTerminal('int32')))), ']') ).addTo() The projection string is made of a index value , followed by an optional parallel marker ( ~ ), followed by an optional step value , all enclosed in brackets. The index value n is the index of a target signal. When the parallel marker option is not present, the values are directed to the target signal. Indexes start at 0. Example Sending data to the second component of a parallel signal: /ITL/scene/signal/sig '[1]' 0. 0.10.2\\ 0.3\\ 0.4\\ 0.5\\ 0.4\\ 0.3\\ 0.2\\ 0.1\\ 0. ; is equivalent to the following message (assuming that the second signal name is 's2'): /ITL/scene/signal/s2 0. 0.10.2\\ 0.3\\ 0.4\\ 0.5\\ 0.4\\ 0.3\\ 0.2\\ 0.1\\ 0. ; Note that: the message is ignored when n is greater than the number of signals in parallel. Default n value is 0 . setting directly the values of a simple signal or as the projection of a parallel signal are equivalent. The parallel marker ( ~ ) and the step value w options affect the target signals. Let's consider s[n] as the signal at index n . The values are distributed in sequence and in loop to the signals s[n], s[n+w]...s[m] where m is the greatest value of the index n+(w.i) that is less than the signal dimension. The default step value is 1 . Example Sending data to the second and third components of a set of 3 parallel signals: /ITL/scene/signal/sig [1~] 0.1 0.2 ; is equivalent to the following messages (assuming that the signal dimension is 3): /ITL/scene/signal/sig [1] 0.1 ; /ITL/scene/signal/sig [2] 0.2 ; or to the following (assuming that the target signal names are 's2' and 's3'): /ITL/scene/signal/s2 0.1; /ITL/scene/signal/s3 0.2; Connecting signals to graphic attributes. A signal may be connected to one or several graphic attributes of an object. Only the common attributes (see section common ) support this mechanism. When a connection between a signal and an object attribute is set, sending values to the signal is equivalent to send the values to the connected object attribute. A similar behavior could be achieved by sending the equivalent messages, however the connection mechanism is provided for efficiency reasons and in addition, it supports values scaling. signalcnx ComplexDiagram( Choice (0, Sequence ('connect', NonTerminal('connection')), Sequence ('disconnect', Choice (0, Sequence (Comment ('1'), NonTerminal('connection')), Sequence (Comment ('2'), NonTerminal('signal')), Sequence (Comment ('3'), NonTerminal('signal'), NonTerminal('object'))))) ).addTo() the connect message makes a connection between a signal and one or several attributes of one or several objects. the disconnect message breaks a specific connection [1] or all the connections of a given signal [2] , or all connections between a given signal and a given object [3] . connection ComplexDiagram( Sequence (NonTerminal('signal'), OneOrMore (NonTerminal('target'))) ).addTo() signal is a name referring to an existing component of the signal node. target ComplexDiagram( Sequence (NonTerminal('object'), Sequence (':', NonTerminal('attribute'), OneOrMore (Optional ( '[low,high]')))) ).addTo() object is the name of an object (must be on the same hierarchy level than the signal node). attribute is the name of the object target attribute (same name as the method used to set the attribute, e.g. x , angle , etc.). an optional scaling feature is provided with the [low,high] suffix: signal values are expected to be between -1 and 1, the scaling suffix re-scale the input values between low and high . Note: Connections are restricted to one-dimensional signals as source and to one-dimensional attribute as target. This is not a real limitation since any component of a multi dimensional attribute (e.g. color ) is always available as a single attribute (e.g. red or blue ). Note: A connection can't cross the borders of a component i.e. the target object and the signal node should have the same parent. Example Connecting signals to attributes: # connects the values of sig1 to the red attribute of the 'rect' object /ITL/scene/signal connect sig1 \"rect:red\"; # connects the values of sig2 to several objects and attributes /ITL/scene/signal connect sig2 \"rect:blue:x:rotatey[0,360]\" \"cursor:date[0,15]\"; Disconnecting some of the previous connections : /ITL/scene/signal disconnect sig2 \"cursor:date\" \"rect:rotatey:blue\"; Graphic signals. A graphic signal is the graphic representation of a set of parallel signals. It is created in the standard scene address space. A simple graphic signal is defined by a parallel signal controling the y deviation value, the thickness and the color at each time position. The color is encoded as HSBA colors (Hue, Saturation, Brightness, Transparency). The mapping of a signal value ( [-1,1] ) to the HSBA color space is given by the table hsbamap . The HSB color space parameter mapping hue [-1,1] corresponds to [-180,180] angular degree where 0 is red. saturation [-1,1] corresponds 0 brigthness [-1,1] corresponds 0 transparency [-1,1] corresponds 0 HSBA color values. A graphic signal responds to common component messages (section common ). Its specific messages are the following: graphicSignal ComplexDiagram( Choice (0, Sequence ('set', NonTerminal('graphtype'), NonTerminal('signalIdentifier')), Sequence ('get', 'dimension')) ).addTo() the set message is followed by the graph type and a signalIdentifier , where signalIdentifier must correspond to an existing signal from the signal address space. In case signalIdentifier doesn't exist, then a new signal is created at the signalIdentifier address with default values. the get dimension message gives the number of graphic signals in parallel (see section pgsignal ). graphtype ComplexDiagram( Choice (0, NonTerminal('graph'), NonTerminal('fastgraph'), NonTerminal('radialgraph')) ).addTo() The signal representation type is among: graph : a classical signal representation as illustrated in figure graphimg , where time is mapped to the x coordinate. fastgraph : a representation similar to the graph type, using a more efficient drawing strategy, but at the expense of a degraded graphic rendering. radialgraph : a signal representation where time is mapped to the polar coordinates. The rendering takes place in the ellipse enclosed in the object dimensions. Example Creating a signal and its graphic representation: /ITL/scene/signal/y size 200 ; # use of constant anonymous signals for thickness and color /ITL/scene/signal/sig set y 0.1 0. 1. 1. 1. ; /ITL/scene/siggraph set graph sig ; Graphic signal default values. As mentionned above, a graphic signal expects to be connected to parallel signals having at least an y component, a graphic thickness component and HSBA components. Thus, from graphic signal viewpoint, the expected dimension of a signal should be equal or greater than 6. In case the signalIdentifier dimension is less than 6, the graphic signal will use the default values defined in table gsigdefaultvalues . parameter default value y 0 the center line of the graphic thickness 0 hue 0 meaningless due to brigthness value saturation 0 meaningless due to brigthness value brigthness -1 black transparency 1 opaque Graphic signal default values. Parallel graphic signals. When the dimension d of a signal connected to a graphic signal is greater than 6, then the input signal is interpreted like parallel graphic signals. More generally, the dimension n of a graphic signal is: n |n \\in \\mathbb{N}\\ \\land\\ 6.(n-1) < d \\leqslant 6.n where d is the dimension of the input signal. When d is not a mutiple of 6, then the last graphic signal makes use of the default values mentionned above. Example Creating parallel graphic signals: /ITL/scene/signal/y1 size 200 ; /ITL/scene/signal/y2 size 200 ; # use of constant anonymous signals for thickness and color /ITL/scene/signal/sig1 set y1 0.1 0. 1. 1. 1. ; # use a different color for 'sig2' /ITL/scene/signal/sig2 set y2 0.1 0.6 1. 1. 1. ; # put 'sig1' and 'sig2' in parallel /ITL/scene/signal/sig set sig1 sig2; # 'sig' dimension is 12 /ITL/scene/siggraph set graph sig; Note: Using data projection may be convenient when the input signal represents interleaved data. For example, the projection string [n~6] distribute data over similar components of a set of graphic signals, where n represents the index of the graphic signal target component.","title":"Graphic signals"},{"location":"refs/15-graphsig/#signals-and-graphic-signals","text":"The graphic representation of a signal is approached with graphic signals . As illustrated in figure graphimg , the graphic representation of a signal could be viewed as a stream of a limited set of parameters : the y coordinate at a time t , a thickness h and a color c . A graphic signal is a composite signal including a set of 3 parallel signals that control these parameters. Thus the INScore library provides messages to create signals and to combine them into graphic signals . A simple graphic signal, defined at time t by a coordinate y, a thickness h and a color c","title":"Signals and graphic signals"},{"location":"refs/15-graphsig/#the-signal-static-node","text":"A scene includes a static signal node, which OSC address is /ITL/ scene /signal which may be viewed as a container for signals. It is also used for composing signals in parallel . The signal node supports the get message that gives the list of the defined signals and also the get connect message that gives a list of all connections, but doesn't take any argument. Example Querying the signal node: /ITL/scene/signal get; will give the enclosed signals definitions: /ITL/scene/signal/y size 200 ; /ITL/scene/signal/h size 200 ; And : /ITL/scene/signal get connect; will give the signal connections : /ITL/scene/signal connect cos object1:method1 ; /ITL/scene/signal connect sin object2:method2 ;","title":"The 'signal' static node."},{"location":"refs/15-graphsig/#signal-messages","text":"Signal messages can be sent to any address with the form /ITL/ scene /signal/\\textit{identifier }, where identifier is a unique signal identifier. The set of messages supported by a signal is the following: simpleSignal ComplexDiagram( Choice (0, Sequence (Comment ('1'), OneOrMore (NonTerminal('float32'))), Sequence (Comment ('2'), Sequence ('size', NonTerminal('int32'))), Sequence (Comment ('3'), Sequence ('default', NonTerminal('float32'))), Sequence (Comment ('4'), 'get', Optional ( Choice (0, 'size', 'default'))), Sequence (Comment ('5'), 'reset'), Sequence (Comment ('6'), 'del')) ).addTo() [1] push an arbitrary data count into the signal buffer. The expected data range is [-1,1] . Note that the internal data buffer is a ring buffer, thus data are wrapped when the data count if greater than the buffer size. [2] the size message sets the signal buffer size. When not specified, the buffer size value is the size of the first data message. [3] the default message sets the default signal value . A signal default value is the value returned when a query asks for data past the available values. [4] the get message without parameter gives the signal current values. The size and default parameters are used to query the signal size and default values. [5] the reset message clears the signal data. [6] the del message deletes the signal from the signal space. Note that it is safe to delete a signal even when used by a graphic signal. Example Creating a signal with a given buffer size: /ITL/scene/signal/mySig size 200; Creating a signal with a given set of data (the buffer size will be the data size): /ITL/scene/signal/mySig 0. 0.10.2\\ 0.3\\ 0.4\\ 0.5\\ 0.4\\ 0.3\\ 0.2\\ 0.1\\ 0.\\ -0.1\\ -0.2 ;","title":"Signal messages."},{"location":"refs/15-graphsig/#composing-signals-in-parallel","text":"Composing signals in parallel produces a signal which value at a time t is a vector of the composed signals values. Thus an additional read-only attribute is defined on parallel signals : the signal dimension which is size of the signals vector. Note that the dimension property holds also for simple signals. The format of the messages for parallel signals is the following: parallelSignal ComplexDiagram( Choice (0, Sequence (Comment ('1'), 'set', OneOrMore (NonTerminal('signal'))), Sequence (Comment ('2'), Optional ( NonTerminal('projectionString')), OneOrMore (NonTerminal('float32'))), Sequence (Comment ('3'), Sequence ('get', 'dimension'))) ).addTo() where signal ComplexDiagram( Choice (0, Sequence (Comment ('4'), NonTerminal('identifier')), Sequence (Comment ('5'), NonTerminal('float32'))) ).addTo() [1] defines a new signal composed of the signals given as parameters. A signal parameter is defined as: [4] an identifier i.e. a signal name referring to an existing signal in the signal node. [5] or as a float value. This form is equivalent to an anonymous constant signal holding the given value. [2] sets the values of the signals using a projection string. See section sigproj . [3] in addition to the get format defined for signals, a parallel signal supports the get dimension message, that gives the number of simple signals in parallel. The dimension of a simple signal is 1. Example Putting a signal y and constant signals 0.01 0. 1. 1. 1. in parallel: /ITL/scene/signal/mySig set y 0.01 0. 1. 1. 1. ; Querying the previously defined parallel signal: /ITL/scene/signal/mySig get ; # will give the following output: /ITL/scene/signal/mySig set y 0.01 0. 1. 1. 1. Note: For a parallel signal: the get size message gives the maximum of the components size. the get default message gives the default value of the first signal.","title":"Composing signals in parallel."},{"location":"refs/15-graphsig/#distributing-data-to-signals-in-parallel","text":"When signals are in parallel, a projection string may be used to distribute data over each signal. Individual components of a parallel signal may be addressed using a projection string that is defined as follows: projectionString ComplexDiagram( Sequence ('[', NonTerminal('int32'), Optional ( Sequence ('~', Optional ( NonTerminal('int32')))), ']') ).addTo() The projection string is made of a index value , followed by an optional parallel marker ( ~ ), followed by an optional step value , all enclosed in brackets. The index value n is the index of a target signal. When the parallel marker option is not present, the values are directed to the target signal. Indexes start at 0. Example Sending data to the second component of a parallel signal: /ITL/scene/signal/sig '[1]' 0. 0.10.2\\ 0.3\\ 0.4\\ 0.5\\ 0.4\\ 0.3\\ 0.2\\ 0.1\\ 0. ; is equivalent to the following message (assuming that the second signal name is 's2'): /ITL/scene/signal/s2 0. 0.10.2\\ 0.3\\ 0.4\\ 0.5\\ 0.4\\ 0.3\\ 0.2\\ 0.1\\ 0. ; Note that: the message is ignored when n is greater than the number of signals in parallel. Default n value is 0 . setting directly the values of a simple signal or as the projection of a parallel signal are equivalent. The parallel marker ( ~ ) and the step value w options affect the target signals. Let's consider s[n] as the signal at index n . The values are distributed in sequence and in loop to the signals s[n], s[n+w]...s[m] where m is the greatest value of the index n+(w.i) that is less than the signal dimension. The default step value is 1 . Example Sending data to the second and third components of a set of 3 parallel signals: /ITL/scene/signal/sig [1~] 0.1 0.2 ; is equivalent to the following messages (assuming that the signal dimension is 3): /ITL/scene/signal/sig [1] 0.1 ; /ITL/scene/signal/sig [2] 0.2 ; or to the following (assuming that the target signal names are 's2' and 's3'): /ITL/scene/signal/s2 0.1; /ITL/scene/signal/s3 0.2;","title":"Distributing data to signals in parallel"},{"location":"refs/15-graphsig/#connecting-signals-to-graphic-attributes","text":"A signal may be connected to one or several graphic attributes of an object. Only the common attributes (see section common ) support this mechanism. When a connection between a signal and an object attribute is set, sending values to the signal is equivalent to send the values to the connected object attribute. A similar behavior could be achieved by sending the equivalent messages, however the connection mechanism is provided for efficiency reasons and in addition, it supports values scaling. signalcnx ComplexDiagram( Choice (0, Sequence ('connect', NonTerminal('connection')), Sequence ('disconnect', Choice (0, Sequence (Comment ('1'), NonTerminal('connection')), Sequence (Comment ('2'), NonTerminal('signal')), Sequence (Comment ('3'), NonTerminal('signal'), NonTerminal('object'))))) ).addTo() the connect message makes a connection between a signal and one or several attributes of one or several objects. the disconnect message breaks a specific connection [1] or all the connections of a given signal [2] , or all connections between a given signal and a given object [3] . connection ComplexDiagram( Sequence (NonTerminal('signal'), OneOrMore (NonTerminal('target'))) ).addTo() signal is a name referring to an existing component of the signal node. target ComplexDiagram( Sequence (NonTerminal('object'), Sequence (':', NonTerminal('attribute'), OneOrMore (Optional ( '[low,high]')))) ).addTo() object is the name of an object (must be on the same hierarchy level than the signal node). attribute is the name of the object target attribute (same name as the method used to set the attribute, e.g. x , angle , etc.). an optional scaling feature is provided with the [low,high] suffix: signal values are expected to be between -1 and 1, the scaling suffix re-scale the input values between low and high . Note: Connections are restricted to one-dimensional signals as source and to one-dimensional attribute as target. This is not a real limitation since any component of a multi dimensional attribute (e.g. color ) is always available as a single attribute (e.g. red or blue ). Note: A connection can't cross the borders of a component i.e. the target object and the signal node should have the same parent. Example Connecting signals to attributes: # connects the values of sig1 to the red attribute of the 'rect' object /ITL/scene/signal connect sig1 \"rect:red\"; # connects the values of sig2 to several objects and attributes /ITL/scene/signal connect sig2 \"rect:blue:x:rotatey[0,360]\" \"cursor:date[0,15]\"; Disconnecting some of the previous connections : /ITL/scene/signal disconnect sig2 \"cursor:date\" \"rect:rotatey:blue\";","title":"Connecting signals to graphic attributes."},{"location":"refs/15-graphsig/#graphic-signals","text":"A graphic signal is the graphic representation of a set of parallel signals. It is created in the standard scene address space. A simple graphic signal is defined by a parallel signal controling the y deviation value, the thickness and the color at each time position. The color is encoded as HSBA colors (Hue, Saturation, Brightness, Transparency). The mapping of a signal value ( [-1,1] ) to the HSBA color space is given by the table hsbamap . The HSB color space parameter mapping hue [-1,1] corresponds to [-180,180] angular degree where 0 is red. saturation [-1,1] corresponds 0 brigthness [-1,1] corresponds 0 transparency [-1,1] corresponds 0 HSBA color values. A graphic signal responds to common component messages (section common ). Its specific messages are the following: graphicSignal ComplexDiagram( Choice (0, Sequence ('set', NonTerminal('graphtype'), NonTerminal('signalIdentifier')), Sequence ('get', 'dimension')) ).addTo() the set message is followed by the graph type and a signalIdentifier , where signalIdentifier must correspond to an existing signal from the signal address space. In case signalIdentifier doesn't exist, then a new signal is created at the signalIdentifier address with default values. the get dimension message gives the number of graphic signals in parallel (see section pgsignal ). graphtype ComplexDiagram( Choice (0, NonTerminal('graph'), NonTerminal('fastgraph'), NonTerminal('radialgraph')) ).addTo() The signal representation type is among: graph : a classical signal representation as illustrated in figure graphimg , where time is mapped to the x coordinate. fastgraph : a representation similar to the graph type, using a more efficient drawing strategy, but at the expense of a degraded graphic rendering. radialgraph : a signal representation where time is mapped to the polar coordinates. The rendering takes place in the ellipse enclosed in the object dimensions. Example Creating a signal and its graphic representation: /ITL/scene/signal/y size 200 ; # use of constant anonymous signals for thickness and color /ITL/scene/signal/sig set y 0.1 0. 1. 1. 1. ; /ITL/scene/siggraph set graph sig ;","title":"Graphic signals."},{"location":"refs/15-graphsig/#graphic-signal-default-values","text":"As mentionned above, a graphic signal expects to be connected to parallel signals having at least an y component, a graphic thickness component and HSBA components. Thus, from graphic signal viewpoint, the expected dimension of a signal should be equal or greater than 6. In case the signalIdentifier dimension is less than 6, the graphic signal will use the default values defined in table gsigdefaultvalues . parameter default value y 0 the center line of the graphic thickness 0 hue 0 meaningless due to brigthness value saturation 0 meaningless due to brigthness value brigthness -1 black transparency 1 opaque Graphic signal default values.","title":"Graphic signal default values."},{"location":"refs/15-graphsig/#parallel-graphic-signals","text":"When the dimension d of a signal connected to a graphic signal is greater than 6, then the input signal is interpreted like parallel graphic signals. More generally, the dimension n of a graphic signal is: n |n \\in \\mathbb{N}\\ \\land\\ 6.(n-1) < d \\leqslant 6.n where d is the dimension of the input signal. When d is not a mutiple of 6, then the last graphic signal makes use of the default values mentionned above. Example Creating parallel graphic signals: /ITL/scene/signal/y1 size 200 ; /ITL/scene/signal/y2 size 200 ; # use of constant anonymous signals for thickness and color /ITL/scene/signal/sig1 set y1 0.1 0. 1. 1. 1. ; # use a different color for 'sig2' /ITL/scene/signal/sig2 set y2 0.1 0.6 1. 1. 1. ; # put 'sig1' and 'sig2' in parallel /ITL/scene/signal/sig set sig1 sig2; # 'sig' dimension is 12 /ITL/scene/siggraph set graph sig; Note: Using data projection may be convenient when the input signal represents interleaved data. For example, the projection string [n~6] distribute data over similar components of a set of graphic signals, where n represents the index of the graphic signal target component.","title":"Parallel graphic signals."},{"location":"refs/16-sensors/","text":"Sensors INScore supports various sensors, which can be viewed as objects or as signals. When created as a signal node, a sensor behaves like any signal but may provide some additional features (like calibration). When created as a score element, a sensor has no graphical appearance and provides specific sensor events and features. Table tab:sensors gives the list of supported sensors names. name values description accelerometer x, y, z acceleration on the x, y, and z axis ambient light light level ambient light value compass azimuth, azimuth is in degrees from magnetic north in a clockwise direction gyroscope x, y, z the angular velocity around the x, y, and z axis light lux the light level measured as lux magnetometer x, y, z the raw magnetic flux density measured on th x, y and z axis orientation orientation the device orientation proximity close a boolean value rotation x, y, z the rotation around the x, y and z axis tilt x, y the amount of tilt on the x and y axis. Sensors names and description Note: All the sensors won't likely be available on a given device. In case a sensor is not supported, an error message is generated at creation request and the creation process fails. Sensors as signals A sensor is viewed as a signal when created in a signal node using pre-defined signal names which are listed in table tab:sensorsig . Values provided on different axis (e.g. acceleration on the x, y, and z axis) are available from the sensor subnodes, also listed this table. sensor signal name subnodes accelerometer accelerometer x, y, z ambient light ambientlight none compass compass none gyroscope gyroscope x, y, z light light none magnetometer magnetometer x, y, z orientation orientation none proximity proximity none rotation rotation x, y, [z] tilt tilt x, y Sensor's signal names and subnodes Example Creating a rotation sensor with a 200 values buffer size. /ITL/scene/signal/rotation size 200; Getting accelerometer values on the x axis. /ITL/scene/signal/accelerometer/x get; Note: The rotation sensor may or may not have a z component however, the z signal is always present but set to 0 when no z component is available. A specific message is provided to get the z component status (see section Rotation ). Sensors as nodes A sensor is viewed as a regular INScore node when created outside a signal node and using one of the sensors types defined below. A sensor node has no graphical appearance but has the position attributes of an INScore object (x, y, z and scale). sensorSet ComplexDiagram( Sequence (NonTerminal('set'), Choice (0, 'accelerometer', 'ambientlight', 'compass', 'gyroscope', 'light', 'magnetometer', 'orientation', 'proximity', 'rotation', 'tilt')) ).addTo() Values generated by a sensor are available using its x , y and z attributes. Depending on the sensor type, y and z may be useless. Note also that events generated in the context of a sensor have the variables $x , $y and $z set with the current sensor values (see section sensorvar ). Example Creating a proximity sensor, querying it's value and watching the value changes. /ITL/scene/sensor set proximity; /ITL/scene/sensor get x; /ITL/scene/sensor watch newData (/ITL/scene/score show '$x'); Values Values generated by the sensors depends on the sensor type and on the the sensor instance (i.e. whether created as signal or as node). Table tab:sensorsval presents the values range for the node and the signal instances. The rationale is that nodes values are raw sensor values while signal values are mapped to the signal range i.e. [-1,1]. Actually, the mapping of the raw values depends on the sensor calibration that can be automatically or manually adjusted. See the section about calibration below. sensor node values signal values comment accelerometer [-v,v] [-1,1] depends on the calibration ambient light {0,1,2,3,4,5} [-1,1] see the note about ambient light below compass [-180,180] [-1,1] gyroscope [-v,v] [-1,1] depends on the calibration light [0,v] [-1,1] depends on the calibration magnetometer [-v,v] [-1,1] orientation {0,1,2,3,4,5,6} [-1,1] see the note about orientation below proximity {0,1} [-1,1] a boolean value mapped to -1, 1 rotation x [-90, 90] [-1,1] y [-180, 180] [-1,1] z [-180, 180] [-1,1] tilt [-90,90] [-1,1] Sensor's values as node and as signal Note: About ambient light Ambient light is measured using discrete values ranging from 0 to 5, where 0 means undefined and 1 to 5 goes from dark to very bright. A value v is mapped to $(v * 0.4 - 1)$ Note: About orientation Orientation is measured using discrete values ranging from 0 to 6, where 0 means undefined and 1 to 6 represents the following orientations: 1: the Top edge of the device is pointing up. 2: the Face of the device is pointing up. 3: the Left edge of the device is pointing up. 4: the Face of the device is pointing down. 5: the Right edge of the device is pointing up. 6: the Top edge of the device is pointing down. A value v is mapped to $(v / 3 - 1)$ In a given way and from values 2 to 5, the device may be viewed as rotating clockwise. A counter-clockwise option is also supported, see section Orientation . Calibration Calibration of sensor values may be viewed as scaling and makes use of the common object's scale attribute. By default, the scale value is 1.0 when the sensor is a regular node. For signal nodes, the default scale value is given by the table tab:sensorsscales . These values have been choosen to map the raw values to the signal range but of course this mapping depends on the device and may greatly vary. In order to accommodate these variations but also to cope with different requirements, scaling can be manually adjusted to any arbitrary value using the scale message, or automatically adjusted to measured peak values using the autoscale message. sensor signal scale comment accelerometer 1/g where g is the gravity on earth i.e. 9.81 ambient light 0.4 see the note about ambient light above compass 1 / 180 gyroscope 1 / 90 light 1 / 200 an arbitrary lux value (considered as magnetometer 10000 orientation 1/3 see the note about orientation above proximity 1.0 the false value is shifted to -1 rotation 1 / 180 for the x value, the scale is multiplied by 2 tilt 1 / 90 Sensor as signal default scaling Note: About auto-scaling Auto-scaling consists in measuring the peak of the absolute values of a sensor during a period. The sensor scale value is next adjusted to $1 / peak$ (see also the sensor common messages in section sensorCommonMsgs ). Auto-scaling is supported by all the sensors, although Sensor common messages All sensors support a common set of message. sensorCommon ComplexDiagram( Choice (0, Sequence ('run', NonTerminal('int32')), Sequence ('smooth', NonTerminal('float32')), Sequence ('scale', NonTerminal('float32')), Sequence ('autoscale', NonTerminal('int32')), 'reset') ).addTo() run : takes a boolean value as parameter. When true, the sensor starts to generate values. Default value is false. smooth : applies exponential smoothing to the sensor values. At a time t , the sensor value is computed as: $s_t = \\alpha.v_t + (1-\\alpha).s_{t-1}$ where v_t is the current sensor value and $0 \\leqslant \\alpha \\leqslant 1$. The parameter is the smoothing factor \\alpha . Default value is 1. scale : sensor values are multiplied by the scale. Default scale is dependent on the sensor type. See table tab:sensorsscales for the default scale values. autoscale : start or stop the auto-scaling process. Default value is false. See the note about auto scaling above. Note that a sensor must be running for the auto-scaling process to take effect. reset : reset the smoothing factor and the scale to their default values. Sensor specific messages Accelerometer sensor accelerometerMsg ComplexDiagram( Sequence ('mode', Choice (0, 'combined', 'gravity', 'user')) ).addTo() mode : the acceleration mode controls how acceleration values are reported. gravity : only the acceleration caused by gravity is reported. Movements of the device caused by the user have no effect other than changing the direction when the device is rotated. user : only the acceleration caused by the user moving the device is reported, the effect of gravity is canceled out. A device at rest therefore should report values of, or close to, zero. combined : both the acceleration caused by gravity and the acceleration caused by the user moving the device is reported combined. Default value is combined . Note: About modes Acceleration caused by gravity and acceleration caused by the user moving the device are physically impossible to distinguish because of general relativity. Most devices use sensor fusion to figure out which parts of the acceleration is caused by gravity, for example by using a rotation sensor to calculate the gravity direction and assuming a fixed magnitude for gravity. Therefore the result is only an approximation and may be inaccurate. The combined mode is the most accurate one, as it does not involve approximating the gravity. Magnetometer sensor magnetometerMsg ComplexDiagram( Sequence ('mode', Choice (0, 'raw', 'geomagnetic')) ).addTo() The magnetometer can report on either raw magnetic flux values or geomagnetic flux values. The primary difference between raw and geomagnetic values is that extra processing is done to eliminate local magnetic interference from the geomagnetic values so they represent only the effect of the Earth's magnetic field. This process is not perfect and the accuracy of each reading may change. Default value is raw . Rotation sensor rotationMsg ComplexDiagram( Sequence ('get', 'hasZ') ).addTo() z angle availability of the rotation sensor can be queried using hasZ . The returned value is a boolean value. Orientation sensor orientationMsg ComplexDiagram( Sequence ('mode', Choice (0, 'clockwise', 'counterClockwise')) ).addTo() mode : selects how the device position is mapped to successive values. Default value is clockwise . See table tab:orientations for the detail of the positions and values. value clockwise counter clockwise 1 Top edge up Top edge up 2 Face up Face up 3 Left edge up Right edge up 4 Face down Face down 5 Right edge up Left edge up 6 Top edge down Top edge down Device positions and values in different modes. Tilt sensor tiltMsg ComplexDiagram( 'calibrate' ).addTo() calibrate : calibrates the tilt sensor: uses the current tilt angles as 0.","title":"Sensors"},{"location":"refs/16-sensors/#sensors","text":"INScore supports various sensors, which can be viewed as objects or as signals. When created as a signal node, a sensor behaves like any signal but may provide some additional features (like calibration). When created as a score element, a sensor has no graphical appearance and provides specific sensor events and features. Table tab:sensors gives the list of supported sensors names. name values description accelerometer x, y, z acceleration on the x, y, and z axis ambient light light level ambient light value compass azimuth, azimuth is in degrees from magnetic north in a clockwise direction gyroscope x, y, z the angular velocity around the x, y, and z axis light lux the light level measured as lux magnetometer x, y, z the raw magnetic flux density measured on th x, y and z axis orientation orientation the device orientation proximity close a boolean value rotation x, y, z the rotation around the x, y and z axis tilt x, y the amount of tilt on the x and y axis. Sensors names and description Note: All the sensors won't likely be available on a given device. In case a sensor is not supported, an error message is generated at creation request and the creation process fails.","title":"Sensors"},{"location":"refs/16-sensors/#sensors-as-signals","text":"A sensor is viewed as a signal when created in a signal node using pre-defined signal names which are listed in table tab:sensorsig . Values provided on different axis (e.g. acceleration on the x, y, and z axis) are available from the sensor subnodes, also listed this table. sensor signal name subnodes accelerometer accelerometer x, y, z ambient light ambientlight none compass compass none gyroscope gyroscope x, y, z light light none magnetometer magnetometer x, y, z orientation orientation none proximity proximity none rotation rotation x, y, [z] tilt tilt x, y Sensor's signal names and subnodes Example Creating a rotation sensor with a 200 values buffer size. /ITL/scene/signal/rotation size 200; Getting accelerometer values on the x axis. /ITL/scene/signal/accelerometer/x get; Note: The rotation sensor may or may not have a z component however, the z signal is always present but set to 0 when no z component is available. A specific message is provided to get the z component status (see section Rotation ).","title":"Sensors as signals"},{"location":"refs/16-sensors/#sensors-as-nodes","text":"A sensor is viewed as a regular INScore node when created outside a signal node and using one of the sensors types defined below. A sensor node has no graphical appearance but has the position attributes of an INScore object (x, y, z and scale). sensorSet ComplexDiagram( Sequence (NonTerminal('set'), Choice (0, 'accelerometer', 'ambientlight', 'compass', 'gyroscope', 'light', 'magnetometer', 'orientation', 'proximity', 'rotation', 'tilt')) ).addTo() Values generated by a sensor are available using its x , y and z attributes. Depending on the sensor type, y and z may be useless. Note also that events generated in the context of a sensor have the variables $x , $y and $z set with the current sensor values (see section sensorvar ). Example Creating a proximity sensor, querying it's value and watching the value changes. /ITL/scene/sensor set proximity; /ITL/scene/sensor get x; /ITL/scene/sensor watch newData (/ITL/scene/score show '$x');","title":"Sensors as nodes"},{"location":"refs/16-sensors/#values","text":"Values generated by the sensors depends on the sensor type and on the the sensor instance (i.e. whether created as signal or as node). Table tab:sensorsval presents the values range for the node and the signal instances. The rationale is that nodes values are raw sensor values while signal values are mapped to the signal range i.e. [-1,1]. Actually, the mapping of the raw values depends on the sensor calibration that can be automatically or manually adjusted. See the section about calibration below. sensor node values signal values comment accelerometer [-v,v] [-1,1] depends on the calibration ambient light {0,1,2,3,4,5} [-1,1] see the note about ambient light below compass [-180,180] [-1,1] gyroscope [-v,v] [-1,1] depends on the calibration light [0,v] [-1,1] depends on the calibration magnetometer [-v,v] [-1,1] orientation {0,1,2,3,4,5,6} [-1,1] see the note about orientation below proximity {0,1} [-1,1] a boolean value mapped to -1, 1 rotation x [-90, 90] [-1,1] y [-180, 180] [-1,1] z [-180, 180] [-1,1] tilt [-90,90] [-1,1] Sensor's values as node and as signal Note: About ambient light Ambient light is measured using discrete values ranging from 0 to 5, where 0 means undefined and 1 to 5 goes from dark to very bright. A value v is mapped to $(v * 0.4 - 1)$ Note: About orientation Orientation is measured using discrete values ranging from 0 to 6, where 0 means undefined and 1 to 6 represents the following orientations: 1: the Top edge of the device is pointing up. 2: the Face of the device is pointing up. 3: the Left edge of the device is pointing up. 4: the Face of the device is pointing down. 5: the Right edge of the device is pointing up. 6: the Top edge of the device is pointing down. A value v is mapped to $(v / 3 - 1)$ In a given way and from values 2 to 5, the device may be viewed as rotating clockwise. A counter-clockwise option is also supported, see section Orientation .","title":"Values"},{"location":"refs/16-sensors/#calibration","text":"Calibration of sensor values may be viewed as scaling and makes use of the common object's scale attribute. By default, the scale value is 1.0 when the sensor is a regular node. For signal nodes, the default scale value is given by the table tab:sensorsscales . These values have been choosen to map the raw values to the signal range but of course this mapping depends on the device and may greatly vary. In order to accommodate these variations but also to cope with different requirements, scaling can be manually adjusted to any arbitrary value using the scale message, or automatically adjusted to measured peak values using the autoscale message. sensor signal scale comment accelerometer 1/g where g is the gravity on earth i.e. 9.81 ambient light 0.4 see the note about ambient light above compass 1 / 180 gyroscope 1 / 90 light 1 / 200 an arbitrary lux value (considered as magnetometer 10000 orientation 1/3 see the note about orientation above proximity 1.0 the false value is shifted to -1 rotation 1 / 180 for the x value, the scale is multiplied by 2 tilt 1 / 90 Sensor as signal default scaling Note: About auto-scaling Auto-scaling consists in measuring the peak of the absolute values of a sensor during a period. The sensor scale value is next adjusted to $1 / peak$ (see also the sensor common messages in section sensorCommonMsgs ). Auto-scaling is supported by all the sensors, although","title":"Calibration"},{"location":"refs/16-sensors/#sensor-common-messages","text":"All sensors support a common set of message. sensorCommon ComplexDiagram( Choice (0, Sequence ('run', NonTerminal('int32')), Sequence ('smooth', NonTerminal('float32')), Sequence ('scale', NonTerminal('float32')), Sequence ('autoscale', NonTerminal('int32')), 'reset') ).addTo() run : takes a boolean value as parameter. When true, the sensor starts to generate values. Default value is false. smooth : applies exponential smoothing to the sensor values. At a time t , the sensor value is computed as: $s_t = \\alpha.v_t + (1-\\alpha).s_{t-1}$ where v_t is the current sensor value and $0 \\leqslant \\alpha \\leqslant 1$. The parameter is the smoothing factor \\alpha . Default value is 1. scale : sensor values are multiplied by the scale. Default scale is dependent on the sensor type. See table tab:sensorsscales for the default scale values. autoscale : start or stop the auto-scaling process. Default value is false. See the note about auto scaling above. Note that a sensor must be running for the auto-scaling process to take effect. reset : reset the smoothing factor and the scale to their default values.","title":"Sensor common messages"},{"location":"refs/16-sensors/#sensor-specific-messages","text":"","title":"Sensor specific messages"},{"location":"refs/16-sensors/#accelerometer-sensor","text":"accelerometerMsg ComplexDiagram( Sequence ('mode', Choice (0, 'combined', 'gravity', 'user')) ).addTo() mode : the acceleration mode controls how acceleration values are reported. gravity : only the acceleration caused by gravity is reported. Movements of the device caused by the user have no effect other than changing the direction when the device is rotated. user : only the acceleration caused by the user moving the device is reported, the effect of gravity is canceled out. A device at rest therefore should report values of, or close to, zero. combined : both the acceleration caused by gravity and the acceleration caused by the user moving the device is reported combined. Default value is combined . Note: About modes Acceleration caused by gravity and acceleration caused by the user moving the device are physically impossible to distinguish because of general relativity. Most devices use sensor fusion to figure out which parts of the acceleration is caused by gravity, for example by using a rotation sensor to calculate the gravity direction and assuming a fixed magnitude for gravity. Therefore the result is only an approximation and may be inaccurate. The combined mode is the most accurate one, as it does not involve approximating the gravity.","title":"Accelerometer sensor"},{"location":"refs/16-sensors/#magnetometer-sensor","text":"magnetometerMsg ComplexDiagram( Sequence ('mode', Choice (0, 'raw', 'geomagnetic')) ).addTo() The magnetometer can report on either raw magnetic flux values or geomagnetic flux values. The primary difference between raw and geomagnetic values is that extra processing is done to eliminate local magnetic interference from the geomagnetic values so they represent only the effect of the Earth's magnetic field. This process is not perfect and the accuracy of each reading may change. Default value is raw .","title":"Magnetometer sensor"},{"location":"refs/16-sensors/#rotation-sensor","text":"rotationMsg ComplexDiagram( Sequence ('get', 'hasZ') ).addTo() z angle availability of the rotation sensor can be queried using hasZ . The returned value is a boolean value.","title":"Rotation sensor"},{"location":"refs/16-sensors/#orientation-sensor","text":"orientationMsg ComplexDiagram( Sequence ('mode', Choice (0, 'clockwise', 'counterClockwise')) ).addTo() mode : selects how the device position is mapped to successive values. Default value is clockwise . See table tab:orientations for the detail of the positions and values. value clockwise counter clockwise 1 Top edge up Top edge up 2 Face up Face up 3 Left edge up Right edge up 4 Face down Face down 5 Right edge up Left edge up 6 Top edge down Top edge down Device positions and values in different modes.","title":"Orientation sensor"},{"location":"refs/16-sensors/#tilt-sensor","text":"tiltMsg ComplexDiagram( 'calibrate' ).addTo() calibrate : calibrates the tilt sensor: uses the current tilt angles as 0.","title":"Tilt sensor"},{"location":"refs/17-interaction/","text":"Events and Interaction Interaction messages are user defined messages associated to events and triggered when these events occur. These messages accept variables as message arguments. Events are typical user interface events (mouse or touch events), extended in the time domain and to specific objects or engine properties. Starting from INScore version 1.20, the modification of any object attribute may be viewed as an event and user defined events have also been introduced (see section attributeevents for more details). The general form of the message to watch an event is the following: interactMsg ComplexDiagram( Sequence (Choice (0, 'watch', 'watch+'), Choice (0, Comment ('1'), Sequence (NonTerminal('what'), Choice (0, Comment ('2'), Sequence (Comment ('3'), \"(\", OneOrMore (NonTerminal('message'), \",\"), \")\"), Sequence (Comment ('4'), NonTerminal('message')))))) ).addTo() what represents the event to watch and message is a list of associated messages, separated by a comma. A colon (':') is also supported as separator (to avoid issues with comma in Max). [1]: clear all the messages for all the events. [2]: clear the messages associated to the what event. [3]: associate a list of messages to the what event. With watch , the messages replace previously associated messages. Using watch+ , the messages are appended to the messages currently associated to the event. [4]: associate or add a single message to the what event. This form is provided for compatibility with previous versions. Note: The [1] and [2] form has no effect with the watch+ message. In some environments, the comma has a special meaning, making tricky to use it as a message separator. This is why ':' is also accepted as separator in OSC messages lists. The get watch message gives all the watch messages of a node, but doesn't take any argument. message ComplexDiagram( Sequence (Optional ( NonTerminal('addressPrefix')), NonTerminal('OSCAddress'), Optional ( OneOrMore (Choice (0, NonTerminal('parameters'), NonTerminal('variable'))))) ).addTo() The associated messages are any valid OSC message (not restricted to the INScore message set), with an extended address scheme, supporting IP addresses or host names and udp port number to be specified as OSC addresses prefix. The message parameters are any valid OSC type or variable (see section interactvar ). addressPrefix ComplexDiagram( Sequence (Choice (0, NonTerminal('IPAddress'), NonTerminal('hostname')), ':', NonTerminal('port')) ).addTo() Example An extended address to send messages to localhost on port 12000 : localhost:12000/your/osc/address; Internal events Internal events are triggered by the user interaction (mouse or touch events) or by the engine internal functioning. Mouse events User interface events are typical mouse events: mouseEvent ComplexDiagram( Choice (0, 'mouseDown', 'mouseUp', 'mouseEnter', 'mouseLeave', 'mouseMove', 'doubleClick') ).addTo() Example Triggering a message on mouse down: /ITL/scene/myObject watch mouseDown (/ITL/scene/myObject show 0); the object hides itself on mouse click. Triggering a message on mouse down but addressed to another host on udp port 12100: /ITL/scene/myObject watch mouseDown (host.domain.org:12100/an/address start); Note: UI events are not supported by objects that are synchronized as slave. Mouse events can be simulated using a event message: uievt ComplexDiagram( Sequence ('event', NonTerminal('mouseEvent'), NonTerminal('x'), NonTerminal('y')) ).addTo() where mouseEvent is one of the events described above, x and y are integer values giving the click position, expressed in pixels and relative to the target object. Example Simulating a mouse down at position 10, 10 : /ITL/scene/myObject event mouseDown 10 10; Touch events Depending on the display device, multi-touch events are supported by INScore : touchEvent ComplexDiagram( Choice (0, 'touchBegin', 'touchEnd', 'touchUpdate') ).addTo() A typical sequence of generated events consists in a touchBegin event, followed by touchUpdate events and closed by a touchEnd . Time events Events are also defined on the time domain: timeEvent ComplexDiagram( Choice (0, Sequence ('timeEnter', NonTerminal('time'), NonTerminal('time')), Sequence ('timeLeave', NonTerminal('time'), NonTerminal('time')), Sequence ('durEnter', NonTerminal('time'), NonTerminal('time')), Sequence ('durLeave', NonTerminal('time'), NonTerminal('time'))) ).addTo() Each event takes a time interval as parameter, defined by two time specifications (see section time for the time format) timeEnter , timeLeave are triggered when an object date is moved to or out of a watched time interval, durEnter , durLeave are triggered when an object duration is moved to or out of a watched time interval. Example An object that moves a score to a given page number when it enters its time zone. /ITL/scene/myObject watch timeEnter 10/1 18/1 (/ITL/scene/score page 2); Keyboard events Keyboard events are triggered by pressing or releasing a key on the keyboard. keyEvent ComplexDiagram( Sequence (Choice (0, 'keyDown', 'keyUp'), Choice (0, Sequence (Comment ('1'), NonTerminal('char')), Sequence (Comment ('2'), '[', NonTerminal('charlist'), ']'), Sequence (Comment ('3'), '*'), Sequence (Comment ('4'), NonTerminal('controlKey')))) ).addTo() controlKey ComplexDiagram( Choice (0, 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown') ).addTo() 1) only the specified char will trigger the event, 2) charlist is a string interpreted like the bracket expression of regular expressions. For example, using [abc] , 'a' or 'b' or 'c' will trigger a key event, using [1-9] , any numeric from 1 to 9 will trigger a key event. 3) any key triggers a key event. 4) handles special keys to trigger the key event. A literal description of the key must be provided (e.g. ArrowLeft ). Note: Unlike standard applications, there is no notion of focus regarding key events: when several objects request keyboard input, all of them will receive key events, provided they are watching the same input. MIDI events MIDI events are supported, but only by the Web version. MIDI events are supported by the native version for compatibility reasons but they are inactive (no MIDI input). See INScore Web documentation for more details. URL events url objects (i.e. intermediate objects for URL based objects (see section filebasedrsrc ) support specific events, intended to reflect the transaction state: urlEvent ComplexDiagram( Choice (0, 'success', 'error', 'cancel') ).addTo() success is triggered when the data have been downloaded, error is triggered when an error has occurred during the download, cancel is triggered when the target url or the object type is changed while downloading. Example Triggering an error message in case of failure : /ITL/scene/score set gmnf \"http://ahost.adomain.org/score.gmn\"; /ITL/scene/score watch error( /ITL/scene/status set txt \"Failed to download file\" ); Miscellaneous events miscEvent ComplexDiagram( Choice (0, 'export', 'newData') ).addTo() the export event is supported by all the components. It is triggered after an export message has been handled and could be used to simulate synchronous exports. the newData event is supported by all the components. It is triggered when the object specific data are modified (typically using the set message). Type specific events specificEvent ComplexDiagram( Choice (0, 'pageCount', 'newElement', 'endPaint', 'error', 'ready', 'end') ).addTo() the pageCount event is supported by all the symbolic score components ( gmn(f) , gmnstream , musicxml(f) ). It is triggered when the page count of the score changes. It is mainly intended to manage variable scores like gmnstream . the newElement event is supported at scene and application ( /ITL ) level and triggered when a new element is added to the scene or when a new scene is created. the endPaint event is supported at scene level only and triggered after a scene has been painted. the error event is supported at application level and triggered when an error occurs while receiving messages. Typically you can use of this event to open the log window ( /ITL/log show 1 ) the ready event is supported by media objects ( audio and video ). It is triggered when media data (duration, graphic dimensions) are available. the end event is supported by media objects ( audio and video ). It is triggered when a media is playing and reaches the end of the media. In this case, the object play status is automatically switched to 0 to reflect the actual player state. Example Displaying a welcome message to new elements: /ITL/scene watch newElement (/ITL/scene/msg set txt \"Welcome\"); Attribute based events Attribute based events includes the whole set of messages that are supported by an object: x , y , color , etc. but also type specific messages. These events are triggered when a message has been succesfully processed. However, you shouldn't assume that the attribute value has been changed: when a message sets an attribute to it's current value, it is succesully processed and the corresponding event - if any - is triggered. Example Watching an object x coordinate change: /ITL/scene/myObject watch x (/ITL/scene/msg set txt \"myObject moved\"); Note: Watching the newData event is equivalent to watch the set attribute. However, the newData event is triggered only when the object state is changed. Although not an object attribute, the del message can be watched and triggered when an object is deleted. Warning With the event's generalization to any object attribute, a one tick delay has been introduced to all events. Thus the associated messages are not processed synchronously to the event but posted to be processed by the next time task. This delay has been introduced to avoid freezing the system in case of loops. However, it introduces also a pitfall in interaction design, when message based variables are used (see section msgvar ): message based variables are evaluated at the event time while messages are processed by the next time task, thus the following messages won't produce the expected result: /ITL/scene/myObject watch x ( /ITL/scene/A x '$(/ITL/scene/myObject get x)', /ITL/scene/B x '$(/ITL/scene/A get x)' ); actually, when the $(/ITL/scene/A get x) variable is evaluated, the preceding message that sets the x attribute of A has not been already processed. One workaround consists in splitting the interaction in several parts, making sure that the messages are processed e.g. /ITL/scene/myObject watch x ( /ITL/scene/A x '$(/ITL/scene/myObject get x)'); /ITL/scene/A watch x ( /ITL/scene/B x '$(/ITL/scene/A get x)' ); User defined events INScore events supports user defined events. The name of user defined events must start with a capital letter and be composed of capital letters and/or numbers. Other characters are reserved for INScore use. Messages attached to user defined events accept regular variables (although the position variables are useless), but they accept also any number of a variables which names are $1, ... $i and which values are taken from the event call arguments (see section udevar ). User defined events can only be triggered using the event message (see section eventMsg ). Example Watching and triggering a user defined event: /ITL/scene/myObject watch MYEVENT (/ITL/scene/msg set txt \"MYEVENT occured!\"); /ITL/scene/myObject event MYEVENT; Defining high level abstractions: /ITL/scene/myObject watch MOVEABC ( /ITL/scene/a x $1, /ITL/scene/b x $2, /ITL/scene/C x $3 ); /ITL/scene/myObject event MOVEABC -0.4 0.1 0.6; The 'event' message The event message may be used to triggered events. It's the only way to trigger user defined events. It may be used also to simulate user interface events (like mouse events). eventMsg ComplexDiagram( Sequence ('event', Choice (0, Sequence (Comment ('1'), Sequence (Choice (0, NonTerminal('mouseEvent'), NonTerminal('touchEvent')), NonTerminal('float32'), NonTerminal('float32'))), Sequence (Comment ('2'), NonTerminal('userEvent'), Optional ( OneOrMore (NonTerminal('var')))), Sequence (Comment ('3'), NonTerminal('eventName')))) ).addTo() 1 : this form is intended to simulate mouse or touch event. It must be followed by the x and y coordinates of the interaction point. Coordinates express a position in pixels (the top left corner of the object is in [0,0]). 2 : triggers a user defined event. It accepts any number of arguments, that are then expanded in place of the variables $1 ... $i. User defined events may be viewed as functions with arbitrary parameters; however parameters count and type is not checked. 3 : triggers any other event. Note: Time events are excluded from the event message supported events: to trigger a time event, you can use a date message. Variables Variables are values computed when an event is triggered. These values are send in place of the variable. A variable name starts with a '$' sign. Position variables Position variables reflects the current mouse position for mouse events or the current touch position for touch events. For attribute based events, the x and y variables are set to the target object current position and the other variables are undefined. For other events, the position variables are set to 0 . posVar ComplexDiagram( Choice (0, NonTerminal('xy'), 'absx', 'absy', 'sx', 'sy') ).addTo() where xy ComplexDiagram( Sequence (Choice (0, 'x', 'y'), Optional ( '[low,high]')) ).addTo() $x $y : denotes the mouse pointer position at the time of the event. The values are in the range [0,1] where 1 is the object size in the x or y dimension. The value is computed according to the object origin: it represents the mouse pointer distance from the object x or y origin (see origin ). $x and $y variables support an optional range in the form [low, high] that transforms the [0,1] values range into the [low, high] range. $absx $absy : denotes the mouse pointer absolute position at the time of the event. The values represent a pixel position relative to the top-left point of the target object. Note that this position is unaffected by scale. Note also that the values are not clipped to the object dimensions and could exceed its width or height or become negative in case of mouse move events. $sx $sy : denotes the mouse pointer position in the scene coordinates space. Example An object that follows mouse move. /ITL/scene/myObject watch mouseDown ( /ITL/scene/myObject x '$sx', /ITL/scene/myObject y '$sy' ); Sensor variables Sensors values are available using the $x , $y and $z variables, for events generated in the context of a sensor. xyz ComplexDiagram( Sequence (Choice (0, 'x', 'y', 'z'), Optional ( '[low,high]')) ).addTo() Note that depending on the sensor type, the $y and $z variables may be useless. Time variables Time variables reflects the date corresponding to the current mouse position for mouse events. For attribute based events, the time variables are set to the target object current time position. They are set to 0 for the other events. timeVar ComplexDiagram( Sequence (Choice (0, 'date', 'rdate'), Optional ( Sequence (':', NonTerminal('mapname'))), Optional ( '[n/d]'), Optional ( Sequence ('%', Choice (0, 'f', 'a')))) ).addTo() $date : denotes the object date corresponding to the mouse pointer position at the time of the event. It is optionally followed by a colon and the name of the mapping to be used to compute the date. The $date variable is replaced by its rational value (i.e. two integers values). The optional rational enclosed in brackets may be used to indicate a quantification: the date value is rounded to an integer count of the specified rational value. The optional %f may be used to get the date delivered as a float value. $rdate : is similar to $date but ignores the target current date: the date is relative to the object mapping only. %f or %a : request the date value as a float value or as an absolute time value. Absolute time is expressed in seconds, assuming a tempo value of 60 bpm. Actually, $date%a = $date%f / 4 Note: A variable can be used several times in a message, but several $date variables must always refer to the same mapping. Example Sending the current date as a float value to an external application: /ITL/scene/myObject watch mouseDown ( targetHost:12000/date '$date%f' ); Miscellaneous variables variable ComplexDiagram( Choice (0, 'name', 'scene', 'address') ).addTo() $name is replaced by the target object name. $scene is replaced by the target object scene name. $address is replaced by the target object OSC address. Note: For the newElement event, the target object is the new element. Example Using an object name: /ITL/scene watch newElement (/ITL/scene/welcome set txt \"Welcome\" '$name'); Message based variables A message based variable is a variable containing an OSC message which will be evaluated at the time of the event. They are supported by all kind of events. Like the variables above, a message based variable starts with a '$' sign followed by a valid 'get' message enclosed in parenthesis: msgVar ComplexDiagram( Sequence ('(', NonTerminal('oscaddress'), 'get', Optional ( NonTerminal('params')), ')') ).addTo() The evaluation of a 'get' message produces a message or a list of messages. The message based variable will be replaced by the parameters of the messages resulting from the evaluation of the 'get' message. Note that all the 'get' messages attached to an event are evaluated at the same time. Example An object that takes the x position of another object on mouse down: /ITL/scene/myObject watch mouseDown (/ITL/scene/myObject x '$(/ITL/scene/obj get x)'); Variables for user defined events Messages associated to user defined events accept any number of a variables which names are $1, ... $i and which values are taken from the event call arguments. These events may be viewed as functions with arbitrary parameters; however parameters count and type is not checked: arguments in excess are ignored and variables without corresponding argument (e.g. $3 when only 2 arguments are available) are left unexpanded. OSC address variables The OSC address of a message associated to an event supports the following variables: $self : replaced by the object name. $scene : replaced by the scene name. Example Requesting a set of objects to send a message to themselves on a mouse event: /ITL/scene/* watch mouseDown # request all the objects of the scene (/ITL/scene/$self x '$sx'); # to send a message to themselves Interaction state management For a given object, its interaction state (i.e. the watched events and the associated messages) can be saved and restored. stateMsg ComplexDiagram( Choice (0, 'push', 'pop') ).addTo() Interaction states are managed using a stack where the states are pushed to or popped from. push : push the current interaction state on top of the stack. pop : replace the current interaction state with the one popped from the top of the stack. The different states stored in this stack can be obtain with the message : stackMsg ComplexDiagram( Sequence ('get', 'stack') ).addTo() Note: The effect of a pop message addressed to an object with an empty stack is to clear the object current interaction state. File watcher The fileWatcher is a static node of a scene that is intended to watch file modifications. It receives messages at the address /ITL/scene/fileWatcher . The fileWatcher support the watch and watch+ messages as described in section interaction with a file name used in place of the what parameter. fileWatcher ComplexDiagram( Sequence (Choice (0, 'watch', 'watch+'), Optional ( Sequence (NonTerminal('filePath'), Optional ( OneOrMore (NonTerminal('message'), \",\"))))) ).addTo() Example Reload an INScore script on file modification: /ITL/scene/fileWatcher watch 'myScript.inscore' ( /ITL/scene load 'myScript.inscore' ); Note: Some text editors delete the target file before saving. In this case, it breaks the file watching system and thus, it doesn't work as expected.","title":"Events"},{"location":"refs/17-interaction/#events-and-interaction","text":"Interaction messages are user defined messages associated to events and triggered when these events occur. These messages accept variables as message arguments. Events are typical user interface events (mouse or touch events), extended in the time domain and to specific objects or engine properties. Starting from INScore version 1.20, the modification of any object attribute may be viewed as an event and user defined events have also been introduced (see section attributeevents for more details). The general form of the message to watch an event is the following: interactMsg ComplexDiagram( Sequence (Choice (0, 'watch', 'watch+'), Choice (0, Comment ('1'), Sequence (NonTerminal('what'), Choice (0, Comment ('2'), Sequence (Comment ('3'), \"(\", OneOrMore (NonTerminal('message'), \",\"), \")\"), Sequence (Comment ('4'), NonTerminal('message')))))) ).addTo() what represents the event to watch and message is a list of associated messages, separated by a comma. A colon (':') is also supported as separator (to avoid issues with comma in Max). [1]: clear all the messages for all the events. [2]: clear the messages associated to the what event. [3]: associate a list of messages to the what event. With watch , the messages replace previously associated messages. Using watch+ , the messages are appended to the messages currently associated to the event. [4]: associate or add a single message to the what event. This form is provided for compatibility with previous versions. Note: The [1] and [2] form has no effect with the watch+ message. In some environments, the comma has a special meaning, making tricky to use it as a message separator. This is why ':' is also accepted as separator in OSC messages lists. The get watch message gives all the watch messages of a node, but doesn't take any argument. message ComplexDiagram( Sequence (Optional ( NonTerminal('addressPrefix')), NonTerminal('OSCAddress'), Optional ( OneOrMore (Choice (0, NonTerminal('parameters'), NonTerminal('variable'))))) ).addTo() The associated messages are any valid OSC message (not restricted to the INScore message set), with an extended address scheme, supporting IP addresses or host names and udp port number to be specified as OSC addresses prefix. The message parameters are any valid OSC type or variable (see section interactvar ). addressPrefix ComplexDiagram( Sequence (Choice (0, NonTerminal('IPAddress'), NonTerminal('hostname')), ':', NonTerminal('port')) ).addTo() Example An extended address to send messages to localhost on port 12000 : localhost:12000/your/osc/address;","title":"Events and Interaction"},{"location":"refs/17-interaction/#internal-events","text":"Internal events are triggered by the user interaction (mouse or touch events) or by the engine internal functioning.","title":"Internal events"},{"location":"refs/17-interaction/#mouse-events","text":"User interface events are typical mouse events: mouseEvent ComplexDiagram( Choice (0, 'mouseDown', 'mouseUp', 'mouseEnter', 'mouseLeave', 'mouseMove', 'doubleClick') ).addTo() Example Triggering a message on mouse down: /ITL/scene/myObject watch mouseDown (/ITL/scene/myObject show 0); the object hides itself on mouse click. Triggering a message on mouse down but addressed to another host on udp port 12100: /ITL/scene/myObject watch mouseDown (host.domain.org:12100/an/address start); Note: UI events are not supported by objects that are synchronized as slave. Mouse events can be simulated using a event message: uievt ComplexDiagram( Sequence ('event', NonTerminal('mouseEvent'), NonTerminal('x'), NonTerminal('y')) ).addTo() where mouseEvent is one of the events described above, x and y are integer values giving the click position, expressed in pixels and relative to the target object. Example Simulating a mouse down at position 10, 10 : /ITL/scene/myObject event mouseDown 10 10;","title":"Mouse events"},{"location":"refs/17-interaction/#touch-events","text":"Depending on the display device, multi-touch events are supported by INScore : touchEvent ComplexDiagram( Choice (0, 'touchBegin', 'touchEnd', 'touchUpdate') ).addTo() A typical sequence of generated events consists in a touchBegin event, followed by touchUpdate events and closed by a touchEnd .","title":"Touch events"},{"location":"refs/17-interaction/#time-events","text":"Events are also defined on the time domain: timeEvent ComplexDiagram( Choice (0, Sequence ('timeEnter', NonTerminal('time'), NonTerminal('time')), Sequence ('timeLeave', NonTerminal('time'), NonTerminal('time')), Sequence ('durEnter', NonTerminal('time'), NonTerminal('time')), Sequence ('durLeave', NonTerminal('time'), NonTerminal('time'))) ).addTo() Each event takes a time interval as parameter, defined by two time specifications (see section time for the time format) timeEnter , timeLeave are triggered when an object date is moved to or out of a watched time interval, durEnter , durLeave are triggered when an object duration is moved to or out of a watched time interval. Example An object that moves a score to a given page number when it enters its time zone. /ITL/scene/myObject watch timeEnter 10/1 18/1 (/ITL/scene/score page 2);","title":"Time events"},{"location":"refs/17-interaction/#keyboard-events","text":"Keyboard events are triggered by pressing or releasing a key on the keyboard. keyEvent ComplexDiagram( Sequence (Choice (0, 'keyDown', 'keyUp'), Choice (0, Sequence (Comment ('1'), NonTerminal('char')), Sequence (Comment ('2'), '[', NonTerminal('charlist'), ']'), Sequence (Comment ('3'), '*'), Sequence (Comment ('4'), NonTerminal('controlKey')))) ).addTo() controlKey ComplexDiagram( Choice (0, 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown') ).addTo() 1) only the specified char will trigger the event, 2) charlist is a string interpreted like the bracket expression of regular expressions. For example, using [abc] , 'a' or 'b' or 'c' will trigger a key event, using [1-9] , any numeric from 1 to 9 will trigger a key event. 3) any key triggers a key event. 4) handles special keys to trigger the key event. A literal description of the key must be provided (e.g. ArrowLeft ). Note: Unlike standard applications, there is no notion of focus regarding key events: when several objects request keyboard input, all of them will receive key events, provided they are watching the same input.","title":"Keyboard events"},{"location":"refs/17-interaction/#midi-events","text":"MIDI events are supported, but only by the Web version. MIDI events are supported by the native version for compatibility reasons but they are inactive (no MIDI input). See INScore Web documentation for more details.","title":"MIDI events"},{"location":"refs/17-interaction/#url-events","text":"url objects (i.e. intermediate objects for URL based objects (see section filebasedrsrc ) support specific events, intended to reflect the transaction state: urlEvent ComplexDiagram( Choice (0, 'success', 'error', 'cancel') ).addTo() success is triggered when the data have been downloaded, error is triggered when an error has occurred during the download, cancel is triggered when the target url or the object type is changed while downloading. Example Triggering an error message in case of failure : /ITL/scene/score set gmnf \"http://ahost.adomain.org/score.gmn\"; /ITL/scene/score watch error( /ITL/scene/status set txt \"Failed to download file\" );","title":"URL events"},{"location":"refs/17-interaction/#miscellaneous-events","text":"miscEvent ComplexDiagram( Choice (0, 'export', 'newData') ).addTo() the export event is supported by all the components. It is triggered after an export message has been handled and could be used to simulate synchronous exports. the newData event is supported by all the components. It is triggered when the object specific data are modified (typically using the set message).","title":"Miscellaneous events"},{"location":"refs/17-interaction/#type-specific-events","text":"specificEvent ComplexDiagram( Choice (0, 'pageCount', 'newElement', 'endPaint', 'error', 'ready', 'end') ).addTo() the pageCount event is supported by all the symbolic score components ( gmn(f) , gmnstream , musicxml(f) ). It is triggered when the page count of the score changes. It is mainly intended to manage variable scores like gmnstream . the newElement event is supported at scene and application ( /ITL ) level and triggered when a new element is added to the scene or when a new scene is created. the endPaint event is supported at scene level only and triggered after a scene has been painted. the error event is supported at application level and triggered when an error occurs while receiving messages. Typically you can use of this event to open the log window ( /ITL/log show 1 ) the ready event is supported by media objects ( audio and video ). It is triggered when media data (duration, graphic dimensions) are available. the end event is supported by media objects ( audio and video ). It is triggered when a media is playing and reaches the end of the media. In this case, the object play status is automatically switched to 0 to reflect the actual player state. Example Displaying a welcome message to new elements: /ITL/scene watch newElement (/ITL/scene/msg set txt \"Welcome\");","title":"Type specific events"},{"location":"refs/17-interaction/#attribute-based-events","text":"Attribute based events includes the whole set of messages that are supported by an object: x , y , color , etc. but also type specific messages. These events are triggered when a message has been succesfully processed. However, you shouldn't assume that the attribute value has been changed: when a message sets an attribute to it's current value, it is succesully processed and the corresponding event - if any - is triggered. Example Watching an object x coordinate change: /ITL/scene/myObject watch x (/ITL/scene/msg set txt \"myObject moved\"); Note: Watching the newData event is equivalent to watch the set attribute. However, the newData event is triggered only when the object state is changed. Although not an object attribute, the del message can be watched and triggered when an object is deleted. Warning With the event's generalization to any object attribute, a one tick delay has been introduced to all events. Thus the associated messages are not processed synchronously to the event but posted to be processed by the next time task. This delay has been introduced to avoid freezing the system in case of loops. However, it introduces also a pitfall in interaction design, when message based variables are used (see section msgvar ): message based variables are evaluated at the event time while messages are processed by the next time task, thus the following messages won't produce the expected result: /ITL/scene/myObject watch x ( /ITL/scene/A x '$(/ITL/scene/myObject get x)', /ITL/scene/B x '$(/ITL/scene/A get x)' ); actually, when the $(/ITL/scene/A get x) variable is evaluated, the preceding message that sets the x attribute of A has not been already processed. One workaround consists in splitting the interaction in several parts, making sure that the messages are processed e.g. /ITL/scene/myObject watch x ( /ITL/scene/A x '$(/ITL/scene/myObject get x)'); /ITL/scene/A watch x ( /ITL/scene/B x '$(/ITL/scene/A get x)' );","title":"Attribute based events"},{"location":"refs/17-interaction/#user-defined-events","text":"INScore events supports user defined events. The name of user defined events must start with a capital letter and be composed of capital letters and/or numbers. Other characters are reserved for INScore use. Messages attached to user defined events accept regular variables (although the position variables are useless), but they accept also any number of a variables which names are $1, ... $i and which values are taken from the event call arguments (see section udevar ). User defined events can only be triggered using the event message (see section eventMsg ). Example Watching and triggering a user defined event: /ITL/scene/myObject watch MYEVENT (/ITL/scene/msg set txt \"MYEVENT occured!\"); /ITL/scene/myObject event MYEVENT; Defining high level abstractions: /ITL/scene/myObject watch MOVEABC ( /ITL/scene/a x $1, /ITL/scene/b x $2, /ITL/scene/C x $3 ); /ITL/scene/myObject event MOVEABC -0.4 0.1 0.6;","title":"User defined events"},{"location":"refs/17-interaction/#the-event-message","text":"The event message may be used to triggered events. It's the only way to trigger user defined events. It may be used also to simulate user interface events (like mouse events). eventMsg ComplexDiagram( Sequence ('event', Choice (0, Sequence (Comment ('1'), Sequence (Choice (0, NonTerminal('mouseEvent'), NonTerminal('touchEvent')), NonTerminal('float32'), NonTerminal('float32'))), Sequence (Comment ('2'), NonTerminal('userEvent'), Optional ( OneOrMore (NonTerminal('var')))), Sequence (Comment ('3'), NonTerminal('eventName')))) ).addTo() 1 : this form is intended to simulate mouse or touch event. It must be followed by the x and y coordinates of the interaction point. Coordinates express a position in pixels (the top left corner of the object is in [0,0]). 2 : triggers a user defined event. It accepts any number of arguments, that are then expanded in place of the variables $1 ... $i. User defined events may be viewed as functions with arbitrary parameters; however parameters count and type is not checked. 3 : triggers any other event. Note: Time events are excluded from the event message supported events: to trigger a time event, you can use a date message.","title":"The 'event' message"},{"location":"refs/17-interaction/#variables","text":"Variables are values computed when an event is triggered. These values are send in place of the variable. A variable name starts with a '$' sign.","title":"Variables"},{"location":"refs/17-interaction/#position-variables","text":"Position variables reflects the current mouse position for mouse events or the current touch position for touch events. For attribute based events, the x and y variables are set to the target object current position and the other variables are undefined. For other events, the position variables are set to 0 . posVar ComplexDiagram( Choice (0, NonTerminal('xy'), 'absx', 'absy', 'sx', 'sy') ).addTo() where xy ComplexDiagram( Sequence (Choice (0, 'x', 'y'), Optional ( '[low,high]')) ).addTo() $x $y : denotes the mouse pointer position at the time of the event. The values are in the range [0,1] where 1 is the object size in the x or y dimension. The value is computed according to the object origin: it represents the mouse pointer distance from the object x or y origin (see origin ). $x and $y variables support an optional range in the form [low, high] that transforms the [0,1] values range into the [low, high] range. $absx $absy : denotes the mouse pointer absolute position at the time of the event. The values represent a pixel position relative to the top-left point of the target object. Note that this position is unaffected by scale. Note also that the values are not clipped to the object dimensions and could exceed its width or height or become negative in case of mouse move events. $sx $sy : denotes the mouse pointer position in the scene coordinates space. Example An object that follows mouse move. /ITL/scene/myObject watch mouseDown ( /ITL/scene/myObject x '$sx', /ITL/scene/myObject y '$sy' );","title":"Position variables"},{"location":"refs/17-interaction/#sensor-variables","text":"Sensors values are available using the $x , $y and $z variables, for events generated in the context of a sensor. xyz ComplexDiagram( Sequence (Choice (0, 'x', 'y', 'z'), Optional ( '[low,high]')) ).addTo() Note that depending on the sensor type, the $y and $z variables may be useless.","title":"Sensor variables"},{"location":"refs/17-interaction/#time-variables","text":"Time variables reflects the date corresponding to the current mouse position for mouse events. For attribute based events, the time variables are set to the target object current time position. They are set to 0 for the other events. timeVar ComplexDiagram( Sequence (Choice (0, 'date', 'rdate'), Optional ( Sequence (':', NonTerminal('mapname'))), Optional ( '[n/d]'), Optional ( Sequence ('%', Choice (0, 'f', 'a')))) ).addTo() $date : denotes the object date corresponding to the mouse pointer position at the time of the event. It is optionally followed by a colon and the name of the mapping to be used to compute the date. The $date variable is replaced by its rational value (i.e. two integers values). The optional rational enclosed in brackets may be used to indicate a quantification: the date value is rounded to an integer count of the specified rational value. The optional %f may be used to get the date delivered as a float value. $rdate : is similar to $date but ignores the target current date: the date is relative to the object mapping only. %f or %a : request the date value as a float value or as an absolute time value. Absolute time is expressed in seconds, assuming a tempo value of 60 bpm. Actually, $date%a = $date%f / 4 Note: A variable can be used several times in a message, but several $date variables must always refer to the same mapping. Example Sending the current date as a float value to an external application: /ITL/scene/myObject watch mouseDown ( targetHost:12000/date '$date%f' );","title":"Time variables"},{"location":"refs/17-interaction/#miscellaneous-variables","text":"variable ComplexDiagram( Choice (0, 'name', 'scene', 'address') ).addTo() $name is replaced by the target object name. $scene is replaced by the target object scene name. $address is replaced by the target object OSC address. Note: For the newElement event, the target object is the new element. Example Using an object name: /ITL/scene watch newElement (/ITL/scene/welcome set txt \"Welcome\" '$name');","title":"Miscellaneous variables"},{"location":"refs/17-interaction/#message-based-variables","text":"A message based variable is a variable containing an OSC message which will be evaluated at the time of the event. They are supported by all kind of events. Like the variables above, a message based variable starts with a '$' sign followed by a valid 'get' message enclosed in parenthesis: msgVar ComplexDiagram( Sequence ('(', NonTerminal('oscaddress'), 'get', Optional ( NonTerminal('params')), ')') ).addTo() The evaluation of a 'get' message produces a message or a list of messages. The message based variable will be replaced by the parameters of the messages resulting from the evaluation of the 'get' message. Note that all the 'get' messages attached to an event are evaluated at the same time. Example An object that takes the x position of another object on mouse down: /ITL/scene/myObject watch mouseDown (/ITL/scene/myObject x '$(/ITL/scene/obj get x)');","title":"Message based variables"},{"location":"refs/17-interaction/#variables-for-user-defined-events","text":"Messages associated to user defined events accept any number of a variables which names are $1, ... $i and which values are taken from the event call arguments. These events may be viewed as functions with arbitrary parameters; however parameters count and type is not checked: arguments in excess are ignored and variables without corresponding argument (e.g. $3 when only 2 arguments are available) are left unexpanded.","title":"Variables for user defined events"},{"location":"refs/17-interaction/#osc-address-variables","text":"The OSC address of a message associated to an event supports the following variables: $self : replaced by the object name. $scene : replaced by the scene name. Example Requesting a set of objects to send a message to themselves on a mouse event: /ITL/scene/* watch mouseDown # request all the objects of the scene (/ITL/scene/$self x '$sx'); # to send a message to themselves","title":"OSC address variables"},{"location":"refs/17-interaction/#interaction-state-management","text":"For a given object, its interaction state (i.e. the watched events and the associated messages) can be saved and restored. stateMsg ComplexDiagram( Choice (0, 'push', 'pop') ).addTo() Interaction states are managed using a stack where the states are pushed to or popped from. push : push the current interaction state on top of the stack. pop : replace the current interaction state with the one popped from the top of the stack. The different states stored in this stack can be obtain with the message : stackMsg ComplexDiagram( Sequence ('get', 'stack') ).addTo() Note: The effect of a pop message addressed to an object with an empty stack is to clear the object current interaction state.","title":"Interaction state management"},{"location":"refs/17-interaction/#file-watcher","text":"The fileWatcher is a static node of a scene that is intended to watch file modifications. It receives messages at the address /ITL/scene/fileWatcher . The fileWatcher support the watch and watch+ messages as described in section interaction with a file name used in place of the what parameter. fileWatcher ComplexDiagram( Sequence (Choice (0, 'watch', 'watch+'), Optional ( Sequence (NonTerminal('filePath'), Optional ( OneOrMore (NonTerminal('message'), \",\"))))) ).addTo() Example Reload an INScore script on file modification: /ITL/scene/fileWatcher watch 'myScript.inscore' ( /ITL/scene load 'myScript.inscore' ); Note: Some text editors delete the target file before saving. In this case, it breaks the file watching system and thus, it doesn't work as expected.","title":"File watcher"},{"location":"refs/18-scoreExpr/","text":"Score expressions Score expressions allows to defines score objects ( gmn or pianoroll ) by dynamically combine various resources using a formal expression. To define such object one should use the basic set messages using a score expressions as arguments: Example The following example defines a gmn and a pianoroll object using score expressions, the meaning of the expression is explained further. /ITL/scene/score set gmn expr(seq [a] [b]); /ITL/scene/pianoroll set pianoroll expr(score); General Syntax A score expression always starts with expr( and ends with ) , then 2 syntaxes are handled: EvaluableExpression ComplexDiagram( Sequence ('expr', '(', Choice (0, Sequence (Comment ('1'), NonTerminal('operator'), NonTerminal('score'), NonTerminal('score')), Sequence (Comment ('2'), NonTerminal('score'))), ')') ).addTo() 1 : Define an expression as an operation combining two scores. operator is the name of the operation used to combine them (see Section~ operators for operators list), and score are the arguments passed to the operator (see Section~ arguments for arguments specification). 2 : Define on expression using a single score. This syntax is useful when defining an object as a dynamic copy of an other existing object or file. Each of these tokens can, of course, be separated by spaces, tabulations or carriage returns (allowing multiline expression definition). When defining an object using a score expressions, INScore will parse it, construct an internal representation and finally evaluate it, reducing the formal expressions to a valid GMN string. Example Creating a guido object by sequencing two guido string /ITL/scene/score set gmn expr( seq \"[c d e]\" \"[f g h]\"); is equivalent to /ITL/scene/score set gmn \"[c d e f g h]\"; Score Operators All the score operators of INScore make use of guido operators implemented in the GuidoAR library. operation arguments description seq s1 s2 puts the scores s1 and s2 in sequence par s1 s2 puts the scores s1 and s2 in parallel rpar s1 s2 puts the scores s1 and s2 in parallel, right aligned top s1 s2 takes the n first voices of s1 where n is s2 voices count bottom s1 s2 cut the n first voices of s1 where n is s2 voices count head s1 s2 takes the head of s1 up to s2 duration evhead s1 s2 takes the n first events of s1 where n is the event's count of s2 tail s1 s2 cut the beginning of s1 up to the duration of s2 evtail s1 s2 cut the n first events of s1 where n is the event's count of s2 transpose s1 s2 transposes s1 so its first note of its first voice match s2 one duration s1 s2 stretches s1 to the duration of s2 if not used carefully, this operator can output impossible to display rhythm pitch s1 s2 applies the pitches of s1 to s2 in a loop rhythm s1 s2 applies the rhythm of s1 to s2 in a loop Score Arguments The syntax for arguments is quite permissive and various resources can be used as arguments for score expressions. In any case, when evaluating the expression, all the arguments will be reduce to GMN string so they can then be processed by the operators. Argument ComplexDiagram( Choice (0, NonTerminal('GmnCode'), Sequence (Optional ( Choice (0, '&', '\\(\\sim\\)')), Choice (0, NonTerminal('filepath'), NonTerminal('ScoreObject'))), NonTerminal('EvaluableExpression')) ).addTo() Arguments specification \\subsubsection{Arguments specification} GmnCode are not evaluated, passed as they are to operators. Both GMN and MusicXML string are supported. filepath : on evaluation INScore read all the content of the file. Again, both GMN and MusicXML are supported. filepath handle absolute or relative path (from the scene rootPath) as well as url. ScoreObject : Gmn code can be retreive from existing score objects ( gmn or pianoroll ) simply refering to them using their identifier (using absolute or relative path). EvaluableExpression : an expression can also be used as an argument, thus simple operator can be combined together to create more complex ones. In that case the expr token can be omitted: parenthesis are sufficient. Arguments prefix \\subsubsection{Arguments prefix} & : When triggering the reevaluation of an expression (see Section exprCmd ) only the arguments prefixed with & are updated. ~ : before the first evaluation of a score expression, any ScoreObjects prefixed with a ~ shall be replaced by their own expression. In other words, score expressions containing ~ arguments will be expended with existing score expressions. This mechanism allows to compose not only scores and score expressions together. Example Defining /ITL/scene/score as a copy of /ITL/scene/simpleScore duplicated 4 times. /ITL/scene/simpleScore set gmn \"[e {c,g} |]\"; /ITL/scene/score set gmn expr( &simpleScore ); /ITL/scene/score set gmn expr( seq ~ score ~ score); /ITL/scene/score set gmn expr( par ~ score ~ score); /ITL/scene/score should look like: Querying for the expanded expression of /ITL/scene/score (see Section~ exprCmd ) should return: /ITL/scene/score expr expr( par ( seq &simpleScore &simpleScore ) ( seq &simpleScore &simpleScore ) ) Note: on arguments quoting Arguments using special characters (space, tabulation, parenthesis, braces...), should be simple or double quoted, otherwise quotes can be omitted. 'expr' commands ITLObject defined using an evaluable expression gain access to these specific commands: get expr : return the expression used to define the object (before the expansion of ~ arguments). get exprTree : return the expanded expression expr reeval : re-evaluate the expression, updating only the value of arguments prefixed with & . expr reset : re-evaluate the expression, updating the value of all arguments. expr renew : reapply the definition of the object (similar to send its set message again) Applied to an object which wasn't defined by an evaluable expression, all this commands will cause a bad argument error. The renew command reset the internal state of the evaluated variable, forcing the re-evaluation and update of every arguments in the expression. Be aware that the track of copy evaluated arguments is lost after the first evaluation, thus renewing an expression defined using copy evaluated arguments won't update these arguments to their targeted ITLObject expression. Though, static arguments added by the copy shall be renewed. newData event newData is triggered by any object when its value change (generally because of a set message). Neither trying to set an object to its actual value without changing its type, nor re-evaluating an object to its actual value will trigger newData. Of course, the newData event can be used together with reeval to automatically update an object when the value of an other changes. Example Creating a copy of score , and automatise its update when score is changed /ITL/scene/score set gmn \"[c e]\"; /ITL/scene/copy set gmn expr(&score); /ITL/scene/score watch newData (/ITL/scene/copy expr reeval); To avoid infinite loop when using recursion, newData event is delayed of one event loop, meaning that, in the previous example, during the event loop that follow score 's modification, score and copy are different ( copy has not been updated yet...). Note: Because newData event is delayed, if score experiences multiple modifications during the same event loop (because multiple set messages have been sent together), only his final value will be accessible when newData will be actually triggered, however the event will be sent as many times as score have been modified. Note: when automatizing update For the reasons raised in the previous note, one should be very careful to delayed update when automatise reeval with newData . Indeed, in some extreme case, executing a script one line after an other won't have the same result as executing the all script at once!! Example Creating a \"score buffer\", storing every state adopted by score /ITL/scene/score set gmn \"[c]\"; /ITL/scene/buffer set gmn \"[]\"; /ITL/scene/buffer set gmn expr(seq &buffer (seq \"[|]\" &score)); /ITL/scene/score watch newData (/ITL/scene/buffer expr reeval); /ITL/scene/score set gmn \"[e]\"; /ITL/scene/score set gmn \"[g]\"; /ITL/scene/score set gmn \"[{c,e,g}]\"; Won't have the same result if run line by line, or the all script as once: Line by line: All script lines at once: To avoid such undeterministic behaviour, one should, in this case, manually trigger reeval after each modification of score .","title":"Score Expressions"},{"location":"refs/18-scoreExpr/#score-expressions","text":"Score expressions allows to defines score objects ( gmn or pianoroll ) by dynamically combine various resources using a formal expression. To define such object one should use the basic set messages using a score expressions as arguments: Example The following example defines a gmn and a pianoroll object using score expressions, the meaning of the expression is explained further. /ITL/scene/score set gmn expr(seq [a] [b]); /ITL/scene/pianoroll set pianoroll expr(score);","title":"Score expressions"},{"location":"refs/18-scoreExpr/#general-syntax","text":"A score expression always starts with expr( and ends with ) , then 2 syntaxes are handled: EvaluableExpression ComplexDiagram( Sequence ('expr', '(', Choice (0, Sequence (Comment ('1'), NonTerminal('operator'), NonTerminal('score'), NonTerminal('score')), Sequence (Comment ('2'), NonTerminal('score'))), ')') ).addTo() 1 : Define an expression as an operation combining two scores. operator is the name of the operation used to combine them (see Section~ operators for operators list), and score are the arguments passed to the operator (see Section~ arguments for arguments specification). 2 : Define on expression using a single score. This syntax is useful when defining an object as a dynamic copy of an other existing object or file. Each of these tokens can, of course, be separated by spaces, tabulations or carriage returns (allowing multiline expression definition). When defining an object using a score expressions, INScore will parse it, construct an internal representation and finally evaluate it, reducing the formal expressions to a valid GMN string. Example Creating a guido object by sequencing two guido string /ITL/scene/score set gmn expr( seq \"[c d e]\" \"[f g h]\"); is equivalent to /ITL/scene/score set gmn \"[c d e f g h]\";","title":"General Syntax"},{"location":"refs/18-scoreExpr/#score-operators","text":"All the score operators of INScore make use of guido operators implemented in the GuidoAR library. operation arguments description seq s1 s2 puts the scores s1 and s2 in sequence par s1 s2 puts the scores s1 and s2 in parallel rpar s1 s2 puts the scores s1 and s2 in parallel, right aligned top s1 s2 takes the n first voices of s1 where n is s2 voices count bottom s1 s2 cut the n first voices of s1 where n is s2 voices count head s1 s2 takes the head of s1 up to s2 duration evhead s1 s2 takes the n first events of s1 where n is the event's count of s2 tail s1 s2 cut the beginning of s1 up to the duration of s2 evtail s1 s2 cut the n first events of s1 where n is the event's count of s2 transpose s1 s2 transposes s1 so its first note of its first voice match s2 one duration s1 s2 stretches s1 to the duration of s2 if not used carefully, this operator can output impossible to display rhythm pitch s1 s2 applies the pitches of s1 to s2 in a loop rhythm s1 s2 applies the rhythm of s1 to s2 in a loop","title":"Score Operators"},{"location":"refs/18-scoreExpr/#score-arguments","text":"The syntax for arguments is quite permissive and various resources can be used as arguments for score expressions. In any case, when evaluating the expression, all the arguments will be reduce to GMN string so they can then be processed by the operators. Argument ComplexDiagram( Choice (0, NonTerminal('GmnCode'), Sequence (Optional ( Choice (0, '&', '\\(\\sim\\)')), Choice (0, NonTerminal('filepath'), NonTerminal('ScoreObject'))), NonTerminal('EvaluableExpression')) ).addTo()","title":"Score Arguments"},{"location":"refs/18-scoreExpr/#arguments-specification","text":"\\subsubsection{Arguments specification} GmnCode are not evaluated, passed as they are to operators. Both GMN and MusicXML string are supported. filepath : on evaluation INScore read all the content of the file. Again, both GMN and MusicXML are supported. filepath handle absolute or relative path (from the scene rootPath) as well as url. ScoreObject : Gmn code can be retreive from existing score objects ( gmn or pianoroll ) simply refering to them using their identifier (using absolute or relative path). EvaluableExpression : an expression can also be used as an argument, thus simple operator can be combined together to create more complex ones. In that case the expr token can be omitted: parenthesis are sufficient.","title":"Arguments specification"},{"location":"refs/18-scoreExpr/#arguments-prefix","text":"\\subsubsection{Arguments prefix} & : When triggering the reevaluation of an expression (see Section exprCmd ) only the arguments prefixed with & are updated. ~ : before the first evaluation of a score expression, any ScoreObjects prefixed with a ~ shall be replaced by their own expression. In other words, score expressions containing ~ arguments will be expended with existing score expressions. This mechanism allows to compose not only scores and score expressions together. Example Defining /ITL/scene/score as a copy of /ITL/scene/simpleScore duplicated 4 times. /ITL/scene/simpleScore set gmn \"[e {c,g} |]\"; /ITL/scene/score set gmn expr( &simpleScore ); /ITL/scene/score set gmn expr( seq ~ score ~ score); /ITL/scene/score set gmn expr( par ~ score ~ score); /ITL/scene/score should look like: Querying for the expanded expression of /ITL/scene/score (see Section~ exprCmd ) should return: /ITL/scene/score expr expr( par ( seq &simpleScore &simpleScore ) ( seq &simpleScore &simpleScore ) ) Note: on arguments quoting Arguments using special characters (space, tabulation, parenthesis, braces...), should be simple or double quoted, otherwise quotes can be omitted.","title":"Arguments prefix"},{"location":"refs/18-scoreExpr/#expr-commands","text":"ITLObject defined using an evaluable expression gain access to these specific commands: get expr : return the expression used to define the object (before the expansion of ~ arguments). get exprTree : return the expanded expression expr reeval : re-evaluate the expression, updating only the value of arguments prefixed with & . expr reset : re-evaluate the expression, updating the value of all arguments. expr renew : reapply the definition of the object (similar to send its set message again) Applied to an object which wasn't defined by an evaluable expression, all this commands will cause a bad argument error. The renew command reset the internal state of the evaluated variable, forcing the re-evaluation and update of every arguments in the expression. Be aware that the track of copy evaluated arguments is lost after the first evaluation, thus renewing an expression defined using copy evaluated arguments won't update these arguments to their targeted ITLObject expression. Though, static arguments added by the copy shall be renewed.","title":"'expr' commands"},{"location":"refs/18-scoreExpr/#newdata-event","text":"newData is triggered by any object when its value change (generally because of a set message). Neither trying to set an object to its actual value without changing its type, nor re-evaluating an object to its actual value will trigger newData. Of course, the newData event can be used together with reeval to automatically update an object when the value of an other changes. Example Creating a copy of score , and automatise its update when score is changed /ITL/scene/score set gmn \"[c e]\"; /ITL/scene/copy set gmn expr(&score); /ITL/scene/score watch newData (/ITL/scene/copy expr reeval); To avoid infinite loop when using recursion, newData event is delayed of one event loop, meaning that, in the previous example, during the event loop that follow score 's modification, score and copy are different ( copy has not been updated yet...). Note: Because newData event is delayed, if score experiences multiple modifications during the same event loop (because multiple set messages have been sent together), only his final value will be accessible when newData will be actually triggered, however the event will be sent as many times as score have been modified. Note: when automatizing update For the reasons raised in the previous note, one should be very careful to delayed update when automatise reeval with newData . Indeed, in some extreme case, executing a script one line after an other won't have the same result as executing the all script at once!! Example Creating a \"score buffer\", storing every state adopted by score /ITL/scene/score set gmn \"[c]\"; /ITL/scene/buffer set gmn \"[]\"; /ITL/scene/buffer set gmn expr(seq &buffer (seq \"[|]\" &score)); /ITL/scene/score watch newData (/ITL/scene/buffer expr reeval); /ITL/scene/score set gmn \"[e]\"; /ITL/scene/score set gmn \"[g]\"; /ITL/scene/score set gmn \"[{c,e,g}]\"; Won't have the same result if run line by line, or the all script as once: Line by line: All script lines at once: To avoid such undeterministic behaviour, one should, in this case, manually trigger reeval after each modification of score .","title":"newData event"},{"location":"refs/19-plugins/","text":"Plugins A plugin is an external library that is dynamically loaded when an object that need it is created. The system looks for plugins in the following locations: in the current folder first in the PlugIns folder, located in the application bundle on macos, in the application folder on other systems in the system default locations for shared libraries Additionaly, a user path can be set, where the system will look for plugins in first position. See section ITLplugins . The plugins are shared libraries which extension is platform dependent. The plugin name should not include the extension. The expected extensions are the following: .dylib on MacOS and Linux, .dll on Windows. FAUST plugins FAUST [Functional Audio Stream] is a functional programming language specifically designed for real-time signal processing and synthesis. A FAUST/INScore architecture allows to embed FAUST processors in INScore, for the purpose of signals computation. A FAUST plugin is viewed as a parallel signal and thus it is created in the signal address space. Similarly to signals, it is associated to an OSC address in the form /ITL/ scene /signal/\\emph{name } where name is a user defined name. Set Message There are two ways to create a FAUST Processor : [1]- By charging a DSP as a plugin already compiled faustprocessor ComplexDiagram( Sequence ('set', 'faust', NonTerminal('path')) ).addTo() Example /ITL/scene/signal/myFaust set faust aFaustPlugin; Note: The plugin name should not include the extension. The expected extensions are the following: .dylib on MacOS and Linux, .dll on Windows. [2]- By charging libfaust as a plugin to compile a DSP on-the-fly (as a string or a file). faustdsp ComplexDiagram( Sequence ('set', 'faustdsp', NonTerminal('faustcode')) ).addTo() \\vspace{0.3cm} faustdspfile ComplexDiagram( Sequence ('set', 'faustdspf', NonTerminal('faustfile')) ).addTo() Example /ITL/scene/signal/plus set faustdsp \"process=+;\"; /ITL/scene/signal/mydsp set faustdspf \"mydsp.dsp\"; Specific messages A FAUST processor is characterized by the numbers of input and output channels and by a set of parameters. Each parameter carries a name defined by the FAUST processor. The set of messages supported by a FAUST processor is the set of signals messages extended with the parameters names and with specific query messages. faustmessage ComplexDiagram( Choice (0, NonTerminal('signalMsgs'), Sequence (Comment ('1'), 'msg', NonTerminal('float32')), Sequence (Comment ('2'), 'get', Choice (0, 'in', 'out'))) ).addTo() [1] msg is any of the FAUST processor parameters, which are defined by the FAUST processor. [2] the get message is extended to query the FAUST processor: in and out give the number of input and output channels. Example Querying a FAUST processor input and output count: /ITL/scene/signal/myFaust get in out; gives as output: /ITL/scene/signal/myFaust in 2; /ITL/scene/signal/myFaust out 4; Modifying the value of a FAUST processor parameter named volume : /ITL/scene/signal/myFaust volume 0.8 Feeding and composing FAUST processors A FAUST processor accepts float values as input, which are taken as interleaved data and distributed to the input channels. From composition viewpoint, a FAUST processor is a parallel signal which dimension is the number of output channels. Thus, a FAUST processor can be used like any parallel signal. However, the signal identifier defined in parcomp is extended to support adressing single components of parallel signal as follows: signal ComplexDiagram( Choice (0, Sequence (NonTerminal('identifier'), Optional ( Sequence (\"/\", NonTerminal('n')))), NonTerminal('float32')) ).addTo() where n selects the signal #n of a parallel signal. Note that indexes start at 0. Example Creating 3 parallel signals using the 3 output channels of a FAUST processor named myFaust : /ITL/scene/signal/y1 set 'myFaust/0' 0.01 0. 1. 1. 1. ; /ITL/scene/signal/y2 set 'myFaust/1' 0.01 0.5 1. 1. 1. ; /ITL/scene/signal/y3 set 'myFaust/2' 0.01 -0.5 1. 1. 1. ; Gesture Follower INScore supports gesture following using the technology developed by the IRCAM IMTR team. These features are available as a plugin that is included in the INScore distribution (version 1.03 or greater) or available from the IRCAM. Basic principle Gesture following is provided as a mean to interact with a score. From input viewpoint, the gesture follower is similar to signals (see section ssignal ): it accepts data stream as input both in learning and following modes. It implements a specific set of events related to gesture following and can generate message streams parametrized with the gesture follower current state. A gesture follower is setup to handle a given count of gestures, which are actually denoted by streams of float vectors. We'll refer to the size of the float vector as the gesture dimension . For example, the dimension of a gesture captured from x, y and z accelerometers is 3. A gesture follower operates in two distinct phases: a learning phase where it actually stores the gestures data, and a following phase where it tries to match incoming data to the stored gestures data. When not learning nor following, we'll talk of an idle phase. In the following phase , the system maintains a list of likelihood for the learned gestures, a list of positions in the gestures and a list of speeds representing how fast the gestures are made. Of course, the higher the likelihood, the more these data are meaningfull. It's the user responsability to decide on the meaningfull likelihood threshold value. Interaction events are triggered only in the following phase and for meaningfull likelihoods. Messages A gesture follower is created in a scene using the imtrgf type. It has a graphic appearance that may be used for debug purpose but it is hidden by default. gesturefollower ComplexDiagram( Sequence ('set', 'imtrgf', NonTerminal('gesturedimension'), NonTerminal('bufsize'), OneOrMore (NonTerminal('name'))) ).addTo() The parameters are: gesturedimension : the size of the gestures data vector. bufsize : the size of the gesture data storage. name : a list of names to be used to refer to the learned gestures. Note: A gesture follower is created with a fixed count of gestures that can be learned and decoded. These gestures are named gestures and can be addressed at /ITL/ scene /\\textit{myfollower / gesturename } where the part in italic are user defined names and where myfollower is a gesture follower. gesturefollowerMsgs ComplexDiagram( Choice (0, Sequence (Comment ('1'), OneOrMore (NonTerminal('float32'))), Sequence (Comment ('2'), Sequence ('learn', NonTerminal('name'))), Sequence (Comment ('3'), 'follow'), Sequence (Comment ('4'), 'stop'), Sequence (Comment ('5'), 'clear'), Sequence (Comment ('6'), Sequence ('likelihoodwindow', NonTerminal('float32'))), Sequence (Comment ('7'), Sequence ('tolerance', NonTerminal('float32')))) ).addTo() [1] input data into the gesture follower. The data are interpreted according to the current operating mode i.e. learning, following or idle. [2] starts to learn the gesture designated by name . Actually records the next input data to the gesture. [3] starts following i.e. trying to match the next input data to the recorded gestures. [4] stops learning or following. Actually puts the system in idle phase. [5] clear all the gestures data. This is equivalent to send the clear message to all the gestures. [6] sets the size of the window that contains the history of the likelihoods. May be viewed as how fast the likelihoods will change. [7] sets the follower tolerance. Example Creating a gesture follower for 3 dimensional data and a typical learning sequence: /ITL/scene/gf set imtrgf 3 1000 gestureA gestureB gestureC gestureD ; /ITL/scene/gf learn gestureA ; /ITL/scene/gf 0.1 0.5 -0.2 ... 0.7; # the data size must be a multiple of 3 /ITL/scene/gf stop; Gestures management Messages can also be sent to gestures i.e. to addresses in the form /ITL/ scene /\\textit{myfollower / gesturename } where myfollower is a gesture follower. A gesture could be in two states: an active state: when its likelihood is greater or equal to the likelihood threshold. an idle state: when its likelihood is lower than the likelihood threshold. gesture ComplexDiagram( Choice (0, Sequence ('set', OneOrMore (NonTerminal('float32'))), 'clear', 'learn', Sequence ('likelihoodThreshold', NonTerminal('float32'))) ).addTo() set : sets the gesture data. This is equivalent to learn the corresponding data. The set message could be used to restored previously saved gesture data. clear : clears the gesture data. learn : puts the gestures follower in learning mode and starts learning the corresponding gesture. This is equivalent to send OSC{learn gesturename } to the parent gesture follower. likelihoodThreshold : sets the gesture likelihood threshold. The parameter is a float value in the range [0,1] . Default value is 0.5 . Gestures supports also specific queries : gestureget ComplexDiagram( Sequence ('get', Optional ( Choice (0, 'likelihoodThreshold', 'size'))) ).addTo() get : without parameter, returns a set message when the gesture is not empty. size : gives the current size of the gesture, actually the number of recorded frames. Events and interaction Events are defined at gesture level and events management messages should be addressed to gestures. gestureevents ComplexDiagram( Sequence ('watch', Optional ( Choice (0, 'gfEnter', 'gfLeave', 'gfActive', 'gfIdle')), Optional ( NonTerminal('messages'))) ).addTo() gfEnter triggered when the gesture state changes from idle to active. gfLeave triggered when the gesture state changes from active to idle. gfActive triggered in active state each time the gesture likelihood is refreshed. gfIdle triggered in idle state each time the gesture likelihood is refreshed. A message associated to a gesture supports the following specific variables: gesturevariable ComplexDiagram( Sequence (Choice (0, 'gflikelihood', 'gfpos', 'gfspeed'), Optional ( '[low,high]')) ).addTo() These variables support the scaling feature associated to position variables and described in section posvar . gflikelihood indicates the current likelihood gfpos indicates the current position in the gesture gfspeed indicates the current gesture execution speed Note: Variables described in section interactvar may also be used but they are meaningless and contains default values. Gesture Follower Appearance A gesture follower object has a graphic appearance and supports all the standard objects properties, including mapping and synchronization. This graphic appearance is provided mainly for debug purpose and by default, the object is hidden. Figure fig:gfgraph shows the gesture follower appearance in its different phases: when idle, the upper part of the graphic indicates the buffer state of the different gestures. It also includes the gestures likelihood threshold. when learning, a red frame and a grey background indicates that a learning a gesture is currently in progress. The gesture buffer state is refreshed while learning. when following, the upper part indicates each gesture current likelihood and the lower part indicates the current estimated positions. The gesture follower appearance in its different phases. Httpd server plugin INScore can embed Http server to expose real time screenshot image of a scene to the web. This feature is based on libmicrohttpd and is available as a plugin that is included in the INScore distribution (version 1.11 or greater). The Url to get the image is the base url of the server. Set Message The http server object is created in a scene like other objects and served image of his scene. httpdserver ComplexDiagram( Sequence ('set', 'httpd', NonTerminal('port')) ).addTo() port http port used by the server. Example /ITL/scene/server set httpd 8000; Note: If the http port is already used, the server cannot start. Specific messages The http server status can be delivered with a specific message. httpdmessage ComplexDiagram( Sequence ('get', NonTerminal('status')) ).addTo() A string corresponding to the server status (\"started\" or \"stopped\") is return. Example /ITL/scene/server get status;","title":"Plugins"},{"location":"refs/19-plugins/#plugins","text":"A plugin is an external library that is dynamically loaded when an object that need it is created. The system looks for plugins in the following locations: in the current folder first in the PlugIns folder, located in the application bundle on macos, in the application folder on other systems in the system default locations for shared libraries Additionaly, a user path can be set, where the system will look for plugins in first position. See section ITLplugins . The plugins are shared libraries which extension is platform dependent. The plugin name should not include the extension. The expected extensions are the following: .dylib on MacOS and Linux, .dll on Windows.","title":"Plugins"},{"location":"refs/19-plugins/#faust-plugins","text":"FAUST [Functional Audio Stream] is a functional programming language specifically designed for real-time signal processing and synthesis. A FAUST/INScore architecture allows to embed FAUST processors in INScore, for the purpose of signals computation. A FAUST plugin is viewed as a parallel signal and thus it is created in the signal address space. Similarly to signals, it is associated to an OSC address in the form /ITL/ scene /signal/\\emph{name } where name is a user defined name.","title":"FAUST plugins"},{"location":"refs/19-plugins/#set-message","text":"There are two ways to create a FAUST Processor : [1]- By charging a DSP as a plugin already compiled faustprocessor ComplexDiagram( Sequence ('set', 'faust', NonTerminal('path')) ).addTo() Example /ITL/scene/signal/myFaust set faust aFaustPlugin; Note: The plugin name should not include the extension. The expected extensions are the following: .dylib on MacOS and Linux, .dll on Windows. [2]- By charging libfaust as a plugin to compile a DSP on-the-fly (as a string or a file). faustdsp ComplexDiagram( Sequence ('set', 'faustdsp', NonTerminal('faustcode')) ).addTo() \\vspace{0.3cm} faustdspfile ComplexDiagram( Sequence ('set', 'faustdspf', NonTerminal('faustfile')) ).addTo() Example /ITL/scene/signal/plus set faustdsp \"process=+;\"; /ITL/scene/signal/mydsp set faustdspf \"mydsp.dsp\";","title":"Set Message"},{"location":"refs/19-plugins/#specific-messages","text":"A FAUST processor is characterized by the numbers of input and output channels and by a set of parameters. Each parameter carries a name defined by the FAUST processor. The set of messages supported by a FAUST processor is the set of signals messages extended with the parameters names and with specific query messages. faustmessage ComplexDiagram( Choice (0, NonTerminal('signalMsgs'), Sequence (Comment ('1'), 'msg', NonTerminal('float32')), Sequence (Comment ('2'), 'get', Choice (0, 'in', 'out'))) ).addTo() [1] msg is any of the FAUST processor parameters, which are defined by the FAUST processor. [2] the get message is extended to query the FAUST processor: in and out give the number of input and output channels. Example Querying a FAUST processor input and output count: /ITL/scene/signal/myFaust get in out; gives as output: /ITL/scene/signal/myFaust in 2; /ITL/scene/signal/myFaust out 4; Modifying the value of a FAUST processor parameter named volume : /ITL/scene/signal/myFaust volume 0.8","title":"Specific messages"},{"location":"refs/19-plugins/#feeding-and-composing-faust-processors","text":"A FAUST processor accepts float values as input, which are taken as interleaved data and distributed to the input channels. From composition viewpoint, a FAUST processor is a parallel signal which dimension is the number of output channels. Thus, a FAUST processor can be used like any parallel signal. However, the signal identifier defined in parcomp is extended to support adressing single components of parallel signal as follows: signal ComplexDiagram( Choice (0, Sequence (NonTerminal('identifier'), Optional ( Sequence (\"/\", NonTerminal('n')))), NonTerminal('float32')) ).addTo() where n selects the signal #n of a parallel signal. Note that indexes start at 0. Example Creating 3 parallel signals using the 3 output channels of a FAUST processor named myFaust : /ITL/scene/signal/y1 set 'myFaust/0' 0.01 0. 1. 1. 1. ; /ITL/scene/signal/y2 set 'myFaust/1' 0.01 0.5 1. 1. 1. ; /ITL/scene/signal/y3 set 'myFaust/2' 0.01 -0.5 1. 1. 1. ;","title":"Feeding and composing FAUST processors"},{"location":"refs/19-plugins/#gesture-follower","text":"INScore supports gesture following using the technology developed by the IRCAM IMTR team. These features are available as a plugin that is included in the INScore distribution (version 1.03 or greater) or available from the IRCAM.","title":"Gesture Follower"},{"location":"refs/19-plugins/#basic-principle","text":"Gesture following is provided as a mean to interact with a score. From input viewpoint, the gesture follower is similar to signals (see section ssignal ): it accepts data stream as input both in learning and following modes. It implements a specific set of events related to gesture following and can generate message streams parametrized with the gesture follower current state. A gesture follower is setup to handle a given count of gestures, which are actually denoted by streams of float vectors. We'll refer to the size of the float vector as the gesture dimension . For example, the dimension of a gesture captured from x, y and z accelerometers is 3. A gesture follower operates in two distinct phases: a learning phase where it actually stores the gestures data, and a following phase where it tries to match incoming data to the stored gestures data. When not learning nor following, we'll talk of an idle phase. In the following phase , the system maintains a list of likelihood for the learned gestures, a list of positions in the gestures and a list of speeds representing how fast the gestures are made. Of course, the higher the likelihood, the more these data are meaningfull. It's the user responsability to decide on the meaningfull likelihood threshold value. Interaction events are triggered only in the following phase and for meaningfull likelihoods.","title":"Basic principle"},{"location":"refs/19-plugins/#messages","text":"A gesture follower is created in a scene using the imtrgf type. It has a graphic appearance that may be used for debug purpose but it is hidden by default. gesturefollower ComplexDiagram( Sequence ('set', 'imtrgf', NonTerminal('gesturedimension'), NonTerminal('bufsize'), OneOrMore (NonTerminal('name'))) ).addTo() The parameters are: gesturedimension : the size of the gestures data vector. bufsize : the size of the gesture data storage. name : a list of names to be used to refer to the learned gestures. Note: A gesture follower is created with a fixed count of gestures that can be learned and decoded. These gestures are named gestures and can be addressed at /ITL/ scene /\\textit{myfollower / gesturename } where the part in italic are user defined names and where myfollower is a gesture follower. gesturefollowerMsgs ComplexDiagram( Choice (0, Sequence (Comment ('1'), OneOrMore (NonTerminal('float32'))), Sequence (Comment ('2'), Sequence ('learn', NonTerminal('name'))), Sequence (Comment ('3'), 'follow'), Sequence (Comment ('4'), 'stop'), Sequence (Comment ('5'), 'clear'), Sequence (Comment ('6'), Sequence ('likelihoodwindow', NonTerminal('float32'))), Sequence (Comment ('7'), Sequence ('tolerance', NonTerminal('float32')))) ).addTo() [1] input data into the gesture follower. The data are interpreted according to the current operating mode i.e. learning, following or idle. [2] starts to learn the gesture designated by name . Actually records the next input data to the gesture. [3] starts following i.e. trying to match the next input data to the recorded gestures. [4] stops learning or following. Actually puts the system in idle phase. [5] clear all the gestures data. This is equivalent to send the clear message to all the gestures. [6] sets the size of the window that contains the history of the likelihoods. May be viewed as how fast the likelihoods will change. [7] sets the follower tolerance. Example Creating a gesture follower for 3 dimensional data and a typical learning sequence: /ITL/scene/gf set imtrgf 3 1000 gestureA gestureB gestureC gestureD ; /ITL/scene/gf learn gestureA ; /ITL/scene/gf 0.1 0.5 -0.2 ... 0.7; # the data size must be a multiple of 3 /ITL/scene/gf stop;","title":"Messages"},{"location":"refs/19-plugins/#gestures-management","text":"Messages can also be sent to gestures i.e. to addresses in the form /ITL/ scene /\\textit{myfollower / gesturename } where myfollower is a gesture follower. A gesture could be in two states: an active state: when its likelihood is greater or equal to the likelihood threshold. an idle state: when its likelihood is lower than the likelihood threshold. gesture ComplexDiagram( Choice (0, Sequence ('set', OneOrMore (NonTerminal('float32'))), 'clear', 'learn', Sequence ('likelihoodThreshold', NonTerminal('float32'))) ).addTo() set : sets the gesture data. This is equivalent to learn the corresponding data. The set message could be used to restored previously saved gesture data. clear : clears the gesture data. learn : puts the gestures follower in learning mode and starts learning the corresponding gesture. This is equivalent to send OSC{learn gesturename } to the parent gesture follower. likelihoodThreshold : sets the gesture likelihood threshold. The parameter is a float value in the range [0,1] . Default value is 0.5 . Gestures supports also specific queries : gestureget ComplexDiagram( Sequence ('get', Optional ( Choice (0, 'likelihoodThreshold', 'size'))) ).addTo() get : without parameter, returns a set message when the gesture is not empty. size : gives the current size of the gesture, actually the number of recorded frames.","title":"Gestures management"},{"location":"refs/19-plugins/#events-and-interaction","text":"Events are defined at gesture level and events management messages should be addressed to gestures. gestureevents ComplexDiagram( Sequence ('watch', Optional ( Choice (0, 'gfEnter', 'gfLeave', 'gfActive', 'gfIdle')), Optional ( NonTerminal('messages'))) ).addTo() gfEnter triggered when the gesture state changes from idle to active. gfLeave triggered when the gesture state changes from active to idle. gfActive triggered in active state each time the gesture likelihood is refreshed. gfIdle triggered in idle state each time the gesture likelihood is refreshed. A message associated to a gesture supports the following specific variables: gesturevariable ComplexDiagram( Sequence (Choice (0, 'gflikelihood', 'gfpos', 'gfspeed'), Optional ( '[low,high]')) ).addTo() These variables support the scaling feature associated to position variables and described in section posvar . gflikelihood indicates the current likelihood gfpos indicates the current position in the gesture gfspeed indicates the current gesture execution speed Note: Variables described in section interactvar may also be used but they are meaningless and contains default values.","title":"Events and interaction"},{"location":"refs/19-plugins/#gesture-follower-appearance","text":"A gesture follower object has a graphic appearance and supports all the standard objects properties, including mapping and synchronization. This graphic appearance is provided mainly for debug purpose and by default, the object is hidden. Figure fig:gfgraph shows the gesture follower appearance in its different phases: when idle, the upper part of the graphic indicates the buffer state of the different gestures. It also includes the gestures likelihood threshold. when learning, a red frame and a grey background indicates that a learning a gesture is currently in progress. The gesture buffer state is refreshed while learning. when following, the upper part indicates each gesture current likelihood and the lower part indicates the current estimated positions. The gesture follower appearance in its different phases.","title":"Gesture Follower Appearance"},{"location":"refs/19-plugins/#httpd-server-plugin","text":"INScore can embed Http server to expose real time screenshot image of a scene to the web. This feature is based on libmicrohttpd and is available as a plugin that is included in the INScore distribution (version 1.11 or greater). The Url to get the image is the base url of the server.","title":"Httpd server plugin"},{"location":"refs/19-plugins/#set-message_1","text":"The http server object is created in a scene like other objects and served image of his scene. httpdserver ComplexDiagram( Sequence ('set', 'httpd', NonTerminal('port')) ).addTo() port http port used by the server. Example /ITL/scene/server set httpd 8000; Note: If the http port is already used, the server cannot start.","title":"Set Message"},{"location":"refs/19-plugins/#specific-messages_1","text":"The http server status can be delivered with a specific message. httpdmessage ComplexDiagram( Sequence ('get', NonTerminal('status')) ).addTo() A string corresponding to the server status (\"started\" or \"stopped\") is return. Example /ITL/scene/server get status;","title":"Specific messages"},{"location":"refs/2-genformat/","text":"General format An OSC message is made of an OSC address, followed by a message string, followed by zero to n parameters. The message string could be viewed as the method name of the object identified by the OSC address. The OSC address could be string or a regular expression matching several objects. OSCMessage ComplexDiagram( Sequence (NonTerminal('OSCAddress'), NonTerminal('message'), Optional (NonTerminal('parameters')) ) ).addTo() Example Sending the message x to the object which address is /ITL/scene/score with 0.5 as parameter. /ITL/scene/score x 0.5; The address is similar to a Unix path and supports regular expressions as defined by the OSC specification . This address scheme is extended to address any host and applications (see section interaction ). Note: A valid legal OSC address always starts with /ITL that is the application address and that is also used as a discriminant for incoming messages. OSCAddress ComplexDiagram( Sequence ('/', OneOrMore (Choice (0, NonTerminal('identifier'), NonTerminal('regexp')))) ).addTo() Identifiers may include letters, hyphen, underscore and numbers (apart at first position for the latter). identifier ComplexDiagram( Sequence ('[-_a-zA-Z]', OneOrMore ('[-_a-zA-Z0-9]]')) ).addTo() Some specific nodes (like signals - see section ssignal ) accept OSC messages without message string: SigOSCMessage ComplexDiagram( Sequence (NonTerminal('OSCAddress'), NonTerminal('parameters')) ).addTo() Parameters Message parameters types are the OSC types int32 , float32 and OSC-string . In the remainder of this document, they are used as terminal symbols, denoted by int32 , float32 and string . When used in a script file, string should be single or double quoted when they include characters not allowed in identifiers (space, punctuation marks, etc.). If an ambiguous double or single quote is part of the string, it can be escaped using a '\\'. Parameters types policy is relaxed: the system makes its best to convert a parameter to the expected type, which depend on the message string. With an incorrect type and when no conversion is applied, an incorrect parameter message error is triggered. The system is strict regarding the number of expected parameters. Address space The OSC address space is made of static and dynamic nodes, hierarchically organized as in figure fig:addrspace : The OSC address space. Nodes in italic/blue are dynamic nodes. OSC messages are accepted at any level of the hierarchy: the application level responds to messages for application management (udp ports management, loading files, query messages). the scene level contains scores that are associated to a window and respond to specific scene management messages. It includes a static node named stats that collects information about incoming messages, a static log node that control an embedded log window. the component level contains the score components and 3 static nodes: a signal node that may be viewed as a folder containing signals a sync node, in charge of the synchronization messages a javascript node, that may be adressed to run javascript code dynamically. Each component includes a static node named debug that provides debugging information. - the signals level contains signals i.e. objects that accept data streams and that may be graphically rendered as a scene component (see Signals and Graphic signals section graphsig ). Note: Since version 1.05, each component of a score may also be a container and thus, the hierarchy described above has a potential infinite depth level. Note also that a sync node is present at each level. Aliases An alias mechanism allows an arbitrary OSC address to be used in place of a real address. An alias message is provided to describe aliases: alias ComplexDiagram( Sequence (NonTerminal('OSCAddress'), 'alias', Choice (0, Sequence (Comment ('1'), NonTerminal('OSCAlias'), Optional (OneOrMore (Sequence (NonTerminal('message'), Optional ('[n,m]') ))) ), Comment ('2'))) ).addTo() [1] sets OSCAlias as an alias of OSCAddress . The alias may be optionally followed by message strings which are then taken as implied messages. These messages can also be optionally followed by a scaling specification. [2] removes OSCAddress aliases. Note: Regular expressions are not supported by the alias mechanism and could lead to unpredictable results. Example # makes the address /ITL/scene/myobject available using /1/fader1 /ITL/scene/myobject alias '/1/fader1'; # the following input message: /1/fader1 0.5; # will be translated into: /ITL/scene/myobject 0.5; # create an alias with an implicit 'x' message /ITL/scene/myobject alias '/1/fader1' x; # the following input message: /1/fader1 0.5; # will be translated into: /ITL/scene/myobject x 0.5; Scaling In INScore, the parameter values are generally in the range [-1, 1]. However, some devices can generate messages with their own values range (e. g. accelerometers). An optional scaling string allows to convert any input range into the [-1, 1] range. The general form of the scaling string is [n,m] , where n and m are 2 numbers describing the minimum and maximum input values. Any input value v is then transformed into a value v' such that: v' = 2 (v-n)/(n-m) - 1 Example # create an alias with an implicit 'x' message using a scaling specification /ITL/scene/myobject alias '/1/fader1' x[0,100]; # the following input message: /1/fader1 5; # will be translated into: /ITL/scene/myobject x -0.9; Using more than one implicit message You can use an arbitrary number of message strings in an alias message. In any case, an input message with the corresponding values is expected. For example, when the alias message has 3 messages strings, input messages are expected to have 3 associated values. These values are distributed in sequence with each message string, which also means that the input message is translated into 3 different messages. Example # create an alias with implicit 'x' 'y' and 'angle' messages using scaling /ITL/scene/myobject alias '/1/fader1' x[0,100] y[0,100] angle; # the following input message: /1/fader1 5 60 12; # will be translated into: /ITL/scene/myobject x -0.9; /ITL/scene/myobject y 0.2; /ITL/scene/myobject angle 12;","title":"Format of a message"},{"location":"refs/2-genformat/#general-format","text":"An OSC message is made of an OSC address, followed by a message string, followed by zero to n parameters. The message string could be viewed as the method name of the object identified by the OSC address. The OSC address could be string or a regular expression matching several objects. OSCMessage ComplexDiagram( Sequence (NonTerminal('OSCAddress'), NonTerminal('message'), Optional (NonTerminal('parameters')) ) ).addTo() Example Sending the message x to the object which address is /ITL/scene/score with 0.5 as parameter. /ITL/scene/score x 0.5; The address is similar to a Unix path and supports regular expressions as defined by the OSC specification . This address scheme is extended to address any host and applications (see section interaction ). Note: A valid legal OSC address always starts with /ITL that is the application address and that is also used as a discriminant for incoming messages. OSCAddress ComplexDiagram( Sequence ('/', OneOrMore (Choice (0, NonTerminal('identifier'), NonTerminal('regexp')))) ).addTo() Identifiers may include letters, hyphen, underscore and numbers (apart at first position for the latter). identifier ComplexDiagram( Sequence ('[-_a-zA-Z]', OneOrMore ('[-_a-zA-Z0-9]]')) ).addTo() Some specific nodes (like signals - see section ssignal ) accept OSC messages without message string: SigOSCMessage ComplexDiagram( Sequence (NonTerminal('OSCAddress'), NonTerminal('parameters')) ).addTo()","title":"General format"},{"location":"refs/2-genformat/#parameters","text":"Message parameters types are the OSC types int32 , float32 and OSC-string . In the remainder of this document, they are used as terminal symbols, denoted by int32 , float32 and string . When used in a script file, string should be single or double quoted when they include characters not allowed in identifiers (space, punctuation marks, etc.). If an ambiguous double or single quote is part of the string, it can be escaped using a '\\'. Parameters types policy is relaxed: the system makes its best to convert a parameter to the expected type, which depend on the message string. With an incorrect type and when no conversion is applied, an incorrect parameter message error is triggered. The system is strict regarding the number of expected parameters.","title":"Parameters"},{"location":"refs/2-genformat/#address-space","text":"The OSC address space is made of static and dynamic nodes, hierarchically organized as in figure fig:addrspace : The OSC address space. Nodes in italic/blue are dynamic nodes. OSC messages are accepted at any level of the hierarchy: the application level responds to messages for application management (udp ports management, loading files, query messages). the scene level contains scores that are associated to a window and respond to specific scene management messages. It includes a static node named stats that collects information about incoming messages, a static log node that control an embedded log window. the component level contains the score components and 3 static nodes: a signal node that may be viewed as a folder containing signals a sync node, in charge of the synchronization messages a javascript node, that may be adressed to run javascript code dynamically. Each component includes a static node named debug that provides debugging information. - the signals level contains signals i.e. objects that accept data streams and that may be graphically rendered as a scene component (see Signals and Graphic signals section graphsig ). Note: Since version 1.05, each component of a score may also be a container and thus, the hierarchy described above has a potential infinite depth level. Note also that a sync node is present at each level.","title":"Address space"},{"location":"refs/2-genformat/#aliases","text":"An alias mechanism allows an arbitrary OSC address to be used in place of a real address. An alias message is provided to describe aliases: alias ComplexDiagram( Sequence (NonTerminal('OSCAddress'), 'alias', Choice (0, Sequence (Comment ('1'), NonTerminal('OSCAlias'), Optional (OneOrMore (Sequence (NonTerminal('message'), Optional ('[n,m]') ))) ), Comment ('2'))) ).addTo() [1] sets OSCAlias as an alias of OSCAddress . The alias may be optionally followed by message strings which are then taken as implied messages. These messages can also be optionally followed by a scaling specification. [2] removes OSCAddress aliases. Note: Regular expressions are not supported by the alias mechanism and could lead to unpredictable results. Example # makes the address /ITL/scene/myobject available using /1/fader1 /ITL/scene/myobject alias '/1/fader1'; # the following input message: /1/fader1 0.5; # will be translated into: /ITL/scene/myobject 0.5; # create an alias with an implicit 'x' message /ITL/scene/myobject alias '/1/fader1' x; # the following input message: /1/fader1 0.5; # will be translated into: /ITL/scene/myobject x 0.5;","title":"Aliases"},{"location":"refs/2-genformat/#scaling","text":"In INScore, the parameter values are generally in the range [-1, 1]. However, some devices can generate messages with their own values range (e. g. accelerometers). An optional scaling string allows to convert any input range into the [-1, 1] range. The general form of the scaling string is [n,m] , where n and m are 2 numbers describing the minimum and maximum input values. Any input value v is then transformed into a value v' such that: v' = 2 (v-n)/(n-m) - 1 Example # create an alias with an implicit 'x' message using a scaling specification /ITL/scene/myobject alias '/1/fader1' x[0,100]; # the following input message: /1/fader1 5; # will be translated into: /ITL/scene/myobject x -0.9;","title":"Scaling"},{"location":"refs/2-genformat/#using-more-than-one-implicit-message","text":"You can use an arbitrary number of message strings in an alias message. In any case, an input message with the corresponding values is expected. For example, when the alias message has 3 messages strings, input messages are expected to have 3 associated values. These values are distributed in sequence with each message string, which also means that the input message is translated into 3 different messages. Example # create an alias with implicit 'x' 'y' and 'angle' messages using scaling /ITL/scene/myobject alias '/1/fader1' x[0,100] y[0,100] angle; # the following input message: /1/fader1 5 60 12; # will be translated into: /ITL/scene/myobject x -0.9; /ITL/scene/myobject y 0.2; /ITL/scene/myobject angle 12;","title":"Using more than one implicit message"},{"location":"refs/20-changes/","text":"Changes list Version 1.34 vs version 1.31 new scount query at application level ( /ITL ): gives the scenes count. See section ITLQuery new scenes message at application level ( /ITL ). See section applmgmt new errorAddress message at application level ( /ITL ): set the OSC address of error messages. See section applmgmt forward message behavior change: append addresses to destination list, broadcast addresses are explicitly rejected and trigger an error. extend newElement event to application level ( /ITL ). See section typespecevents add support for get 'date%a' query: gives the absolute date in seconds (assumes the tempo is 60 bpm). add event handlers portrait and landscape for screen orientation change (triggered only by the web version) supports dynamic scene relative dimensions and positions. See section srelpos and whcontrol add IP query to application level ( /ITL ). See section ITLQuery add text query to txt objects. allows negative date messages. fix evaluation of args variables ( 1... n) in javascript run method. fix crash bug with OSC bundles. Web Specific Changes new init message for audioInput objects, must be called before using the audio input. new autoOff message supported by faust objects to automatically set ui buttons to 0 after a 1 value. support portrait and landscape events. prevent default keydown event on window (avoid scrolling). fix media end event. fix concurrent faustw objects creation. Version 1.31 vs version 1.28 add support for get 'date%f' query add midi node at application level, supported by the native app for compatibility reasons (works only with the web version) new keyDown and keyUp events. See section keyevents fix $date quantification fix 'event' messages forwarding fix $date%f detection in javascript run method fix non visible mapping for images fix incorrect $x et $y variables value for proportional dimension objects fix missing curve rendering fix guido score scaling issue Web Specific Changes new 'compute' message supported by faust objects new form of the 'connect' message (to address individual channels) font size unit changed to 'vw' (relative to viewport width) load message implemented new faustw object (precompiled faust dsp) new midi events Version 1.28 vs version 1.27 new dvolume method for media objects new ssl static application node for ssl certificates management new cert key cacert messages to manage ssl certificates and keys. See section SSL new get clients messages at application level add https support to forwarding mechanism. See section Forwarding Web Specific Changes fix ready event for audio objects Version 1.27 vs version 1.24 Web Specific Changes new faust object (web version) new connect method (web version) forwarding mechanism extended with http and ws support. See section Forwarding Version 1.24 vs version 1.22 new inscore2 scripting language log window supports the scale message. See section ITLlog colors: supports html color names and hex values with 0x as prefix. See section colormsg supports absolute time segments in mappings. See section segdefs tempo is now a floating point value fix touch events with edit dialog add 'inscore2' extension to files filter (mobile version) update to guido engine 1.66 edit message supports set as argument. See section editmsg edit new reset argument to clear the edit string in the object cache. See section editmsg new dshear method. See section transform fix bug with javascript runtime variable (passed as argument to run) fix synchronization issue with arcs (not visible when synchronized) fix crash bug with set messages addressed to /ITL/*/anobject Version 1.22 vs version 1.21 new opengl message supported at scene level for optional OpenGl graphics rendering. Improves significantly the cpu use for graphics operations but at the cost of poorer rendering for text and symbolic scores fix potential issue with dates: dates expressed with big values for the numerator or the denominator may result in overflow Version 1.21 vs version 1.18 new set of sensor objects. See section sensors . update to guido engine 1.63 new preprocess message supported at application and scene level intended to debug javascript sections or math expressions. Output of pre-processing is printed to the log window. See section applmgmt and scene . environement variables introduced in scripting environment (OSName and OSId). See INScoreLang documentation. new math expressions introduced in scripting context. See INScoreLang documentation. new syncFrame synchronisation mode. See section syncPos and syncFrame . the events system has been extended to any object attribute and supports user defined events. This change comes also with a one tick delay introduced to handle all the events (i.e. the event associated messages are processed by the next time task): this is intended to avoid freezing the system in case of loops. See section attributeevents and userevents . lua support has been dropped (compilation was optional, never embedded into a distribution) parser strategy changed: now each message is processed one by one to ensure the system consistency, especially for message based variables: an object state remains now consistent from one message to another. new arc object. See section vgraphscore and arcobjects . new radius message supported by rectangles. See section rectobjects . new edit message supported by all objects: opens a small messages editor. See section editmsg . new level message supported by the log window and extended debugging support. See section ITLlog . new video specific messages and management: the video time is now independent from the inscore object time. See section video . gmn objects set : output correct error message in case of syntax error save msg output changed: a scene emit the new message, static info nodes (log, stat, javascript...) bug in debug name corrected (was not removed from graphic space) bug in polygon and curve position corrected (was not centered on 0 0) - use /ITL compatibility to preserve previous behaviour crash bug corrected: occured when lauching inscore from a secondary screen new write message supported by text based objects. See section txtwrite . Version 1.18 vs version 1.17 new tempo message supported by all objects. See section tempo . new pageCount event supported by symbolic score objects. See section typespecevents . new error event supported at application level. See section typespecevents . new browse message at application level to open a document in a web browser. See section system . web api documentation included in package Version 1.17 vs version 1.15 support animated svg using the new animate message. See section svgobjects . messages list variables are exported to javascript as a string. Carlito Regular open source font is embedded in the application ressources and used as a default font. See at https://fontlibrary.org/fr/font/carlito for more information. symbolic notation support extended with score expressions. See section scoreExpr . new newData event. See section miscevents . the javascript engine is shared between the application and the different scenes. Note that it may change a script behavior when exploiting the previous independance of the javascript engine environments. new javascript osname function that gives the current operating system name. See INScoreLang documentation. new javascript osid function that gives the current operating system as an id. See INScoreLang documentation. rootPath message can be called without parameter to clear a scene rootPath. See section scene . log window supports the foreground message. See section ITLlog . user actions on windows are generating foreground messages. application quit when the last scene is closed (even when the log window is opened) new lock message supported by all objects to prevent an object deletion. See section common . OSC output buffer has been enlarged to 32768. Note that sending large messages works on localhost but are likely to face the MTU on real network. crash bug corrected: outgoing OSC messages are now handling buffer overflow exceptions. support for multi touch events. See section touchevents . new radialgraph signal representation. See section gsignal . httpd object is visible as a qrcode giving the server url. httpd object is now part of the library (not a plugin any more) (not available on Windows, Android and iOS) frameless and fullscreen modes management revised at view level and are now now exclusive at model level String without spaces in INScore scripts no longer need to be quoted. Version 1.15 vs version 1.12 new frame query method: get frame gives the coordinates of 4 points that represent the object frame, expressed in the scene local coordinates system and including all the graphic transformations (scaling, rotations on the 3 axis, shear etc.) pen messages are now accepted by all the components. Thie extension is provided to display any object bounding box. Note that for rects, ellipses etc. the previous behavior is preserved. pianoroll support. See section pianorollscore and pianoroll . Add web Api to expose inscore on the web with websocket or http. Add change tab on mobile with three digits gesture. add new object filter at application and scene level to filter forwarded messages. sending to broadcast address is enabled add forward and filter messages to the scene to handle messages forwarding at scene level. See section \\fullref{forwarding}. default port to forward messages is now 7000. add new optional tab at startup with a menu for ios and android. add zoom and move capabilities at scene level using scale , OSC{xorigin} and OSC{yorigin}. This is intended to support two fingers gesture on mobile device. bug with lines corrected: a line in non-square parent was rotated when the parent's width was smaller than its height. bug with eval forwarding corrected: forwarded messages were triggering a syntax error due to a misinterpreted incorrect args count Version 1.12 vs version 1.08 line objects: color message is now an alias of penColor . foreground method at scene level to put a scene window in foreground. See section scene . text items support font spec with new fontSize , fontFamily , fontStyle and fontWeight messages. See section fontctrl . new compatibility method at application level, provided to preserve previous behaviors. See section applmgmt . default size of guido item is increased: the ratio to the previous size is 8. force default size and font to text items in order to get equivelent rendering on different platforms (default to Arial 13px). new arrows attribute for line objects. See section arrows . the export message supports multiple file paths. See section common . new exportAll message to export an object with its children. See section common . incoming messages buffer size increased to 10.000 url support for inscore files ( load message) new common queries ( get message) : count and rcount that give the enclosed objects count and recursive count. The messages are supported at scene and application level as well. See section scenequery . new memimg object that capture the image of any object hierarchy including scenes. See section imgscore . supports relative OSC addresses that are evaluated in the context of the target object (i.e. a scene for drag and drop operations, arbitrary objects with the eval method). new eval method that takes a message list as argument, provided as a context for relative addresses evaluation. See section miscmsgs . new httpd object that implements an http server providing images of the scene to remote clients. See section webobjects and section Httpd . new websocket object that implements a websocket server providing images of the scene to remote clients but also changes notifications. See section webobjects . Files objects can receive URL as path. See section filebasedrsrc . new intermediate object for the URL (waiting for the data to be downloaded to create the real object) new events associated to url based objects: success, error, cancel. See section urlevents . support for int values as parameters of the set method of rect shape and polygon objects the clear message addressed to a gmnstream object clears also the view. The change was not previously reflected until a new valid string was posted to the object. bug in export item corrected : child scaling was not applied. bug correction: for multiple exports, only the last one was done. bug in extended address support corrected: extended address was ignored for messages dropped to a scene . bug in window color corrected: black color was not correctly set due to an incorrect color information returned by Qt. bug with 'line' initialization corrected: wrong position and orientation with negative coordinates (was previously corrected but reintroduced), incorrect initialization in layers. Version 1.08 vs version 1.07 new END marker supported to end a script parsing at arbitrary location (see INScoreLang documentation.). when displaying the mapping, the map dates are not printed any more by default (due to size and collisions). The debug map parameter change from boolean to int value: 1 to activate the mapping display, 2 to have also the dates displayed (see section debugnode ). the signal node is available at any level of the hierarchy (as well as the sync node) new connect and disconnect messages for the signal node to support signal connection to objects graphic attributes (see section signalcnx ). a slave can have several masters no more side effects for synchronized objects (position change, scaling) Version 1.07 vs version 1.06 bug with 'line' initialization corrected: wrong position and orientation with negative coordinates. new plugins static node at application level to provide a user path to look for pugins (see section ITLplugins ). explicit objects for musicxml scores ( musicxml and musicxmlf types) (see section symscore ). new faustdsp object, charging libfaust as a plugin to compile faust DSP on-the-fly (see section sigscore ). exception catched when sending osc messages: was a potential crash, e.g. in case of get message sent to a signal with a large buffer -> out of buffer memory new javascript 'post' function for posting delayed messages (see INScoreLang documentation.) new write method supported by the 'log' window (see section ITLlog ) variable addresses are evaluated in message based variables supports relative rotations on x and y axis Version 1.06 vs version 1.05 save message can now take an optional list of attributes to be saved (see section common ) variables are now evaluated and expanded inside strings. Thus interaction variables can now be passed as argument of javascript functions. corrects musicxml-version output log window is put to front when the show menu is recalled object aliases are removed when the object is deleted Version 1.05 vs version 1.03 incorrect error message for watch messages corrected new javascript readfile function (see INScoreLang documentation.) log window is now available from the application 'Tools' menu new brushStyle attribute (see section brush ) new layer object (see section miscscore ) new save method specific to the log window: saves the window content to a file (see section ITLlog ) new event method supported at object level for UI events simulation new del watchable event: sent when deleting an object (see section miscevents ) new gmnstream guido stream object (see section symscore ) Version 1.03 vs version 1.0 log window utility provided as a new static node at application level ( /ITL/log ) (see section ITLlog ). new systemCount read only attribute for Guido scores (see section gmnpage ) IRCAM gesture follower support (see section GF ) javascript engine is available at the static address /ITL/scene/javascript and can be activated using a 'run' method (see INScoreLang documentation.) new export event (see section miscevents ) new endPaint event at scene level (see section miscevents ) new windowOpacity method at scene level (see section scene ) bug correction: error messages not generated for dropped files (actually for the scene load method) bug correction: possible infinite loop in QStretchTilerItem::paint method bug correction: incorrect get alias output (all the aliases were dumped out in a single message) Version 1.00 vs version 0.98 bug correction in streching very small objects (due to approximations) bug correction in $sx and $sy computation (xorigin and yorigin was not taken into account) new 'ticks' message at application level for querying or setting the current count of time tasks (see section applmgmt ) new 'time' message at application level for querying or setting the current time (see section applmgmt ) new 'forward' message at application level for messages forwarding to remote hosts (see section applmgmt ) new 'relative | absolute' synchronization mode (see section syncmode ) 'rename' message not supported any more a scene accepts multiple dropped files significant extension and syntax changes in inscore script files (see INScoreLang documentation.) fileWatcher methods renamed and simplified (see section filewatch ) 'click' and 'select' messages are not supported any more. new 'stats' virtual node at application level (address /ITL/stats), supports 'get' and 'reset' messages the node gives statistics about the incoming messages (see section ITLdebug ) crash bug in signal creation corrected: a signal size created with an incorrect stream (e.g. a string value) was 0 and no buffer was allocated. extension of the time related events to duration: new 'durEnter' and 'durLeave' watchable events (see section timeevents ) new 'absolutexy' message at scene level to switch to absolute coordinates (in pixels) (see section scene ) new 'push' and 'pop' messages to store and restore current watched events and associated messages (see section evtstate ) internal change: mappings are now implemented as a separable library strictly complying to the mappings formalism. new dates may be specified as rational strings (see section time ). interaction messages are not any more generated when the date can't be resolved. new rate message at application level to control the time task rate (see section ITL ) new frameless message at scene level to switch to frameless or normal window (see section scene ) Version 0.98 vs version 0.97 new fastgraph object for graphic signals fast rendering (see section setsect ) $date variable overflow catched files dropped on application icon correctly opened when the application is not running supports drag and drop of textual osc message strings osc error stream normalized: the message address is 'error:' or 'warning:' followed by a single message string. javascript and lua support: a single persistent context is created at application level and for each scene. (see section \\fullref{scriptlang}) Version 0.97 vs version 0.96 objects position, date and watched events preserved through type change bug in quantified dates corrected (null denominator set to the quantified value) new 'alias' message providing arbitrary OSC addresses support bug in parser corrected: escape only ' and \" chars, otherwise it is literal guido score map makes use of the new guidolib extended mapping API for staff and system chords map correction (corrected by guido engine) Version 0.96 vs version 0.95 switch to v8 javascript engine lua not embedded by default Version 0.95 vs version 0.92 new 'mouse' 'show/hide' message supported at application level (see section ITL ) graphic signal supports alpha messages at object level javascript and lua embedded and supported in inscore scripts. bug correction in sync delete (introduced with version 0.90) Version 0.92 vs version 0.91 bug corrected: crash with messages addressed to a signal without argument date and duration messages support one arg form using 1 as implicit denominator value the one arg form accepts float values (see section time ). Version 0.91 vs version 0.90 bug in sync management corrected (introduced with the new sync parsing scheme) Version 0.90 vs version 0.82 at application level: osc debug is now 'on' by default new scripting features (variables). ITL file format change: semicolon added at the end of each message '//' comment not supported any more ' new variables scripting features single quote support for strings messages addressed to sync node must use the string format new 'grid' object for automatic segmentation and mapping Version 0.82 vs version 0.81 new Faust plugins for signals processing colors management change: all the color models (RGBA and HSBA) accept now float values that are interpreted in the common [-1,1] range. For the hue value, 0 always corresponds to 'red' whatever the scale used. stretch adjustment for video objects (corrects gaps in sync h mode) support for opening inscore files on the command line system mapping correction splash screen and about menu implemented by the viewer Version 0.81 vs version 0.80 behavior change with synchronization without stretch: now the system looks also in the slave map for a segment corresponding to the master date. $date variable change: the value is now (0,0) when no date is available and $date is time shifted according to the object date. date message change: the date 0 0 is ignored Version 0.80 vs version 0.79 corrects the map not saved by the save message issue corrects get map output: 2D segments were not correctly converted to string Version 0.79 vs version 0.78 crash bug corrected for the 'save' message addressed to '/ITL' message policy change: relaxed numeric parameters policy (float are accepted for int and int for float) bug in get watch for time events corrected (incorrect reply) Known issues: map not saved by the save message Version 0.78 vs version 0.77 guido system map extended: supports flat map or subdivided map (see section guidomap ). new shear and rotate transformations messages (see section transform ). new rename message to change an object name (and thus its OSC address) (see section common ). relaxed bool parameter policy: objects accept float values for bool parameters automatic numbering of exports when destination file is not completely specified i.e. no name, no extension. (see section common ). quantification introduced to $date variable (see section interactvar ). reset message addressed to a scene clears the scene rootPath Version 0.77 vs version 0.76 get guido-version and musicxml-version messages supported by the application (see section ITL ). save message bug correction - introduced with version 0.70: only partial state of objects was saved rootPath message introduced at scene level (see section scene ). scene name translation strategy change: only the explicit 'scene' name is translated by the scene load message handler into the current scene name, other names are left unchanged. bitmap copy adjustment in sync stretched mode is now only made for images Version 0.76 vs version 0.75 new require message supported by the /ITL node (see section ITL ). new event named newElement supported at scene level (see section timeevents ). new name and address variables (see section interactvar ). new system map computation making use of the new slices map provided by the guidolib version 1.42 INScore API: the newMessage method sets now the message src IP to localhost With the previous version and the lack of src IP, replies to queries or error messages could be sent to undefined addresses (and mostly lost). bug corrected with ellipse and rect : integer graphic size computation changed to float (prevents objects disappearance with small width or height) bug in scene export: left and right borders could be cut, depending on the scene size corrected by rendering the QGraphicsView container instead the QGraphicsScene crash bug with $date:name corrected: crashed when there is no mapping named name . Version 0.75 vs version 0.74 new map+ message (see section mapAddMsg ). the click and select messages are deprecated (but still supported). They will be removed in a future version. Version 0.74 vs version 0.63 new dpage message accepted by gmn objects (see section gmnpage ). x and y variables: automatic range type detection (int | float) set txt message: accepts polymorphic stream like parameters (see section setsect ). drag and drop files support in INScore viewer interaction variables extension: $sx , $sy variables added to support scene coordinate space (see section interactvar ). automatic range mapping for $x , $y variables. new $self and $scene variables in the address field (see section oscvar ). OSC identifiers characters set extended with '_' and '-' (see section genformat ). support for multiple scenes: new , del and foreground messages (see section scene ). load message supported at scene level (see section scene ). get watch implemented. watch message without argument to clear all the watched events (see section interactvar ). order of rendering and width, height update corrected (may lead to incorrect rendering) bug with gmn score corrected: missing update for page, columns and rows changes. package delivered with the Guido Engine version 1.41 that corrects minimum staves distance and incorrect mapping when optimum page fill is off. Version 0.63 vs version 0.60 new 'mousemove' event (see section uievents ). interaction messages accept variables ($x, $y, $date...) (see section interactvar ). SVG code and files support (see section setfile ). set line message change: the x y form is deprecated, it is replaced by the following forms: 'xy' x y (equivalent to the former form) and 'wa' width angle (see section setsect ). new 'effect' message (section effectmsg ). utf8 support on windows corrected transparency support for stretched synchronized objects corrected multiple application instances supported with dynamic udp port number allocation. command line option with --port portnumber option to set the receive udp port number at startup. Version 0.60 vs version 0.55 new 'xorigin' and 'yorigin' messages (section origin ). new interaction messages set (section interaction ). alpha channel handled by images and video bug correction in line creation corrected (false incorrect parameter returned) bug correction in line 'get' message handling memory leak correction (messages not deleted) Known issues: incorrect graphic rendering when 'sync a b' is changed to 'sync b a' in the same update loop incorrect nested synchronization when master is horizontaly stretched, Version 0.55 vs version 0.53 ITL parser corrected to support regexp in message string (used by messages addressed to sync node) format of mapping files and strings changed (section mapMsg ). format of sync messages extended to include map name (section syncmsg ). signal node: 'garbage' message removed new 'reset' message for the scene (/ITL/scene) (section scene ). new 'version' message for the application (/ITL) (section ITL ). new 'reset' message for signals (section ssignal ). bug parsing messages without params corrected slave segmentation used for synchronization new H synchronization mode (preserves slave segmentation) crash bug corrected for load message and missing ITL files Version 0.53 vs version 0.50 Graphic signal thickness is now symmetrically drawn around y position. ITL file format supports regular expressions in OSC addresses. IP of a message sender is now used for the reply or for error reporting. new line object (section setsect ). new penStyle message for vectorial graphics (section specificMsg ). new color messages red, green, blue, alpha, dcolor, dred, dgreen, dblue (section common and relpos ). color values for objects are bounded to [0,255] get map message behaves according to new map message (section getsect ). get width and get height is now supported by all objects (section getsect ). bug in signal projection corrected (index 0 rejected) bug in signals default value delivery corrected new pageCount message for guido scores debug nodes modified state propagated to parent node (corrects the debug informations graphic update issue) rational values catch null denominator (to prevents divide by zero exceptions). Version 0.50 vs version 0.42 identifier specification change (section genformat ). new application hello and defaultShow messages (section ITL ). new load and save messages (sections ITL and common ). click and select messages: rightbottom and leftbottom modes renamed to bottomright and bottomleft new center mode for the click message query mode sent back with the reply both for click and select messages new file , html and htmlf types for the set message (section setsect ). get syntax change for the scene . fileWatcher messages completely redesigned. mappings can be identified by names (section mapMsg ). rect, ellipse, curve, line and polygon object support graphic to relative-time mapping new synchronization modes for Guido scores: voice1, voice2, ... , staff1, staff2, ... , system, page. Guido mapping manages repeat bars. Graphic signals messages design (section gsignal ).","title":"Changes list"},{"location":"refs/20-changes/#changes-list","text":"","title":"Changes list"},{"location":"refs/20-changes/#version-134-vs-version-131","text":"new scount query at application level ( /ITL ): gives the scenes count. See section ITLQuery new scenes message at application level ( /ITL ). See section applmgmt new errorAddress message at application level ( /ITL ): set the OSC address of error messages. See section applmgmt forward message behavior change: append addresses to destination list, broadcast addresses are explicitly rejected and trigger an error. extend newElement event to application level ( /ITL ). See section typespecevents add support for get 'date%a' query: gives the absolute date in seconds (assumes the tempo is 60 bpm). add event handlers portrait and landscape for screen orientation change (triggered only by the web version) supports dynamic scene relative dimensions and positions. See section srelpos and whcontrol add IP query to application level ( /ITL ). See section ITLQuery add text query to txt objects. allows negative date messages. fix evaluation of args variables ( 1... n) in javascript run method. fix crash bug with OSC bundles. Web Specific Changes new init message for audioInput objects, must be called before using the audio input. new autoOff message supported by faust objects to automatically set ui buttons to 0 after a 1 value. support portrait and landscape events. prevent default keydown event on window (avoid scrolling). fix media end event. fix concurrent faustw objects creation.","title":"Version 1.34 vs version 1.31"},{"location":"refs/20-changes/#version-131-vs-version-128","text":"add support for get 'date%f' query add midi node at application level, supported by the native app for compatibility reasons (works only with the web version) new keyDown and keyUp events. See section keyevents fix $date quantification fix 'event' messages forwarding fix $date%f detection in javascript run method fix non visible mapping for images fix incorrect $x et $y variables value for proportional dimension objects fix missing curve rendering fix guido score scaling issue Web Specific Changes new 'compute' message supported by faust objects new form of the 'connect' message (to address individual channels) font size unit changed to 'vw' (relative to viewport width) load message implemented new faustw object (precompiled faust dsp) new midi events","title":"Version 1.31 vs version 1.28"},{"location":"refs/20-changes/#version-128-vs-version-127","text":"new dvolume method for media objects new ssl static application node for ssl certificates management new cert key cacert messages to manage ssl certificates and keys. See section SSL new get clients messages at application level add https support to forwarding mechanism. See section Forwarding Web Specific Changes fix ready event for audio objects","title":"Version 1.28 vs version 1.27"},{"location":"refs/20-changes/#version-127-vs-version-124","text":"Web Specific Changes new faust object (web version) new connect method (web version) forwarding mechanism extended with http and ws support. See section Forwarding","title":"Version 1.27 vs version 1.24"},{"location":"refs/20-changes/#version-124-vs-version-122","text":"new inscore2 scripting language log window supports the scale message. See section ITLlog colors: supports html color names and hex values with 0x as prefix. See section colormsg supports absolute time segments in mappings. See section segdefs tempo is now a floating point value fix touch events with edit dialog add 'inscore2' extension to files filter (mobile version) update to guido engine 1.66 edit message supports set as argument. See section editmsg edit new reset argument to clear the edit string in the object cache. See section editmsg new dshear method. See section transform fix bug with javascript runtime variable (passed as argument to run) fix synchronization issue with arcs (not visible when synchronized) fix crash bug with set messages addressed to /ITL/*/anobject","title":"Version 1.24 vs version 1.22"},{"location":"refs/20-changes/#version-122-vs-version-121","text":"new opengl message supported at scene level for optional OpenGl graphics rendering. Improves significantly the cpu use for graphics operations but at the cost of poorer rendering for text and symbolic scores fix potential issue with dates: dates expressed with big values for the numerator or the denominator may result in overflow","title":"Version 1.22 vs version 1.21"},{"location":"refs/20-changes/#version-121-vs-version-118","text":"new set of sensor objects. See section sensors . update to guido engine 1.63 new preprocess message supported at application and scene level intended to debug javascript sections or math expressions. Output of pre-processing is printed to the log window. See section applmgmt and scene . environement variables introduced in scripting environment (OSName and OSId). See INScoreLang documentation. new math expressions introduced in scripting context. See INScoreLang documentation. new syncFrame synchronisation mode. See section syncPos and syncFrame . the events system has been extended to any object attribute and supports user defined events. This change comes also with a one tick delay introduced to handle all the events (i.e. the event associated messages are processed by the next time task): this is intended to avoid freezing the system in case of loops. See section attributeevents and userevents . lua support has been dropped (compilation was optional, never embedded into a distribution) parser strategy changed: now each message is processed one by one to ensure the system consistency, especially for message based variables: an object state remains now consistent from one message to another. new arc object. See section vgraphscore and arcobjects . new radius message supported by rectangles. See section rectobjects . new edit message supported by all objects: opens a small messages editor. See section editmsg . new level message supported by the log window and extended debugging support. See section ITLlog . new video specific messages and management: the video time is now independent from the inscore object time. See section video . gmn objects set : output correct error message in case of syntax error save msg output changed: a scene emit the new message, static info nodes (log, stat, javascript...) bug in debug name corrected (was not removed from graphic space) bug in polygon and curve position corrected (was not centered on 0 0) - use /ITL compatibility to preserve previous behaviour crash bug corrected: occured when lauching inscore from a secondary screen new write message supported by text based objects. See section txtwrite .","title":"Version 1.21 vs version 1.18"},{"location":"refs/20-changes/#version-118-vs-version-117","text":"new tempo message supported by all objects. See section tempo . new pageCount event supported by symbolic score objects. See section typespecevents . new error event supported at application level. See section typespecevents . new browse message at application level to open a document in a web browser. See section system . web api documentation included in package","title":"Version 1.18 vs version 1.17"},{"location":"refs/20-changes/#version-117-vs-version-115","text":"support animated svg using the new animate message. See section svgobjects . messages list variables are exported to javascript as a string. Carlito Regular open source font is embedded in the application ressources and used as a default font. See at https://fontlibrary.org/fr/font/carlito for more information. symbolic notation support extended with score expressions. See section scoreExpr . new newData event. See section miscevents . the javascript engine is shared between the application and the different scenes. Note that it may change a script behavior when exploiting the previous independance of the javascript engine environments. new javascript osname function that gives the current operating system name. See INScoreLang documentation. new javascript osid function that gives the current operating system as an id. See INScoreLang documentation. rootPath message can be called without parameter to clear a scene rootPath. See section scene . log window supports the foreground message. See section ITLlog . user actions on windows are generating foreground messages. application quit when the last scene is closed (even when the log window is opened) new lock message supported by all objects to prevent an object deletion. See section common . OSC output buffer has been enlarged to 32768. Note that sending large messages works on localhost but are likely to face the MTU on real network. crash bug corrected: outgoing OSC messages are now handling buffer overflow exceptions. support for multi touch events. See section touchevents . new radialgraph signal representation. See section gsignal . httpd object is visible as a qrcode giving the server url. httpd object is now part of the library (not a plugin any more) (not available on Windows, Android and iOS) frameless and fullscreen modes management revised at view level and are now now exclusive at model level String without spaces in INScore scripts no longer need to be quoted.","title":"Version 1.17 vs version 1.15"},{"location":"refs/20-changes/#version-115-vs-version-112","text":"new frame query method: get frame gives the coordinates of 4 points that represent the object frame, expressed in the scene local coordinates system and including all the graphic transformations (scaling, rotations on the 3 axis, shear etc.) pen messages are now accepted by all the components. Thie extension is provided to display any object bounding box. Note that for rects, ellipses etc. the previous behavior is preserved. pianoroll support. See section pianorollscore and pianoroll . Add web Api to expose inscore on the web with websocket or http. Add change tab on mobile with three digits gesture. add new object filter at application and scene level to filter forwarded messages. sending to broadcast address is enabled add forward and filter messages to the scene to handle messages forwarding at scene level. See section \\fullref{forwarding}. default port to forward messages is now 7000. add new optional tab at startup with a menu for ios and android. add zoom and move capabilities at scene level using scale , OSC{xorigin} and OSC{yorigin}. This is intended to support two fingers gesture on mobile device. bug with lines corrected: a line in non-square parent was rotated when the parent's width was smaller than its height. bug with eval forwarding corrected: forwarded messages were triggering a syntax error due to a misinterpreted incorrect args count","title":"Version 1.15 vs version 1.12"},{"location":"refs/20-changes/#version-112-vs-version-108","text":"line objects: color message is now an alias of penColor . foreground method at scene level to put a scene window in foreground. See section scene . text items support font spec with new fontSize , fontFamily , fontStyle and fontWeight messages. See section fontctrl . new compatibility method at application level, provided to preserve previous behaviors. See section applmgmt . default size of guido item is increased: the ratio to the previous size is 8. force default size and font to text items in order to get equivelent rendering on different platforms (default to Arial 13px). new arrows attribute for line objects. See section arrows . the export message supports multiple file paths. See section common . new exportAll message to export an object with its children. See section common . incoming messages buffer size increased to 10.000 url support for inscore files ( load message) new common queries ( get message) : count and rcount that give the enclosed objects count and recursive count. The messages are supported at scene and application level as well. See section scenequery . new memimg object that capture the image of any object hierarchy including scenes. See section imgscore . supports relative OSC addresses that are evaluated in the context of the target object (i.e. a scene for drag and drop operations, arbitrary objects with the eval method). new eval method that takes a message list as argument, provided as a context for relative addresses evaluation. See section miscmsgs . new httpd object that implements an http server providing images of the scene to remote clients. See section webobjects and section Httpd . new websocket object that implements a websocket server providing images of the scene to remote clients but also changes notifications. See section webobjects . Files objects can receive URL as path. See section filebasedrsrc . new intermediate object for the URL (waiting for the data to be downloaded to create the real object) new events associated to url based objects: success, error, cancel. See section urlevents . support for int values as parameters of the set method of rect shape and polygon objects the clear message addressed to a gmnstream object clears also the view. The change was not previously reflected until a new valid string was posted to the object. bug in export item corrected : child scaling was not applied. bug correction: for multiple exports, only the last one was done. bug in extended address support corrected: extended address was ignored for messages dropped to a scene . bug in window color corrected: black color was not correctly set due to an incorrect color information returned by Qt. bug with 'line' initialization corrected: wrong position and orientation with negative coordinates (was previously corrected but reintroduced), incorrect initialization in layers.","title":"Version 1.12 vs version 1.08"},{"location":"refs/20-changes/#version-108-vs-version-107","text":"new END marker supported to end a script parsing at arbitrary location (see INScoreLang documentation.). when displaying the mapping, the map dates are not printed any more by default (due to size and collisions). The debug map parameter change from boolean to int value: 1 to activate the mapping display, 2 to have also the dates displayed (see section debugnode ). the signal node is available at any level of the hierarchy (as well as the sync node) new connect and disconnect messages for the signal node to support signal connection to objects graphic attributes (see section signalcnx ). a slave can have several masters no more side effects for synchronized objects (position change, scaling)","title":"Version 1.08 vs version 1.07"},{"location":"refs/20-changes/#version-107-vs-version-106","text":"bug with 'line' initialization corrected: wrong position and orientation with negative coordinates. new plugins static node at application level to provide a user path to look for pugins (see section ITLplugins ). explicit objects for musicxml scores ( musicxml and musicxmlf types) (see section symscore ). new faustdsp object, charging libfaust as a plugin to compile faust DSP on-the-fly (see section sigscore ). exception catched when sending osc messages: was a potential crash, e.g. in case of get message sent to a signal with a large buffer -> out of buffer memory new javascript 'post' function for posting delayed messages (see INScoreLang documentation.) new write method supported by the 'log' window (see section ITLlog ) variable addresses are evaluated in message based variables supports relative rotations on x and y axis","title":"Version 1.07 vs version 1.06"},{"location":"refs/20-changes/#version-106-vs-version-105","text":"save message can now take an optional list of attributes to be saved (see section common ) variables are now evaluated and expanded inside strings. Thus interaction variables can now be passed as argument of javascript functions. corrects musicxml-version output log window is put to front when the show menu is recalled object aliases are removed when the object is deleted","title":"Version 1.06 vs version 1.05"},{"location":"refs/20-changes/#version-105-vs-version-103","text":"incorrect error message for watch messages corrected new javascript readfile function (see INScoreLang documentation.) log window is now available from the application 'Tools' menu new brushStyle attribute (see section brush ) new layer object (see section miscscore ) new save method specific to the log window: saves the window content to a file (see section ITLlog ) new event method supported at object level for UI events simulation new del watchable event: sent when deleting an object (see section miscevents ) new gmnstream guido stream object (see section symscore )","title":"Version 1.05 vs version 1.03"},{"location":"refs/20-changes/#version-103-vs-version-10","text":"log window utility provided as a new static node at application level ( /ITL/log ) (see section ITLlog ). new systemCount read only attribute for Guido scores (see section gmnpage ) IRCAM gesture follower support (see section GF ) javascript engine is available at the static address /ITL/scene/javascript and can be activated using a 'run' method (see INScoreLang documentation.) new export event (see section miscevents ) new endPaint event at scene level (see section miscevents ) new windowOpacity method at scene level (see section scene ) bug correction: error messages not generated for dropped files (actually for the scene load method) bug correction: possible infinite loop in QStretchTilerItem::paint method bug correction: incorrect get alias output (all the aliases were dumped out in a single message)","title":"Version 1.03 vs version 1.0"},{"location":"refs/20-changes/#version-100-vs-version-098","text":"bug correction in streching very small objects (due to approximations) bug correction in $sx and $sy computation (xorigin and yorigin was not taken into account) new 'ticks' message at application level for querying or setting the current count of time tasks (see section applmgmt ) new 'time' message at application level for querying or setting the current time (see section applmgmt ) new 'forward' message at application level for messages forwarding to remote hosts (see section applmgmt ) new 'relative | absolute' synchronization mode (see section syncmode ) 'rename' message not supported any more a scene accepts multiple dropped files significant extension and syntax changes in inscore script files (see INScoreLang documentation.) fileWatcher methods renamed and simplified (see section filewatch ) 'click' and 'select' messages are not supported any more. new 'stats' virtual node at application level (address /ITL/stats), supports 'get' and 'reset' messages the node gives statistics about the incoming messages (see section ITLdebug ) crash bug in signal creation corrected: a signal size created with an incorrect stream (e.g. a string value) was 0 and no buffer was allocated. extension of the time related events to duration: new 'durEnter' and 'durLeave' watchable events (see section timeevents ) new 'absolutexy' message at scene level to switch to absolute coordinates (in pixels) (see section scene ) new 'push' and 'pop' messages to store and restore current watched events and associated messages (see section evtstate ) internal change: mappings are now implemented as a separable library strictly complying to the mappings formalism. new dates may be specified as rational strings (see section time ). interaction messages are not any more generated when the date can't be resolved. new rate message at application level to control the time task rate (see section ITL ) new frameless message at scene level to switch to frameless or normal window (see section scene )","title":"Version 1.00 vs version 0.98"},{"location":"refs/20-changes/#version-098-vs-version-097","text":"new fastgraph object for graphic signals fast rendering (see section setsect ) $date variable overflow catched files dropped on application icon correctly opened when the application is not running supports drag and drop of textual osc message strings osc error stream normalized: the message address is 'error:' or 'warning:' followed by a single message string. javascript and lua support: a single persistent context is created at application level and for each scene. (see section \\fullref{scriptlang})","title":"Version 0.98 vs version 0.97"},{"location":"refs/20-changes/#version-097-vs-version-096","text":"objects position, date and watched events preserved through type change bug in quantified dates corrected (null denominator set to the quantified value) new 'alias' message providing arbitrary OSC addresses support bug in parser corrected: escape only ' and \" chars, otherwise it is literal guido score map makes use of the new guidolib extended mapping API for staff and system chords map correction (corrected by guido engine)","title":"Version 0.97 vs version 0.96"},{"location":"refs/20-changes/#version-096-vs-version-095","text":"switch to v8 javascript engine lua not embedded by default","title":"Version 0.96 vs version 0.95"},{"location":"refs/20-changes/#version-095-vs-version-092","text":"new 'mouse' 'show/hide' message supported at application level (see section ITL ) graphic signal supports alpha messages at object level javascript and lua embedded and supported in inscore scripts. bug correction in sync delete (introduced with version 0.90)","title":"Version 0.95 vs version 0.92"},{"location":"refs/20-changes/#version-092-vs-version-091","text":"bug corrected: crash with messages addressed to a signal without argument date and duration messages support one arg form using 1 as implicit denominator value the one arg form accepts float values (see section time ).","title":"Version 0.92 vs version 0.91"},{"location":"refs/20-changes/#version-091-vs-version-090","text":"bug in sync management corrected (introduced with the new sync parsing scheme)","title":"Version 0.91 vs version 0.90"},{"location":"refs/20-changes/#version-090-vs-version-082","text":"at application level: osc debug is now 'on' by default new scripting features (variables). ITL file format change: semicolon added at the end of each message '//' comment not supported any more ' new variables scripting features single quote support for strings messages addressed to sync node must use the string format new 'grid' object for automatic segmentation and mapping","title":"Version 0.90 vs version 0.82"},{"location":"refs/20-changes/#version-082-vs-version-081","text":"new Faust plugins for signals processing colors management change: all the color models (RGBA and HSBA) accept now float values that are interpreted in the common [-1,1] range. For the hue value, 0 always corresponds to 'red' whatever the scale used. stretch adjustment for video objects (corrects gaps in sync h mode) support for opening inscore files on the command line system mapping correction splash screen and about menu implemented by the viewer","title":"Version 0.82 vs version 0.81"},{"location":"refs/20-changes/#version-081-vs-version-080","text":"behavior change with synchronization without stretch: now the system looks also in the slave map for a segment corresponding to the master date. $date variable change: the value is now (0,0) when no date is available and $date is time shifted according to the object date. date message change: the date 0 0 is ignored","title":"Version 0.81 vs version 0.80"},{"location":"refs/20-changes/#version-080-vs-version-079","text":"corrects the map not saved by the save message issue corrects get map output: 2D segments were not correctly converted to string","title":"Version 0.80 vs version 0.79"},{"location":"refs/20-changes/#version-079-vs-version-078","text":"crash bug corrected for the 'save' message addressed to '/ITL' message policy change: relaxed numeric parameters policy (float are accepted for int and int for float) bug in get watch for time events corrected (incorrect reply) Known issues: map not saved by the save message","title":"Version 0.79 vs version 0.78"},{"location":"refs/20-changes/#version-078-vs-version-077","text":"guido system map extended: supports flat map or subdivided map (see section guidomap ). new shear and rotate transformations messages (see section transform ). new rename message to change an object name (and thus its OSC address) (see section common ). relaxed bool parameter policy: objects accept float values for bool parameters automatic numbering of exports when destination file is not completely specified i.e. no name, no extension. (see section common ). quantification introduced to $date variable (see section interactvar ). reset message addressed to a scene clears the scene rootPath","title":"Version 0.78 vs version 0.77"},{"location":"refs/20-changes/#version-077-vs-version-076","text":"get guido-version and musicxml-version messages supported by the application (see section ITL ). save message bug correction - introduced with version 0.70: only partial state of objects was saved rootPath message introduced at scene level (see section scene ). scene name translation strategy change: only the explicit 'scene' name is translated by the scene load message handler into the current scene name, other names are left unchanged. bitmap copy adjustment in sync stretched mode is now only made for images","title":"Version 0.77 vs version 0.76"},{"location":"refs/20-changes/#version-076-vs-version-075","text":"new require message supported by the /ITL node (see section ITL ). new event named newElement supported at scene level (see section timeevents ). new name and address variables (see section interactvar ). new system map computation making use of the new slices map provided by the guidolib version 1.42 INScore API: the newMessage method sets now the message src IP to localhost With the previous version and the lack of src IP, replies to queries or error messages could be sent to undefined addresses (and mostly lost). bug corrected with ellipse and rect : integer graphic size computation changed to float (prevents objects disappearance with small width or height) bug in scene export: left and right borders could be cut, depending on the scene size corrected by rendering the QGraphicsView container instead the QGraphicsScene crash bug with $date:name corrected: crashed when there is no mapping named name .","title":"Version 0.76 vs version 0.75"},{"location":"refs/20-changes/#version-075-vs-version-074","text":"new map+ message (see section mapAddMsg ). the click and select messages are deprecated (but still supported). They will be removed in a future version.","title":"Version 0.75 vs version 0.74"},{"location":"refs/20-changes/#version-074-vs-version-063","text":"new dpage message accepted by gmn objects (see section gmnpage ). x and y variables: automatic range type detection (int | float) set txt message: accepts polymorphic stream like parameters (see section setsect ). drag and drop files support in INScore viewer interaction variables extension: $sx , $sy variables added to support scene coordinate space (see section interactvar ). automatic range mapping for $x , $y variables. new $self and $scene variables in the address field (see section oscvar ). OSC identifiers characters set extended with '_' and '-' (see section genformat ). support for multiple scenes: new , del and foreground messages (see section scene ). load message supported at scene level (see section scene ). get watch implemented. watch message without argument to clear all the watched events (see section interactvar ). order of rendering and width, height update corrected (may lead to incorrect rendering) bug with gmn score corrected: missing update for page, columns and rows changes. package delivered with the Guido Engine version 1.41 that corrects minimum staves distance and incorrect mapping when optimum page fill is off.","title":"Version 0.74 vs version 0.63"},{"location":"refs/20-changes/#version-063-vs-version-060","text":"new 'mousemove' event (see section uievents ). interaction messages accept variables ($x, $y, $date...) (see section interactvar ). SVG code and files support (see section setfile ). set line message change: the x y form is deprecated, it is replaced by the following forms: 'xy' x y (equivalent to the former form) and 'wa' width angle (see section setsect ). new 'effect' message (section effectmsg ). utf8 support on windows corrected transparency support for stretched synchronized objects corrected multiple application instances supported with dynamic udp port number allocation. command line option with --port portnumber option to set the receive udp port number at startup.","title":"Version 0.63 vs version 0.60"},{"location":"refs/20-changes/#version-060-vs-version-055","text":"new 'xorigin' and 'yorigin' messages (section origin ). new interaction messages set (section interaction ). alpha channel handled by images and video bug correction in line creation corrected (false incorrect parameter returned) bug correction in line 'get' message handling memory leak correction (messages not deleted) Known issues: incorrect graphic rendering when 'sync a b' is changed to 'sync b a' in the same update loop incorrect nested synchronization when master is horizontaly stretched,","title":"Version 0.60 vs version 0.55"},{"location":"refs/20-changes/#version-055-vs-version-053","text":"ITL parser corrected to support regexp in message string (used by messages addressed to sync node) format of mapping files and strings changed (section mapMsg ). format of sync messages extended to include map name (section syncmsg ). signal node: 'garbage' message removed new 'reset' message for the scene (/ITL/scene) (section scene ). new 'version' message for the application (/ITL) (section ITL ). new 'reset' message for signals (section ssignal ). bug parsing messages without params corrected slave segmentation used for synchronization new H synchronization mode (preserves slave segmentation) crash bug corrected for load message and missing ITL files","title":"Version 0.55 vs version 0.53"},{"location":"refs/20-changes/#version-053-vs-version-050","text":"Graphic signal thickness is now symmetrically drawn around y position. ITL file format supports regular expressions in OSC addresses. IP of a message sender is now used for the reply or for error reporting. new line object (section setsect ). new penStyle message for vectorial graphics (section specificMsg ). new color messages red, green, blue, alpha, dcolor, dred, dgreen, dblue (section common and relpos ). color values for objects are bounded to [0,255] get map message behaves according to new map message (section getsect ). get width and get height is now supported by all objects (section getsect ). bug in signal projection corrected (index 0 rejected) bug in signals default value delivery corrected new pageCount message for guido scores debug nodes modified state propagated to parent node (corrects the debug informations graphic update issue) rational values catch null denominator (to prevents divide by zero exceptions).","title":"Version 0.53 vs version 0.50"},{"location":"refs/20-changes/#version-050-vs-version-042","text":"identifier specification change (section genformat ). new application hello and defaultShow messages (section ITL ). new load and save messages (sections ITL and common ). click and select messages: rightbottom and leftbottom modes renamed to bottomright and bottomleft new center mode for the click message query mode sent back with the reply both for click and select messages new file , html and htmlf types for the set message (section setsect ). get syntax change for the scene . fileWatcher messages completely redesigned. mappings can be identified by names (section mapMsg ). rect, ellipse, curve, line and polygon object support graphic to relative-time mapping new synchronization modes for Guido scores: voice1, voice2, ... , staff1, staff2, ... , system, page. Guido mapping manages repeat bars. Graphic signals messages design (section gsignal ).","title":"Version 0.50 vs version 0.42"},{"location":"refs/3-common/","text":"Common messages Common messages are intended to control the graphic and the time space of the components of a scene. They could be sent to any address with the form /ITL/ scene or /ITL/ scene /\\textit{identifier } where identifier is the unique identifier of a scene component. commonMsg ComplexDiagram( Choice (0, Sequence ('show', NonTerminal('int32')), 'del', Sequence ('lock', NonTerminal('int32')), Sequence (Choice (0, 'export', 'exportAll'), Choice (0, OneOrMore (Sequence (Comment ('1'), NonTerminal('filePath'))), Comment ('2'))), Sequence ('save', Optional ( OneOrMore ('message')), NonTerminal('filePath'), Optional ( '+')), NonTerminal('PositionMsg'), NonTerminal('ColorMsg'), NonTerminal('TimeMsg'), NonTerminal('WatchMsg'), NonTerminal('EventMsg')) ).addTo() show : shows or hides the destination object. The parameter is interpreted as a boolean value. Default value is 1 . del : deletes the destination object. lock : if not null, cancel any del message sent to this object. However, the object will still be deleted if one of its parents receives a del message. The parameter is interpreted as a boolean value. Default value is 0 . export and exportAll : exports an object to an image file respectively without or with its childrens. If the exported object is a scene, childrens are always exported. 1) exports to the filePath name. The filePath can be relative or absolute. When the filename is not specified, exports to path/ identifier .pdf . The file extension is used to infer the export format. Supported extensions and formats are: pdf, bmp, gif, jpeg, png, pgm, ppm, tiff, xbm, xpm . 2) exports to rootPath/ identifier .pdf . When the destination file is not completely specified (second form or missing extension), there is an automatic numbering of output names when the destination file already exists. save : recursively saves objects states to a file. When a message list is present, only the specified attributes are saved. The filePath can be relative or absolute. When relative, an absolute path is build using the current rootPath (see application or scene current paths p.\\pageref{applmgmt} and p.\\pageref{scene}). The optional + parameter indicates an append mode for the write operation. The message must be sent to the address /ITL to save the whole application state. 'PositionMsg' are absolute and relative position messages. 'ColorMsg' are absolute and relative color control messages. 'TimeMsg' are time management messages. They are described in section time . 'WatchMsg' are described in section interaction . 'EventMsg' are described in section eventMsg . Example Export of a scene to a given file as jpeg at the current root path: /ITL/scene export 'myexport.jpg'; Saving a scene to myScore.inscore at the current root path, the second form saves only the x , y and z attributes, the third form uses the append mode: /ITL/scene save 'myScore.inscore'; /ITL/scene save x y z 'thePositions.inscore'; /ITL/scene save 'myScore.inscore' '+'; Hiding an object: /ITL/scene/myObject show 0; Note: when a list of attributes is specified, unknown attributes are silently ignored. Positioning PositionMsg ComplexDiagram( Choice (0, NonTerminal('absPosMsg'), NonTerminal('relPosMsg'), NonTerminal('originMsg'), NonTerminal('transformMsg')) ).addTo() Graphic position messages are absolute position or relative position messages. They can also control an object origin and transformations like rotation around an axis. Absolute positioning absPosMsg ComplexDiagram( Choice (0, Sequence ('x', NonTerminal('float32')), Sequence ('y', NonTerminal('float32')), Sequence ('z', NonTerminal('float32')), Sequence ('angle', NonTerminal('float32')), Sequence ('scale', NonTerminal('float32'))) ).addTo() x y : moves the x or y coordinate of a component. By default, components are centered on their x , y coordinates. The coordinates space range is [-1,1] . For a scene component, -1 is the leftmost or topmost position, 1 is the rightmost or bottommost position. [0,0] represents the center of the scene . For the scene itself, it moves the window in the screen space and the coordinate space is orthonormal, based on the screen lowest dimension ( i.e. with a 4:3 screen, y=-1 and y=1 are respectively the exact top and bottom of the screen, but neither x=-1 nor x=1 are the exact left and right of the screen). Default coordinates are [0,0] . z : sets the z order of a component. z order is actually relative to the scene components: objects of high z order will be drawn on top of components with a lower z order. Components sharing the same z order will be drawn in an undefined order, although the order will stay the same for as long as they live. Default z order is 0. angle : sets the angle value of a component, which is used to rotate it around its center. The angle is measured in clockwise degrees from the x axis. Default angle value is 0. scale : reduce/enlarge a component. Default scale is 1 . Example Moving and scaling an object: /ITL/scene/myObject x -0.9; /ITL/scene/myObject y 0.9; /ITL/scene/myObject scale 2.0; Relative positioning relPosMsg ComplexDiagram( Choice (0, Sequence ('dx', NonTerminal('float32')), Sequence ('dy', NonTerminal('float32')), Sequence ('dz', NonTerminal('float32')), Sequence ('drotatex', NonTerminal('float32')), Sequence ('drotatey', NonTerminal('float32')), Sequence ('drotatez', NonTerminal('float32')), Sequence ('dangle', NonTerminal('float32')), Sequence ('dscale', NonTerminal('float32'))) ).addTo() dx , dy , dz messages are similar to x , y , z but the parameters represent a displacement relative to the current target value. drotatex , drotatey , drotatez are relative rotation messages. dangle is equivalent to drotatez and is maintained only for compatibility reasons. dscale is similar to scale but the parameters represents a scale multiplying factor. Example Relative displacement of an object: /ITL/scene/myObject dx 0.1; Scene relative position An object position dan be relative to the scene dimensions (i.e. the scene width or height). sceneRelativePos ComplexDiagram( Sequence (Choice (0, 'x', 'y'), NonTerminal('float32'), Choice (0, 'sw', 'sh')) ).addTo() sw refers to the scene width. sh refers to the scene height. Example Putting on object on top of the scene (whatever its dimension): /ITL/scene/myObject x -1sh; Components origin The origin of a component is the point (xo, yo) such that the (x, y) coordinates and the (xo, yo) point coincide graphically. For example, when the origin is the top left corner, the component top left corner is drawn at the (x, y) coordinates. originMsg ComplexDiagram( Choice (0, Sequence ('xorigin', NonTerminal('float32')), Sequence ('yorigin', NonTerminal('float32')), Sequence ('dxorigin', NonTerminal('float32')), Sequence ('dyorigin', NonTerminal('float32'))) ).addTo() xorigin , yorigin are relative to the component coordinates space i.e. [-1,1] , where -1 is the top or left border and 1 is the bottom or right border. The default origin is [0,0] i.e. the component is centered on its (x,y) coordinates. dxorigin , dyorigin represents displacement of the current xorigin or yorigin . Example Setting an object graphic origin to the top left corner. /ITL/scene/myObject xorigin -1. ; /ITL/scene/myObject yorigin -1. ; Components transformations A component tranformation specifies 2D transformations of its coordinate system. It includes shear and object rotation on x, y and z axis. transformMsg ComplexDiagram( Choice (0, Sequence (Choice (0, 'rotatex', 'rotatey', 'rotatez'), NonTerminal('float32')), Sequence (Choice (0, 'drotatex', 'drotatey', 'drotatez'), NonTerminal('float32')), Sequence (Choice (0, 'shear', 'dshear'), NonTerminal('x'), NonTerminal('y'))) ).addTo() rotatex rotatey rotatez : rotates the component around the corresponding axis. Parameter value expresses the rotation in degrees. drotatex drotatey drotatez : relative rotations. shear transforms the component in x and y dimensions. x and y are float values expressing the transformation value in the corresponding dimension. Values should be in the range ]-1, 1[. dshear relative shear transformation. Example Rotating an object graphic on the z axis. /ITL/scene/myObject rotatez 90. ; Note: angle and rotatez are equivalent. angle has been introduced before the transformation messages and is maintained for compatibility reasons. Color messages ColorMsg ComplexDiagram( Choice (0, NonTerminal('absColorMsg'), NonTerminal('relColorMsg')) ).addTo() Color messages are absolute or relative color control messages. Color may be expressed in RGBA or HSBA or using a color name. Absolute color messages absColorMsg ComplexDiagram( Choice (0, NonTerminal('color'), NonTerminal('hsb'), Sequence ('red', NonTerminal('colorvalue')), Sequence ('green', NonTerminal('colorvalue')), Sequence ('blue', NonTerminal('colorvalue')), Sequence ('alpha', NonTerminal('colorvalue')), Sequence ('hue', NonTerminal('colorvalue')), Sequence ('saturation', NonTerminal('colorvalue')), Sequence ('brightness', NonTerminal('colorvalue'))) ).addTo() red , green , blue , hue , saturation , brightness , alpha messages address a specific part of a color using the RGB or HSB scheme. colorvalue ComplexDiagram( Choice (0, NonTerminal('int32'), NonTerminal('float32')) ).addTo() The value may be specified as integer or float. The data range is given in table colorrange . When the alpha component is not specified, the color is assumed to be opaque. Component integer range float range red [R] [0,255] [-1,1] green [G] [0,255] [-1,1] blue [B] [0,255] [-1,1] alpha [A] [0,255] [-1,1] hue [H] [0,360] [-1,1] mapped to [-180,180] saturation [S] [0,100] [-1,1] brightness [B] [0,100] [-1,1] Color components data ranges when expressed as integer or float. Example The same alpha channel specified as integer value or as floating point value: /ITL/scene/myObject alpha 51 ; /ITL/scene/myObject alpha 0.2 ; The color messages color ComplexDiagram( Sequence ('color', Choice (0, Sequence (Comment ('1'), Sequence ('r', 'g', 'b')), Sequence (Comment ('2'), Sequence ('r', 'g', 'b', 'a')), Sequence (Comment ('3'), 'name'), Sequence (Comment ('4'), 'hexValue'))) ).addTo() color sets an object color in the RGBA space. The color can be specified in different ways: 1 sets the color using RGB values. Alpha is not specified and the color is assumed to be opaque. 2 sets the color using RGBA values. 3 sets the color using a name among html defined names (see at https://www.w3schools.com/colors/colors_names.asp ). Name is not case sensitive. 4 sets the color using a single hexadecimal value in the form 0xrrggbb or 0xrrggbbaa . The default color value is [0,0,0,255] . The hsb messages hsb ComplexDiagram( Sequence ('hsb', Choice (0, Sequence ('h', 's', 'b'), Sequence ('h', 's', 'b', 'a'))) ).addTo() hsb sets an object color in the HSBA space. When A is not specified, the color is assumed to be opaque. Relative color messages relColorMsg ComplexDiagram( Choice (0, Sequence ('dcolor', NonTerminal('color')), Sequence ('dhsb', NonTerminal('hsb')), Sequence ('dred', NonTerminal('colorvalue')), Sequence ('dgreen', NonTerminal('colorvalue')), Sequence ('dblue', NonTerminal('colorvalue')), Sequence ('dhue', NonTerminal('colorvalue')), Sequence ('dsaturation', NonTerminal('colorvalue')), Sequence ('dbrightness', NonTerminal('colorvalue')), Sequence ('dalpha', NonTerminal('colorvalue'))) ).addTo() dred , dgreen , etc. messages are similar to red , green , etc. messages but the parameters values represent a displacement of the current target value. dcolor and dhsb are similar and each color parameter represents a displacement of the corresponding target value. Example Moving a color in the RGBA space: TL/scene/myObject dcolor 10 5 0 -10 , will increase the red component by 10, the blue component by 5, and decrease the transparency by 10. Note: Objects that are carrying color information (images, SVG) don't respond to color change but are sensitive to transparency changes. Pen control Pen messages accepted by all the components and result in 2 different behaviors: for components types rect | ellipse | polygon | curve | line | graph | fast graph | grid , it makes the object border visible using the pen attributes; for the other components and when the pen width is greater than 0, it makes the object bounding box visible. penMsg ComplexDiagram( Choice (0, Sequence ('penWidth', NonTerminal('float32')), Sequence ('penColor', NonTerminal('color')), Sequence ('penStyle', NonTerminal('penstyle')), Sequence ('penAlpha', NonTerminal('alphavalue')), Sequence ('pendAlpha', NonTerminal('alphavalue'))) ).addTo() penWidth controls the pen width. The default value is 0 (excepted for line objects, where 1.0 is the default value). It is expressed in arbitrary units (1 is a reasonable value). penColor controls the pen color. The color should be given in the RGBA space. The default value is opaque black (0 0 0 255). penStyle controls the pen style. penAlpha, pendAlpha controls the pen transparency only. See section colormsg for the expected penstyle ComplexDiagram( Choice (0, 'solid', 'dash', 'dot', 'dashDot', 'dashDotDot') ).addTo() The pen style default value is solid . Example Setting a rectangle border width and color: /ITL/scene/rect set rect 0.5 0.5 ; /ITL/scene/rect penWidth 2. ; /ITL/scene/rect penColor 255 0 0 ; The 'effect' messages The effect message sets a graphic effect on the target object. effectMsg ComplexDiagram( Sequence ('effect', Choice (0, 'none', Sequence (Choice (0, 'blur', 'colorize', 'shadow'), Optional ( NonTerminal('params'))))) ).addTo() none : removes any effect set on the target object. blur, colorize, shadow : sets the corresponding effect. An effect always replaces any previous effect. The effect name is followed by optional specific effects parameters. Note: An effect affects the target object but also all the target slaves. The blur effect blurParams ComplexDiagram( Sequence (NonTerminal('int32'), Optional ( NonTerminal('blurHint'))) ).addTo() Blur parameters are the blur radius and a rendering hint. The radius is an int32 value. By default, it is 5 pixels. The radius is given in device coordinates, meaning it is unaffected by scale. blurHint ComplexDiagram( Choice (0, 'performance', 'quality', 'animation') ).addTo() Use the performance hint to say that you want a faster blur, the quality hint to say that you prefer a higher quality blur, or the animation when you want to animate the blur radius. The default hint value is performance . Example Setting a 8 pixels effect on myObject /ITL/scene/myObject effect blur 8; The colorize effect colorizeParams ComplexDiagram( Sequence (NonTerminal('float32'), Optional ( NonTerminal('color'))) ).addTo() Colorize parameters are a strength and a tint color. The strength is a float value. By default, it is 1.0. A strength 0.0 equals to no effect, while 1.0 means full colorization. The color is given as a RGB triplet (see section colormsg ) by default, the color value is light blue (0, 0, 192). Example Setting a red colorize effect on myObject with a 0.5 strength. /ITL/scene/myObject effect colorize 0.5 200 0 0; The shadow effect shadowParams ComplexDiagram( Sequence (NonTerminal('xoffset'), NonTerminal('yoffset'), Optional ( Sequence (NonTerminal('color'), Optional ( NonTerminal('blur'))))) ).addTo() xoffset and yoffset are the shadow offset and should be given as int32 values. The default value is 8 pixels. The offset is given in device coordinates, which means it is unaffected by scale. The color is given as a RGBA color (see section colormsg ) by default, the color value is a semi-transparent dark gray (63, 63, 63, 180) The blur radius should be given as an int32 value. By default, the blur radius is 1 pixel. Example Setting a shadow effect on myObject . The shadow offset is (10,10) pixels, the color is a transparent grey (100,100,100, 50) and the blur is 8 pixels. /ITL/scene/myObject effect shadow 10 10 100 100 100 50 8; The 'edit' message The edit message opens a small editor that allows to edit the target object attributes. editMsg ComplexDiagram( Sequence ('edit', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('attributes'))), Sequence (Comment ('3'), NonTerminal('reset')))) ).addTo() 1 : without argument, the editor is initialized with all the target object attributes. 2 : using a list of attributes, the editor is initialized with the target object corresponding attributes. Note that set as attribute can be used to edit the object set message. 3 : reset is used to clear the edit string stored in the object cache. It is equivalent to the 'clear' button in the edit dialog. Note that as long as the edit string stored in the cache is not empty, edit messages are ignored unless followed by a reset (see below). Each object maintains the current content of the editor, that is initialized at first edit message or when this content is cleared. Successive call to edit will preserve the editor content unless it is cleared. Note: Since the editor preserves its content, it doesn't take account of changes that may result from received messages and thus may not reflect the target object changes. To synchronize the editor content with the current attributes values, you can clear the editor content, which will refresh the attributes to their current values. Note: Although initialized with the target object attributes, the editor supports arbitrary INScore messages, i.e. addressed to any other object or even making use of extended OSC addresses. Example Editing an object on double click: /ITL/scene/myObject watch doubleClick (/ITL/scene/myObject edit); Editing some specific attributes: /ITL/scene/myObject watch doubleClick (/ITL/scene/myObject edit x y);","title":"Common Messages"},{"location":"refs/3-common/#common-messages","text":"Common messages are intended to control the graphic and the time space of the components of a scene. They could be sent to any address with the form /ITL/ scene or /ITL/ scene /\\textit{identifier } where identifier is the unique identifier of a scene component. commonMsg ComplexDiagram( Choice (0, Sequence ('show', NonTerminal('int32')), 'del', Sequence ('lock', NonTerminal('int32')), Sequence (Choice (0, 'export', 'exportAll'), Choice (0, OneOrMore (Sequence (Comment ('1'), NonTerminal('filePath'))), Comment ('2'))), Sequence ('save', Optional ( OneOrMore ('message')), NonTerminal('filePath'), Optional ( '+')), NonTerminal('PositionMsg'), NonTerminal('ColorMsg'), NonTerminal('TimeMsg'), NonTerminal('WatchMsg'), NonTerminal('EventMsg')) ).addTo() show : shows or hides the destination object. The parameter is interpreted as a boolean value. Default value is 1 . del : deletes the destination object. lock : if not null, cancel any del message sent to this object. However, the object will still be deleted if one of its parents receives a del message. The parameter is interpreted as a boolean value. Default value is 0 . export and exportAll : exports an object to an image file respectively without or with its childrens. If the exported object is a scene, childrens are always exported. 1) exports to the filePath name. The filePath can be relative or absolute. When the filename is not specified, exports to path/ identifier .pdf . The file extension is used to infer the export format. Supported extensions and formats are: pdf, bmp, gif, jpeg, png, pgm, ppm, tiff, xbm, xpm . 2) exports to rootPath/ identifier .pdf . When the destination file is not completely specified (second form or missing extension), there is an automatic numbering of output names when the destination file already exists. save : recursively saves objects states to a file. When a message list is present, only the specified attributes are saved. The filePath can be relative or absolute. When relative, an absolute path is build using the current rootPath (see application or scene current paths p.\\pageref{applmgmt} and p.\\pageref{scene}). The optional + parameter indicates an append mode for the write operation. The message must be sent to the address /ITL to save the whole application state. 'PositionMsg' are absolute and relative position messages. 'ColorMsg' are absolute and relative color control messages. 'TimeMsg' are time management messages. They are described in section time . 'WatchMsg' are described in section interaction . 'EventMsg' are described in section eventMsg . Example Export of a scene to a given file as jpeg at the current root path: /ITL/scene export 'myexport.jpg'; Saving a scene to myScore.inscore at the current root path, the second form saves only the x , y and z attributes, the third form uses the append mode: /ITL/scene save 'myScore.inscore'; /ITL/scene save x y z 'thePositions.inscore'; /ITL/scene save 'myScore.inscore' '+'; Hiding an object: /ITL/scene/myObject show 0; Note: when a list of attributes is specified, unknown attributes are silently ignored.","title":"Common messages"},{"location":"refs/3-common/#positioning","text":"PositionMsg ComplexDiagram( Choice (0, NonTerminal('absPosMsg'), NonTerminal('relPosMsg'), NonTerminal('originMsg'), NonTerminal('transformMsg')) ).addTo() Graphic position messages are absolute position or relative position messages. They can also control an object origin and transformations like rotation around an axis.","title":"Positioning"},{"location":"refs/3-common/#absolute-positioning","text":"absPosMsg ComplexDiagram( Choice (0, Sequence ('x', NonTerminal('float32')), Sequence ('y', NonTerminal('float32')), Sequence ('z', NonTerminal('float32')), Sequence ('angle', NonTerminal('float32')), Sequence ('scale', NonTerminal('float32'))) ).addTo() x y : moves the x or y coordinate of a component. By default, components are centered on their x , y coordinates. The coordinates space range is [-1,1] . For a scene component, -1 is the leftmost or topmost position, 1 is the rightmost or bottommost position. [0,0] represents the center of the scene . For the scene itself, it moves the window in the screen space and the coordinate space is orthonormal, based on the screen lowest dimension ( i.e. with a 4:3 screen, y=-1 and y=1 are respectively the exact top and bottom of the screen, but neither x=-1 nor x=1 are the exact left and right of the screen). Default coordinates are [0,0] . z : sets the z order of a component. z order is actually relative to the scene components: objects of high z order will be drawn on top of components with a lower z order. Components sharing the same z order will be drawn in an undefined order, although the order will stay the same for as long as they live. Default z order is 0. angle : sets the angle value of a component, which is used to rotate it around its center. The angle is measured in clockwise degrees from the x axis. Default angle value is 0. scale : reduce/enlarge a component. Default scale is 1 . Example Moving and scaling an object: /ITL/scene/myObject x -0.9; /ITL/scene/myObject y 0.9; /ITL/scene/myObject scale 2.0;","title":"Absolute positioning"},{"location":"refs/3-common/#relative-positioning","text":"relPosMsg ComplexDiagram( Choice (0, Sequence ('dx', NonTerminal('float32')), Sequence ('dy', NonTerminal('float32')), Sequence ('dz', NonTerminal('float32')), Sequence ('drotatex', NonTerminal('float32')), Sequence ('drotatey', NonTerminal('float32')), Sequence ('drotatez', NonTerminal('float32')), Sequence ('dangle', NonTerminal('float32')), Sequence ('dscale', NonTerminal('float32'))) ).addTo() dx , dy , dz messages are similar to x , y , z but the parameters represent a displacement relative to the current target value. drotatex , drotatey , drotatez are relative rotation messages. dangle is equivalent to drotatez and is maintained only for compatibility reasons. dscale is similar to scale but the parameters represents a scale multiplying factor. Example Relative displacement of an object: /ITL/scene/myObject dx 0.1;","title":"Relative positioning"},{"location":"refs/3-common/#scene-relative-position","text":"An object position dan be relative to the scene dimensions (i.e. the scene width or height). sceneRelativePos ComplexDiagram( Sequence (Choice (0, 'x', 'y'), NonTerminal('float32'), Choice (0, 'sw', 'sh')) ).addTo() sw refers to the scene width. sh refers to the scene height. Example Putting on object on top of the scene (whatever its dimension): /ITL/scene/myObject x -1sh;","title":"Scene relative position"},{"location":"refs/3-common/#components-origin","text":"The origin of a component is the point (xo, yo) such that the (x, y) coordinates and the (xo, yo) point coincide graphically. For example, when the origin is the top left corner, the component top left corner is drawn at the (x, y) coordinates. originMsg ComplexDiagram( Choice (0, Sequence ('xorigin', NonTerminal('float32')), Sequence ('yorigin', NonTerminal('float32')), Sequence ('dxorigin', NonTerminal('float32')), Sequence ('dyorigin', NonTerminal('float32'))) ).addTo() xorigin , yorigin are relative to the component coordinates space i.e. [-1,1] , where -1 is the top or left border and 1 is the bottom or right border. The default origin is [0,0] i.e. the component is centered on its (x,y) coordinates. dxorigin , dyorigin represents displacement of the current xorigin or yorigin . Example Setting an object graphic origin to the top left corner. /ITL/scene/myObject xorigin -1. ; /ITL/scene/myObject yorigin -1. ;","title":"Components origin"},{"location":"refs/3-common/#components-transformations","text":"A component tranformation specifies 2D transformations of its coordinate system. It includes shear and object rotation on x, y and z axis. transformMsg ComplexDiagram( Choice (0, Sequence (Choice (0, 'rotatex', 'rotatey', 'rotatez'), NonTerminal('float32')), Sequence (Choice (0, 'drotatex', 'drotatey', 'drotatez'), NonTerminal('float32')), Sequence (Choice (0, 'shear', 'dshear'), NonTerminal('x'), NonTerminal('y'))) ).addTo() rotatex rotatey rotatez : rotates the component around the corresponding axis. Parameter value expresses the rotation in degrees. drotatex drotatey drotatez : relative rotations. shear transforms the component in x and y dimensions. x and y are float values expressing the transformation value in the corresponding dimension. Values should be in the range ]-1, 1[. dshear relative shear transformation. Example Rotating an object graphic on the z axis. /ITL/scene/myObject rotatez 90. ; Note: angle and rotatez are equivalent. angle has been introduced before the transformation messages and is maintained for compatibility reasons.","title":"Components transformations"},{"location":"refs/3-common/#color-messages","text":"ColorMsg ComplexDiagram( Choice (0, NonTerminal('absColorMsg'), NonTerminal('relColorMsg')) ).addTo() Color messages are absolute or relative color control messages. Color may be expressed in RGBA or HSBA or using a color name.","title":"Color messages"},{"location":"refs/3-common/#absolute-color-messages","text":"absColorMsg ComplexDiagram( Choice (0, NonTerminal('color'), NonTerminal('hsb'), Sequence ('red', NonTerminal('colorvalue')), Sequence ('green', NonTerminal('colorvalue')), Sequence ('blue', NonTerminal('colorvalue')), Sequence ('alpha', NonTerminal('colorvalue')), Sequence ('hue', NonTerminal('colorvalue')), Sequence ('saturation', NonTerminal('colorvalue')), Sequence ('brightness', NonTerminal('colorvalue'))) ).addTo() red , green , blue , hue , saturation , brightness , alpha messages address a specific part of a color using the RGB or HSB scheme. colorvalue ComplexDiagram( Choice (0, NonTerminal('int32'), NonTerminal('float32')) ).addTo() The value may be specified as integer or float. The data range is given in table colorrange . When the alpha component is not specified, the color is assumed to be opaque. Component integer range float range red [R] [0,255] [-1,1] green [G] [0,255] [-1,1] blue [B] [0,255] [-1,1] alpha [A] [0,255] [-1,1] hue [H] [0,360] [-1,1] mapped to [-180,180] saturation [S] [0,100] [-1,1] brightness [B] [0,100] [-1,1] Color components data ranges when expressed as integer or float. Example The same alpha channel specified as integer value or as floating point value: /ITL/scene/myObject alpha 51 ; /ITL/scene/myObject alpha 0.2 ;","title":"Absolute color messages"},{"location":"refs/3-common/#the-color-messages","text":"color ComplexDiagram( Sequence ('color', Choice (0, Sequence (Comment ('1'), Sequence ('r', 'g', 'b')), Sequence (Comment ('2'), Sequence ('r', 'g', 'b', 'a')), Sequence (Comment ('3'), 'name'), Sequence (Comment ('4'), 'hexValue'))) ).addTo() color sets an object color in the RGBA space. The color can be specified in different ways: 1 sets the color using RGB values. Alpha is not specified and the color is assumed to be opaque. 2 sets the color using RGBA values. 3 sets the color using a name among html defined names (see at https://www.w3schools.com/colors/colors_names.asp ). Name is not case sensitive. 4 sets the color using a single hexadecimal value in the form 0xrrggbb or 0xrrggbbaa . The default color value is [0,0,0,255] .","title":"The color messages"},{"location":"refs/3-common/#the-hsb-messages","text":"hsb ComplexDiagram( Sequence ('hsb', Choice (0, Sequence ('h', 's', 'b'), Sequence ('h', 's', 'b', 'a'))) ).addTo() hsb sets an object color in the HSBA space. When A is not specified, the color is assumed to be opaque.","title":"The hsb messages"},{"location":"refs/3-common/#relative-color-messages","text":"relColorMsg ComplexDiagram( Choice (0, Sequence ('dcolor', NonTerminal('color')), Sequence ('dhsb', NonTerminal('hsb')), Sequence ('dred', NonTerminal('colorvalue')), Sequence ('dgreen', NonTerminal('colorvalue')), Sequence ('dblue', NonTerminal('colorvalue')), Sequence ('dhue', NonTerminal('colorvalue')), Sequence ('dsaturation', NonTerminal('colorvalue')), Sequence ('dbrightness', NonTerminal('colorvalue')), Sequence ('dalpha', NonTerminal('colorvalue'))) ).addTo() dred , dgreen , etc. messages are similar to red , green , etc. messages but the parameters values represent a displacement of the current target value. dcolor and dhsb are similar and each color parameter represents a displacement of the corresponding target value. Example Moving a color in the RGBA space: TL/scene/myObject dcolor 10 5 0 -10 , will increase the red component by 10, the blue component by 5, and decrease the transparency by 10. Note: Objects that are carrying color information (images, SVG) don't respond to color change but are sensitive to transparency changes.","title":"Relative color messages"},{"location":"refs/3-common/#pen-control","text":"Pen messages accepted by all the components and result in 2 different behaviors: for components types rect | ellipse | polygon | curve | line | graph | fast graph | grid , it makes the object border visible using the pen attributes; for the other components and when the pen width is greater than 0, it makes the object bounding box visible. penMsg ComplexDiagram( Choice (0, Sequence ('penWidth', NonTerminal('float32')), Sequence ('penColor', NonTerminal('color')), Sequence ('penStyle', NonTerminal('penstyle')), Sequence ('penAlpha', NonTerminal('alphavalue')), Sequence ('pendAlpha', NonTerminal('alphavalue'))) ).addTo() penWidth controls the pen width. The default value is 0 (excepted for line objects, where 1.0 is the default value). It is expressed in arbitrary units (1 is a reasonable value). penColor controls the pen color. The color should be given in the RGBA space. The default value is opaque black (0 0 0 255). penStyle controls the pen style. penAlpha, pendAlpha controls the pen transparency only. See section colormsg for the expected penstyle ComplexDiagram( Choice (0, 'solid', 'dash', 'dot', 'dashDot', 'dashDotDot') ).addTo() The pen style default value is solid . Example Setting a rectangle border width and color: /ITL/scene/rect set rect 0.5 0.5 ; /ITL/scene/rect penWidth 2. ; /ITL/scene/rect penColor 255 0 0 ;","title":"Pen control"},{"location":"refs/3-common/#the-effect-messages","text":"The effect message sets a graphic effect on the target object. effectMsg ComplexDiagram( Sequence ('effect', Choice (0, 'none', Sequence (Choice (0, 'blur', 'colorize', 'shadow'), Optional ( NonTerminal('params'))))) ).addTo() none : removes any effect set on the target object. blur, colorize, shadow : sets the corresponding effect. An effect always replaces any previous effect. The effect name is followed by optional specific effects parameters. Note: An effect affects the target object but also all the target slaves.","title":"The 'effect' messages"},{"location":"refs/3-common/#the-blur-effect","text":"blurParams ComplexDiagram( Sequence (NonTerminal('int32'), Optional ( NonTerminal('blurHint'))) ).addTo() Blur parameters are the blur radius and a rendering hint. The radius is an int32 value. By default, it is 5 pixels. The radius is given in device coordinates, meaning it is unaffected by scale. blurHint ComplexDiagram( Choice (0, 'performance', 'quality', 'animation') ).addTo() Use the performance hint to say that you want a faster blur, the quality hint to say that you prefer a higher quality blur, or the animation when you want to animate the blur radius. The default hint value is performance . Example Setting a 8 pixels effect on myObject /ITL/scene/myObject effect blur 8;","title":"The blur effect"},{"location":"refs/3-common/#the-colorize-effect","text":"colorizeParams ComplexDiagram( Sequence (NonTerminal('float32'), Optional ( NonTerminal('color'))) ).addTo() Colorize parameters are a strength and a tint color. The strength is a float value. By default, it is 1.0. A strength 0.0 equals to no effect, while 1.0 means full colorization. The color is given as a RGB triplet (see section colormsg ) by default, the color value is light blue (0, 0, 192). Example Setting a red colorize effect on myObject with a 0.5 strength. /ITL/scene/myObject effect colorize 0.5 200 0 0;","title":"The colorize effect"},{"location":"refs/3-common/#the-shadow-effect","text":"shadowParams ComplexDiagram( Sequence (NonTerminal('xoffset'), NonTerminal('yoffset'), Optional ( Sequence (NonTerminal('color'), Optional ( NonTerminal('blur'))))) ).addTo() xoffset and yoffset are the shadow offset and should be given as int32 values. The default value is 8 pixels. The offset is given in device coordinates, which means it is unaffected by scale. The color is given as a RGBA color (see section colormsg ) by default, the color value is a semi-transparent dark gray (63, 63, 63, 180) The blur radius should be given as an int32 value. By default, the blur radius is 1 pixel. Example Setting a shadow effect on myObject . The shadow offset is (10,10) pixels, the color is a transparent grey (100,100,100, 50) and the blur is 8 pixels. /ITL/scene/myObject effect shadow 10 10 100 100 100 50 8;","title":"The shadow effect"},{"location":"refs/3-common/#the-edit-message","text":"The edit message opens a small editor that allows to edit the target object attributes. editMsg ComplexDiagram( Sequence ('edit', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('attributes'))), Sequence (Comment ('3'), NonTerminal('reset')))) ).addTo() 1 : without argument, the editor is initialized with all the target object attributes. 2 : using a list of attributes, the editor is initialized with the target object corresponding attributes. Note that set as attribute can be used to edit the object set message. 3 : reset is used to clear the edit string stored in the object cache. It is equivalent to the 'clear' button in the edit dialog. Note that as long as the edit string stored in the cache is not empty, edit messages are ignored unless followed by a reset (see below). Each object maintains the current content of the editor, that is initialized at first edit message or when this content is cleared. Successive call to edit will preserve the editor content unless it is cleared. Note: Since the editor preserves its content, it doesn't take account of changes that may result from received messages and thus may not reflect the target object changes. To synchronize the editor content with the current attributes values, you can clear the editor content, which will refresh the attributes to their current values. Note: Although initialized with the target object attributes, the editor supports arbitrary INScore messages, i.e. addressed to any other object or even making use of extended OSC addresses. Example Editing an object on double click: /ITL/scene/myObject watch doubleClick (/ITL/scene/myObject edit); Editing some specific attributes: /ITL/scene/myObject watch doubleClick (/ITL/scene/myObject edit x y);","title":"The 'edit' message"},{"location":"refs/4-time/","text":"Time management messages Date and duration Time messages control the time dimension of the score components. They could be sent to any address with the form /ITL/ scene /\\textit{identifier } where identifier is the unique identifier string of a scene component. timeMsg ComplexDiagram( Choice (0, 'clock', 'durClock', Sequence ('date', NonTerminal('time')), Sequence ('duration', NonTerminal('time')), Sequence ('ddate', NonTerminal('time')), Sequence ('dduration', NonTerminal('time'))) ).addTo() time ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('int32'), NonTerminal('int32')), Sequence (Comment ('2'), NonTerminal('int32')), Sequence (Comment ('3'), NonTerminal('float32')), Sequence (Comment ('4'), 'n/d')) ).addTo() 1) Time is specified as a rational value d/n where 1/1 represents a whole note. 2) Time may be specified with a single integer, then 1 is used as implicit denominator value. 3) Time may be specified as a single float value that is converted using the following approximation: let f be the floating point date, the corresponding rational date is computed as f x 10000 / 10000 . 4) Time may also be specified as a string in the form 'n/d' . clock : similar to MIDI clock message: advances the object date by 1/24 of quarter note. durClock : a clock message applied to duration: increases the object duration by 1/24 of quarter note. date : sets the time position of an object. Default value is 0/1 . duration : changes the object duration. Default value is 1/1 . ddate : relative time positioning message: adds the specified value to the object date. dduration : relative duration message: adds the specified value to the object duration. Example Various ways to set an object date. /ITL/scene/myObject date 2 1 ; /ITL/scene/myObject date 2; # the denominator is 1 (implied) /ITL/scene/myObject date 0.5; # equivalent to 1/2 /ITL/scene/myObject date '1/2'; # the string form Similar ways to move an object date. /ITL/scene/myObject clock; /ITL/scene/myObject ddate '1/96'; Date queries Several formats are available to query the date of an object: dateQuery ComplexDiagram( Sequence ('get', Choice (0, 'date', 'date%f', 'date%a')) ).addTo() date : gives the object date as a rational value. date%f : gives the object date as a float value. date%a : gives the object date as an absolute time. It assumes that the tempo is 60bpm. Tempo The tempo message is supported by all the score components. Its default value is 0. When non null, the date of an object is moved at the corresponding tempo (e.g. with a tempo = 60, the date move will be 1/4 - a quarter note - every second). Note that the date is refreshed at INScore time task rate. tempoMsg ComplexDiagram( Choice (0, Sequence ('tempo', NonTerminal('val')), Sequence ('dtempo', NonTerminal('val'))) ).addTo() tempo : set an object tempo. Default value is 0. dtempo : relative tempo message: adds the specified value to the object tempo. Example A cursor moving over a score using the tempo message. /ITL/scene/score set gmn \"[a a a a a a]\"; # a short score /ITL/scene/cursor set ellipse 0.5 0.5; # a cursor /ITL/scene/sync cursor score; # synchonizes the cursor to the score /ITL/scene/cursor tempo 80; # an set the tempo","title":"Time Messages"},{"location":"refs/4-time/#time-management-messages","text":"","title":"Time management messages"},{"location":"refs/4-time/#date-and-duration","text":"Time messages control the time dimension of the score components. They could be sent to any address with the form /ITL/ scene /\\textit{identifier } where identifier is the unique identifier string of a scene component. timeMsg ComplexDiagram( Choice (0, 'clock', 'durClock', Sequence ('date', NonTerminal('time')), Sequence ('duration', NonTerminal('time')), Sequence ('ddate', NonTerminal('time')), Sequence ('dduration', NonTerminal('time'))) ).addTo() time ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('int32'), NonTerminal('int32')), Sequence (Comment ('2'), NonTerminal('int32')), Sequence (Comment ('3'), NonTerminal('float32')), Sequence (Comment ('4'), 'n/d')) ).addTo() 1) Time is specified as a rational value d/n where 1/1 represents a whole note. 2) Time may be specified with a single integer, then 1 is used as implicit denominator value. 3) Time may be specified as a single float value that is converted using the following approximation: let f be the floating point date, the corresponding rational date is computed as f x 10000 / 10000 . 4) Time may also be specified as a string in the form 'n/d' . clock : similar to MIDI clock message: advances the object date by 1/24 of quarter note. durClock : a clock message applied to duration: increases the object duration by 1/24 of quarter note. date : sets the time position of an object. Default value is 0/1 . duration : changes the object duration. Default value is 1/1 . ddate : relative time positioning message: adds the specified value to the object date. dduration : relative duration message: adds the specified value to the object duration. Example Various ways to set an object date. /ITL/scene/myObject date 2 1 ; /ITL/scene/myObject date 2; # the denominator is 1 (implied) /ITL/scene/myObject date 0.5; # equivalent to 1/2 /ITL/scene/myObject date '1/2'; # the string form Similar ways to move an object date. /ITL/scene/myObject clock; /ITL/scene/myObject ddate '1/96';","title":"Date and duration"},{"location":"refs/4-time/#date-queries","text":"Several formats are available to query the date of an object: dateQuery ComplexDiagram( Sequence ('get', Choice (0, 'date', 'date%f', 'date%a')) ).addTo() date : gives the object date as a rational value. date%f : gives the object date as a float value. date%a : gives the object date as an absolute time. It assumes that the tempo is 60bpm.","title":"Date queries"},{"location":"refs/4-time/#tempo","text":"The tempo message is supported by all the score components. Its default value is 0. When non null, the date of an object is moved at the corresponding tempo (e.g. with a tempo = 60, the date move will be 1/4 - a quarter note - every second). Note that the date is refreshed at INScore time task rate. tempoMsg ComplexDiagram( Choice (0, Sequence ('tempo', NonTerminal('val')), Sequence ('dtempo', NonTerminal('val'))) ).addTo() tempo : set an object tempo. Default value is 0. dtempo : relative tempo message: adds the specified value to the object tempo. Example A cursor moving over a score using the tempo message. /ITL/scene/score set gmn \"[a a a a a a]\"; # a short score /ITL/scene/cursor set ellipse 0.5 0.5; # a cursor /ITL/scene/sync cursor score; # synchonizes the cursor to the score /ITL/scene/cursor tempo 80; # an set the tempo","title":"Tempo"},{"location":"refs/5-miscmsgs/","text":"Miscellaneous messages The following messages are supported by all the objects. They are detailed in specific sections. miscMsgs ComplexDiagram( Choice (0, Sequence (\"eval\", NonTerminal('msgsList')), Sequence (\"watch\", Optional ( Sequence (NonTerminal('what'), Optional ( NonTerminal('msgsList'))))), \"push\", \"pop\", Sequence (\"map\", Optional ( NonTerminal('mapName')), Choice (0, NonTerminal('relation'), NonTerminal('del')))) ).addTo() eval : evaluates a list of messages in the context of the receiver object. The messages can used relative OSC addresses i.e. addresses that start with a dot ('.'). In this case, the leading '.' is replaced by the receiver OSC address. watch : used to manage the object interaction with various events. See section interaction for more details. push , pop : saves and restores the object interaction state. See section evtstate for more details. map : used to describe the relations between graphic and time spaces. See section mapping for more details.","title":"Miscellaneous"},{"location":"refs/5-miscmsgs/#miscellaneous-messages","text":"The following messages are supported by all the objects. They are detailed in specific sections. miscMsgs ComplexDiagram( Choice (0, Sequence (\"eval\", NonTerminal('msgsList')), Sequence (\"watch\", Optional ( Sequence (NonTerminal('what'), Optional ( NonTerminal('msgsList'))))), \"push\", \"pop\", Sequence (\"map\", Optional ( NonTerminal('mapName')), Choice (0, NonTerminal('relation'), NonTerminal('del')))) ).addTo() eval : evaluates a list of messages in the context of the receiver object. The messages can used relative OSC addresses i.e. addresses that start with a dot ('.'). In this case, the leading '.' is replaced by the receiver OSC address. watch : used to manage the object interaction with various events. See section interaction for more details. push , pop : saves and restores the object interaction state. See section evtstate for more details. map : used to describe the relations between graphic and time spaces. See section mapping for more details.","title":"Miscellaneous messages"},{"location":"refs/6-setsect/","text":"The 'set' message The set messages can be sent to any address with the form /ITL/scene/ identifier . The global form of the message is: setMsg ComplexDiagram( Sequence ('set', NonTerminal('type'), NonTerminal('data')) ).addTo() It sets a scene component data. When there is no destination for the OSC address, the component is first created before being given the message. When the target destination type doesn't correspond to the message type , the object is replaced by an adequate object. Symbolic music notation Symbolic music notation support is based on the Guido Music Notation format [GMN] or on the MusicXML format. MusicXMl is supported via conversion to the GMN format when the MusicXML library is present. setScore ComplexDiagram( Sequence ('set', Choice (0, Sequence ('gmn', NonTerminal('gmnString')), Sequence ('gmnf', NonTerminal('gmnFilePath')), Sequence ('gmnstream', NonTerminal('gmnStream')), Sequence ('musicxml', NonTerminal('xmlString')), Sequence ('musicxmlf', NonTerminal('xmlFilePath')), Sequence ('gmn', 'expr', NonTerminal('scoreExpression')))) ).addTo() gmn : a Guido score defined by a GMN string. gmnf : a Guido score defined by a GMN file. gmnstream : a Guido score defined by a GMN stream (a GMN string that can be written in several times). musicxml : a score defined by a MusicXML string. musicxmlf : a score defined by a MusicXML file. gmn expr : a score defined by a score expression . See section scoreExpr for the score expressions reference. Example Creating a music score using a Guido Music Notation language string. /ITL/scene/myObject set gmn \"[ a b g ]\"; Creating the same music score as a stream. /ITL/scene/myObject set gmnstream \"[ a\"; /ITL/scene/myObject write \"b\"; /ITL/scene/myObject write \"g\"; Note: For compatibility with previous versions, passing a MusicXML string to a gmn object or a MusicXML file to a gmnf object may succed since the system tries to parse the content as GMN content or as MusicXML content when the former fails. Note: Conversion from MusicXML to GMN could be achieved manually using a command line tool that is distributed with the MusicXML library (see at https://github.com/dfober/libmusicxml ). It allows to improve the output GMN code afterhand. Piano roll music notation Piano roll music notation is based on the Guido Music Notation format [GMN]. setPianoRoll ComplexDiagram( Sequence ('set', Choice (0, Sequence ('pianoroll', NonTerminal('gmnString')), Sequence ('pianorollstream', NonTerminal('gmnStream')), Sequence ('pianorollf', NonTerminal('filePath')), Sequence ('pianoroll', 'expr', NonTerminal('scoreExpression')))) ).addTo() pianoroll : a piano roll defined by a GMN string. pianorollstream : a piano roll defined by a GMN stream (a GMN string that can be written in several times). pianorollf : a piano roll defined by a guido file (with \".gmn\" extension) or by a midi file (with \".mid\" extension). Warning: url forms are not supported for midi files. pianoroll expr : a piano roll defined by a score expression . See section scoreExpr for the score expressions reference. Example Creating a pianoroll using a Guido Music Notation language string. /ITL/scene/myObject set pianoroll \"[ a b g ]\"; Creating the same piano roll as a stream. /ITL/scene/myObject set pianorollstream \"[ a\"; /ITL/scene/myObject write \"b\"; /ITL/scene/myObject write \"g\"; Textual components setText ComplexDiagram( Sequence ('set', Choice (0, Sequence ('txt', Choice (0, NonTerminal('string'), NonTerminal('txtStream'))), Sequence ('txtf', NonTerminal('textFilePath')), Sequence ('html', NonTerminal('string')), Sequence ('htmlf', NonTerminal('htmlFilePath')))) ).addTo() txt : a textual component. txtf : a textual component defined by a file. html : an html component defined by an HTML string. htmlf : an html component defined by an HTML file. Text may be specified by a single quoted string or using an arbitrary count of parameters that are converted to a single string with a space used as separator. txtStream ComplexDiagram( OneOrMore (Choice (0, NonTerminal('string'), NonTerminal('int32'), NonTerminal('float32'))) ).addTo() Example Creating a text object. /ITL/scene/myObject set txt \"Hello ... world!\"; Setting the content of a text object using a values stream. /ITL/scene/myObject set txt Hello 1 world and 0.5; Vectorial graphics setVGraphics ComplexDiagram( Sequence ('set', Choice (0, Sequence ('svg', NonTerminal('svgString')), Sequence ('svgf', NonTerminal('svgFilePath')), Sequence ('rect', NonTerminal('width'), NonTerminal('height')), Sequence ('ellipse', NonTerminal('width'), NonTerminal('height')), Sequence ('polygon', OneOrMore (Sequence (NonTerminal('x'), NonTerminal('y')))), Sequence ('curve', OneOrMore (Sequence (NonTerminal('x1'), NonTerminal('y1'), NonTerminal('x2'), NonTerminal('y2'), NonTerminal('x3'), NonTerminal('y3'), NonTerminal('x4'), NonTerminal('y4')))), Sequence ('arc', NonTerminal('width'), NonTerminal('height'), NonTerminal('startAngle'), NonTerminal('endAngle')), Sequence ('line', Choice (0, Sequence ('xy', NonTerminal('x'), NonTerminal('y')), Sequence ('wa', NonTerminal('width'), NonTerminal('angle')))))) ).addTo() svg : SVG graphics defined by a SVG string. svgf : vectorial graphics defined by a SVG file. rect : a rectangle specified by a width and height. Width and height are expressed in scene coordinates space, thus a width or a height of 2 corresponds to the width or a height of the scene . ellipse : an ellipse specified by a width and height. polygon : a polygon specified by a sequence of points, each point being defined by its (x,y) coordinates. The coordinates are expressed in the scene coordinate space, but only the relative position of the points is taken into account ( i.e a polygon A = { (0,0) ; (1,1) ; (0,1) } is equivalent to a polygon B = { (1,1) ; (2,2) ; (1,2) }). curve : a sequence of 4-points bezier cubic curve. If the end-point of a curve doesn't match the start-point of the following one, the curves are linked by a straight line. The first curve follows the last curve. The inner space defined by the sequence of curves is filled, using the object color. The points coordinates are handled like in a polygon . arc : an arc defined by its enclosing rectangle and the start and end angles. Angles are in degrees and express counter-clockwise directions. line : a simple line specified by a point (x,y) expressed in scene coordinate space or by a width and angle. The point form is used to compute a line from (0,0) to (x,y), which is next drawn centered on the scene. Note: Width and/or height parameters can be expressed as float values or as scene relative values. See section whcontrol . Example Creating a rectangle with a 0.5 width and a 1.5 height. /ITL/scene/myObject set rect 0.5 1.5; Creating a line specified using width and angle. /ITL/scene/myObject set line wa 1. 45.; Signals and graphic signals Signals are special objects that are stored in a special signal node and that may be composed in parallel to produce graphic signals. Signals and graphic signals are decribed in section graphsig . Signals and computation on signals may be based on FAUST objects that are actually signals processors. FAUST objects are decribed in section faust . For more information about the FAUST language, see at http://faust.grame.fr . setGraphicSignal ComplexDiagram( Sequence ('set', Choice (0, Sequence ('graph', NonTerminal('signals')), Sequence ('fastgraph', NonTerminal('signals')), Sequence ('faust', 'pluginname'), Sequence ('faustdsp', NonTerminal('faustcode')), Sequence ('faustdspf', NonTerminal('faustfile')))) ).addTo() graph : graphic of a signal. See section graphsig for details about the graph objects data. fastgraph : fast rendering graphic signal. See also section graphsig . faust : a FAUST object as a plugin (see section faust ) faustdsp : a FAUST object defined by a string (see section faust ) faustdspf : a FAUST object defined by a file (see section faust ) Media files Images, video and audio are supported using various formats. See section fileset for more details on the supported formats. setMedia ComplexDiagram( Choice (0, Sequence ('img', NonTerminal('imgPath')), Sequence ('memimg', NonTerminal('objectPath')), Sequence ('video', NonTerminal('videoPath')), Sequence ('audio', NonTerminal('audioPath'))) ).addTo() img : an image file. The image format is inferred from the file extension. memimg : a memory capture of the object given as argument. objectPath indicates the target object that is captured with all its childrens. It may be an object name or a path to an object. Simple object names and relative path are looked for in the receiver layer. video : a video file. The video format is inferred from the file extension. Note that navigation through the video is made using its date . audio : an audio file. The audio format is inferred from the file extension. audio objects appear as a waveform but this waveforom is not (yet) computed from the audio data but randomly generated. Example Creating an image. /ITL/scene/myObject set img \"myImage.png\"; Creating a memory image of a scene. /ITL/scene/myObject set memimg \"/ITL/scene\"; Note: It is necessary to have an object or scene graphically rendered before a capture can be made. Since the actual graphic rendering is made asynchronously to the model update, a sequence of messages like the following: /ITL/scene/myObject set gmn \"[a f g]\"; /ITL/scene/capture set memimg myObject; won't work if the messages are handled by the same time task. A delay is necessary between the two messages. To make sure all the objects have been rendered, you can use the scene endPaint event. Miscellaneous setMisc ComplexDiagram( Sequence ('set', Choice (0, 'layer', Sequence ('grid', NonTerminal('int32'), NonTerminal('int32')))) ).addTo() layer : a graphic layer, may be viewed as a container (see section layers ). grid : a white transparent object that provides a predefined time to graphic mapping (see section grid for more details and section mapping for time to graphic relations). The parameters are int32 values representing the number of columns and rows. File based resources Most of the types can be either expressed with the corresponding data, or by a path to a file containing the data. For the latter form, the object type is generally suffixed with an 'f' (e.g. txtf , htmlf , gmnf , musicxmlf , svgf , faustf ). The img , audio and video types have only a file form (and no 'f' suffix). A file path can be expressed as a Unix path (absolute or relative - see the scene or application rootPath message for relative paths handling), but also as an URL. Only the http: protocol is currently supported. When the system encounters an URL, it creates an intermediate object that is in charge of retrieving the corresponding data. This object has a specific url type that takes the target type and an url as arguments. It has a graphic appearance (actually a light gray box containing the object name and the target url) that can be controled like for any regular object. urlType ComplexDiagram( Sequence ('url', NonTerminal('targetType'), NonTerminal('urlPath')) ).addTo() The url intermediate object acts as a proxy for the target object and will transfer all its properties once the data are ready. A client can thus interact transparently with the target adress, whatever the status of the download request. Example Creating a score using an URL: /ITL/scene/score set gmnf \"http://anyhost.adomain.org/score.gmn\"; # is equivalent to /ITL/scene/score set url gmnf \"http://anyhost.adomain.org/score.gmn\"; Note: The url object handles specific events : success , error and cancel (see the section urlevents ). The file type setFile ComplexDiagram( Sequence ('file', Choice (0, NonTerminal('filePath'), NonTerminal('urlPath'))) ).addTo() file : a generic type to handle file based objects. Actually, the file type is translated into a one of the txtf , gmnf , img , audio or video types, according to the file extension (see table fileTranslate ). See also: the application rootPath message (section ITL ) for file based objects. file extension translated type .txt .text txtf .htm .html htmlf .gmn gmnf .xml musicxmlf .svg svgf .jpg .jpeg .png .gif .bmp .tiff img .avi .wmv .mpg .mpeg .mp4 .mov .vob video .mp3 .wav .aiff .aif, .m4a, .aac audio .dsp faustdspf File extensions supported by the file translation scheme. Example Creating an image using the file type. /ITL/scene/myObject set file \"myImage.png\"; # is equivalent to /ITL/scene/myObject set img \"myImage.png\"; Web objects A score can make its content available to the Internet using specific components that provide an image of the scene over http or websocket protocols. The httpd server depends on the Httpd server plugin and is described in section Httpd . The websocket server provides a two-ways communication between INScore and distant clients. The server sends notifications to client using a Screen updated text message when the scene is updated. Clients can request an image by sending a getImage text message to the server. The server responds with a image of the scene in png format, using a Blob type javascript object. webobject ComplexDiagram( Choice (0, Sequence ('websocket', NonTerminal('port'), NonTerminal('frequency')), Sequence ('httpd', NonTerminal('port'))) ).addTo() port : a port number for the socket communication. frequency : a minimum time in millisecond between two Screen updated notifications. Note: A busy port prevents the server to start. The server status can be checked with the get status message. Example Creating an websocket server using the port 1234 and limiting the notifications rate to one per 500 milliseconds. /ITL/scene/myObject set websocket 1234 500; See also: the http web server plugin (section Httpd ).","title":"The set Message"},{"location":"refs/6-setsect/#the-set-message","text":"The set messages can be sent to any address with the form /ITL/scene/ identifier . The global form of the message is: setMsg ComplexDiagram( Sequence ('set', NonTerminal('type'), NonTerminal('data')) ).addTo() It sets a scene component data. When there is no destination for the OSC address, the component is first created before being given the message. When the target destination type doesn't correspond to the message type , the object is replaced by an adequate object.","title":"The 'set' message"},{"location":"refs/6-setsect/#symbolic-music-notation","text":"Symbolic music notation support is based on the Guido Music Notation format [GMN] or on the MusicXML format. MusicXMl is supported via conversion to the GMN format when the MusicXML library is present. setScore ComplexDiagram( Sequence ('set', Choice (0, Sequence ('gmn', NonTerminal('gmnString')), Sequence ('gmnf', NonTerminal('gmnFilePath')), Sequence ('gmnstream', NonTerminal('gmnStream')), Sequence ('musicxml', NonTerminal('xmlString')), Sequence ('musicxmlf', NonTerminal('xmlFilePath')), Sequence ('gmn', 'expr', NonTerminal('scoreExpression')))) ).addTo() gmn : a Guido score defined by a GMN string. gmnf : a Guido score defined by a GMN file. gmnstream : a Guido score defined by a GMN stream (a GMN string that can be written in several times). musicxml : a score defined by a MusicXML string. musicxmlf : a score defined by a MusicXML file. gmn expr : a score defined by a score expression . See section scoreExpr for the score expressions reference. Example Creating a music score using a Guido Music Notation language string. /ITL/scene/myObject set gmn \"[ a b g ]\"; Creating the same music score as a stream. /ITL/scene/myObject set gmnstream \"[ a\"; /ITL/scene/myObject write \"b\"; /ITL/scene/myObject write \"g\"; Note: For compatibility with previous versions, passing a MusicXML string to a gmn object or a MusicXML file to a gmnf object may succed since the system tries to parse the content as GMN content or as MusicXML content when the former fails. Note: Conversion from MusicXML to GMN could be achieved manually using a command line tool that is distributed with the MusicXML library (see at https://github.com/dfober/libmusicxml ). It allows to improve the output GMN code afterhand.","title":"Symbolic music notation"},{"location":"refs/6-setsect/#piano-roll-music-notation","text":"Piano roll music notation is based on the Guido Music Notation format [GMN]. setPianoRoll ComplexDiagram( Sequence ('set', Choice (0, Sequence ('pianoroll', NonTerminal('gmnString')), Sequence ('pianorollstream', NonTerminal('gmnStream')), Sequence ('pianorollf', NonTerminal('filePath')), Sequence ('pianoroll', 'expr', NonTerminal('scoreExpression')))) ).addTo() pianoroll : a piano roll defined by a GMN string. pianorollstream : a piano roll defined by a GMN stream (a GMN string that can be written in several times). pianorollf : a piano roll defined by a guido file (with \".gmn\" extension) or by a midi file (with \".mid\" extension). Warning: url forms are not supported for midi files. pianoroll expr : a piano roll defined by a score expression . See section scoreExpr for the score expressions reference. Example Creating a pianoroll using a Guido Music Notation language string. /ITL/scene/myObject set pianoroll \"[ a b g ]\"; Creating the same piano roll as a stream. /ITL/scene/myObject set pianorollstream \"[ a\"; /ITL/scene/myObject write \"b\"; /ITL/scene/myObject write \"g\";","title":"Piano roll music notation"},{"location":"refs/6-setsect/#textual-components","text":"setText ComplexDiagram( Sequence ('set', Choice (0, Sequence ('txt', Choice (0, NonTerminal('string'), NonTerminal('txtStream'))), Sequence ('txtf', NonTerminal('textFilePath')), Sequence ('html', NonTerminal('string')), Sequence ('htmlf', NonTerminal('htmlFilePath')))) ).addTo() txt : a textual component. txtf : a textual component defined by a file. html : an html component defined by an HTML string. htmlf : an html component defined by an HTML file. Text may be specified by a single quoted string or using an arbitrary count of parameters that are converted to a single string with a space used as separator. txtStream ComplexDiagram( OneOrMore (Choice (0, NonTerminal('string'), NonTerminal('int32'), NonTerminal('float32'))) ).addTo() Example Creating a text object. /ITL/scene/myObject set txt \"Hello ... world!\"; Setting the content of a text object using a values stream. /ITL/scene/myObject set txt Hello 1 world and 0.5;","title":"Textual components"},{"location":"refs/6-setsect/#vectorial-graphics","text":"setVGraphics ComplexDiagram( Sequence ('set', Choice (0, Sequence ('svg', NonTerminal('svgString')), Sequence ('svgf', NonTerminal('svgFilePath')), Sequence ('rect', NonTerminal('width'), NonTerminal('height')), Sequence ('ellipse', NonTerminal('width'), NonTerminal('height')), Sequence ('polygon', OneOrMore (Sequence (NonTerminal('x'), NonTerminal('y')))), Sequence ('curve', OneOrMore (Sequence (NonTerminal('x1'), NonTerminal('y1'), NonTerminal('x2'), NonTerminal('y2'), NonTerminal('x3'), NonTerminal('y3'), NonTerminal('x4'), NonTerminal('y4')))), Sequence ('arc', NonTerminal('width'), NonTerminal('height'), NonTerminal('startAngle'), NonTerminal('endAngle')), Sequence ('line', Choice (0, Sequence ('xy', NonTerminal('x'), NonTerminal('y')), Sequence ('wa', NonTerminal('width'), NonTerminal('angle')))))) ).addTo() svg : SVG graphics defined by a SVG string. svgf : vectorial graphics defined by a SVG file. rect : a rectangle specified by a width and height. Width and height are expressed in scene coordinates space, thus a width or a height of 2 corresponds to the width or a height of the scene . ellipse : an ellipse specified by a width and height. polygon : a polygon specified by a sequence of points, each point being defined by its (x,y) coordinates. The coordinates are expressed in the scene coordinate space, but only the relative position of the points is taken into account ( i.e a polygon A = { (0,0) ; (1,1) ; (0,1) } is equivalent to a polygon B = { (1,1) ; (2,2) ; (1,2) }). curve : a sequence of 4-points bezier cubic curve. If the end-point of a curve doesn't match the start-point of the following one, the curves are linked by a straight line. The first curve follows the last curve. The inner space defined by the sequence of curves is filled, using the object color. The points coordinates are handled like in a polygon . arc : an arc defined by its enclosing rectangle and the start and end angles. Angles are in degrees and express counter-clockwise directions. line : a simple line specified by a point (x,y) expressed in scene coordinate space or by a width and angle. The point form is used to compute a line from (0,0) to (x,y), which is next drawn centered on the scene. Note: Width and/or height parameters can be expressed as float values or as scene relative values. See section whcontrol . Example Creating a rectangle with a 0.5 width and a 1.5 height. /ITL/scene/myObject set rect 0.5 1.5; Creating a line specified using width and angle. /ITL/scene/myObject set line wa 1. 45.;","title":"Vectorial graphics"},{"location":"refs/6-setsect/#signals-and-graphic-signals","text":"Signals are special objects that are stored in a special signal node and that may be composed in parallel to produce graphic signals. Signals and graphic signals are decribed in section graphsig . Signals and computation on signals may be based on FAUST objects that are actually signals processors. FAUST objects are decribed in section faust . For more information about the FAUST language, see at http://faust.grame.fr . setGraphicSignal ComplexDiagram( Sequence ('set', Choice (0, Sequence ('graph', NonTerminal('signals')), Sequence ('fastgraph', NonTerminal('signals')), Sequence ('faust', 'pluginname'), Sequence ('faustdsp', NonTerminal('faustcode')), Sequence ('faustdspf', NonTerminal('faustfile')))) ).addTo() graph : graphic of a signal. See section graphsig for details about the graph objects data. fastgraph : fast rendering graphic signal. See also section graphsig . faust : a FAUST object as a plugin (see section faust ) faustdsp : a FAUST object defined by a string (see section faust ) faustdspf : a FAUST object defined by a file (see section faust )","title":"Signals and graphic signals"},{"location":"refs/6-setsect/#media-files","text":"Images, video and audio are supported using various formats. See section fileset for more details on the supported formats. setMedia ComplexDiagram( Choice (0, Sequence ('img', NonTerminal('imgPath')), Sequence ('memimg', NonTerminal('objectPath')), Sequence ('video', NonTerminal('videoPath')), Sequence ('audio', NonTerminal('audioPath'))) ).addTo() img : an image file. The image format is inferred from the file extension. memimg : a memory capture of the object given as argument. objectPath indicates the target object that is captured with all its childrens. It may be an object name or a path to an object. Simple object names and relative path are looked for in the receiver layer. video : a video file. The video format is inferred from the file extension. Note that navigation through the video is made using its date . audio : an audio file. The audio format is inferred from the file extension. audio objects appear as a waveform but this waveforom is not (yet) computed from the audio data but randomly generated. Example Creating an image. /ITL/scene/myObject set img \"myImage.png\"; Creating a memory image of a scene. /ITL/scene/myObject set memimg \"/ITL/scene\"; Note: It is necessary to have an object or scene graphically rendered before a capture can be made. Since the actual graphic rendering is made asynchronously to the model update, a sequence of messages like the following: /ITL/scene/myObject set gmn \"[a f g]\"; /ITL/scene/capture set memimg myObject; won't work if the messages are handled by the same time task. A delay is necessary between the two messages. To make sure all the objects have been rendered, you can use the scene endPaint event.","title":"Media files"},{"location":"refs/6-setsect/#miscellaneous","text":"setMisc ComplexDiagram( Sequence ('set', Choice (0, 'layer', Sequence ('grid', NonTerminal('int32'), NonTerminal('int32')))) ).addTo() layer : a graphic layer, may be viewed as a container (see section layers ). grid : a white transparent object that provides a predefined time to graphic mapping (see section grid for more details and section mapping for time to graphic relations). The parameters are int32 values representing the number of columns and rows.","title":"Miscellaneous"},{"location":"refs/6-setsect/#file-based-resources","text":"Most of the types can be either expressed with the corresponding data, or by a path to a file containing the data. For the latter form, the object type is generally suffixed with an 'f' (e.g. txtf , htmlf , gmnf , musicxmlf , svgf , faustf ). The img , audio and video types have only a file form (and no 'f' suffix). A file path can be expressed as a Unix path (absolute or relative - see the scene or application rootPath message for relative paths handling), but also as an URL. Only the http: protocol is currently supported. When the system encounters an URL, it creates an intermediate object that is in charge of retrieving the corresponding data. This object has a specific url type that takes the target type and an url as arguments. It has a graphic appearance (actually a light gray box containing the object name and the target url) that can be controled like for any regular object. urlType ComplexDiagram( Sequence ('url', NonTerminal('targetType'), NonTerminal('urlPath')) ).addTo() The url intermediate object acts as a proxy for the target object and will transfer all its properties once the data are ready. A client can thus interact transparently with the target adress, whatever the status of the download request. Example Creating a score using an URL: /ITL/scene/score set gmnf \"http://anyhost.adomain.org/score.gmn\"; # is equivalent to /ITL/scene/score set url gmnf \"http://anyhost.adomain.org/score.gmn\"; Note: The url object handles specific events : success , error and cancel (see the section urlevents ).","title":"File based resources"},{"location":"refs/6-setsect/#the-file-type","text":"setFile ComplexDiagram( Sequence ('file', Choice (0, NonTerminal('filePath'), NonTerminal('urlPath'))) ).addTo() file : a generic type to handle file based objects. Actually, the file type is translated into a one of the txtf , gmnf , img , audio or video types, according to the file extension (see table fileTranslate ). See also: the application rootPath message (section ITL ) for file based objects. file extension translated type .txt .text txtf .htm .html htmlf .gmn gmnf .xml musicxmlf .svg svgf .jpg .jpeg .png .gif .bmp .tiff img .avi .wmv .mpg .mpeg .mp4 .mov .vob video .mp3 .wav .aiff .aif, .m4a, .aac audio .dsp faustdspf File extensions supported by the file translation scheme. Example Creating an image using the file type. /ITL/scene/myObject set file \"myImage.png\"; # is equivalent to /ITL/scene/myObject set img \"myImage.png\";","title":"The file type"},{"location":"refs/6-setsect/#web-objects","text":"A score can make its content available to the Internet using specific components that provide an image of the scene over http or websocket protocols. The httpd server depends on the Httpd server plugin and is described in section Httpd . The websocket server provides a two-ways communication between INScore and distant clients. The server sends notifications to client using a Screen updated text message when the scene is updated. Clients can request an image by sending a getImage text message to the server. The server responds with a image of the scene in png format, using a Blob type javascript object. webobject ComplexDiagram( Choice (0, Sequence ('websocket', NonTerminal('port'), NonTerminal('frequency')), Sequence ('httpd', NonTerminal('port'))) ).addTo() port : a port number for the socket communication. frequency : a minimum time in millisecond between two Screen updated notifications. Note: A busy port prevents the server to start. The server status can be checked with the get status message. Example Creating an websocket server using the port 1234 and limiting the notifications rate to one per 500 milliseconds. /ITL/scene/myObject set websocket 1234 500; See also: the http web server plugin (section Httpd ).","title":"Web objects"},{"location":"refs/7-getsect/","text":"The 'get' messages The get messages can be sent to any valid OSC address. It is intended to query the system state. It is the counterpart of all the messages modifying this state. The result of the query is sent to the OSC output port with the exact syntax of the counterpart message. The global form of the message is: getMsg ComplexDiagram( Sequence ('get', Optional ( OneOrMore (NonTerminal('getParam')))) ).addTo() The get message without parameter is the counterpart of the set message. When addressed to a container (the application /ITL , a scene /ITL/scene , the signal node /ITL/scene/signal ) is also distributed to all the container components. Specific get forms may be available, depending on the component type (see sections gmnpage , ITLQuery , ITLdebug , syncmsg , parcomp , faustmsg ). The get frame message is supported by all the components. An object frame is available for read only. It represents the polygon that encloses the object, taking account of scaling, rotations, and shear. The polygon is returned as a set of 4 points (x, y) expressed in the parent object coordinates space. Example Sending the following request to an object which position is 0.3 0.5 /ITL/scene/myobject get x y; will give the following messages on outpout port: ~~~~~~~ inscore /ITL/scene/myobject x 0.3; /ITL/scene/myobject y 0.5;} Querying an object content /ITL/scene/myobject get; will give the corresponding set message: /ITL/scene/myobject set txt \"Hello world!\"; Querying an object frame /ITL/scene/myobject get frame; will give the corresponding frame message: /ITL/scene/myobject frame -0.5 -0.25 0.50 -0.25 0.50 0.25 -0.5 0.25; Note: The get width and get height messages addressed to components that have no explicit width and height (text, images, etc.) returns 0 as long as the target component has not been graphically rendered.","title":"The get Message"},{"location":"refs/7-getsect/#the-get-messages","text":"The get messages can be sent to any valid OSC address. It is intended to query the system state. It is the counterpart of all the messages modifying this state. The result of the query is sent to the OSC output port with the exact syntax of the counterpart message. The global form of the message is: getMsg ComplexDiagram( Sequence ('get', Optional ( OneOrMore (NonTerminal('getParam')))) ).addTo() The get message without parameter is the counterpart of the set message. When addressed to a container (the application /ITL , a scene /ITL/scene , the signal node /ITL/scene/signal ) is also distributed to all the container components. Specific get forms may be available, depending on the component type (see sections gmnpage , ITLQuery , ITLdebug , syncmsg , parcomp , faustmsg ). The get frame message is supported by all the components. An object frame is available for read only. It represents the polygon that encloses the object, taking account of scaling, rotations, and shear. The polygon is returned as a set of 4 points (x, y) expressed in the parent object coordinates space. Example Sending the following request to an object which position is 0.3 0.5 /ITL/scene/myobject get x y; will give the following messages on outpout port: ~~~~~~~ inscore /ITL/scene/myobject x 0.3; /ITL/scene/myobject y 0.5;} Querying an object content /ITL/scene/myobject get; will give the corresponding set message: /ITL/scene/myobject set txt \"Hello world!\"; Querying an object frame /ITL/scene/myobject get frame; will give the corresponding frame message: /ITL/scene/myobject frame -0.5 -0.25 0.50 -0.25 0.50 0.25 -0.5 0.25; Note: The get width and get height messages addressed to components that have no explicit width and height (text, images, etc.) returns 0 as long as the target component has not been graphically rendered.","title":"The 'get' messages"},{"location":"refs/8-specificMsg/","text":"Type specific messages Some of the messages are accepted only by specific components. This section describes the messages associated to specific objects types. Brush control Brush styles brushStyle message is accepted by the following components: rect ellipse polygon curve layer . brushMsg ComplexDiagram( Sequence ('brushStyle', Choice (0, 'solid', 'dense1', 'dense2', 'dense3', 'dense4', 'dense5', 'dense6', 'dense7', 'none', 'hor', 'ver', 'cross', 'bdiag', 'fdiag', 'diagCross')) ).addTo() brushStyle controls the brush style (see figure brushstyle ). The brush style default value is solid . For the layer object, the brush style default value is none . Example Setting a rectangle style : /ITL/scene/rect set rect 0.5 0.5 ; /ITL/scene/rect brushStyle dense4; Width and height control width and height messages are accepted by the almost all components except textual components (see section textscore ). widthMsg ComplexDiagram( Choice (0, Sequence ('width', NonTerminal('dimension')), Sequence ('height', NonTerminal('dimension'))) ).addTo() dimension ComplexDiagram( Sequence (NonTerminal('float32'), Choice (0, Comment ('1'), Sequence (Comment ('2'), Choice (0, 'sw', 'sh')))) ).addTo() 1 : a single float value express the dimension in the inscore coordinate system. 2 : a float value suffixed with sw or sh express a dimension relative to the actual scene dimension. sw stands for 'scene width' and sh for 'scene height'. Such dimension dynamically adjusted to any change in the scene dimension. Example /ITL/scene/myObject width 1; # using the inscore coordinate system /ITL/scene/myObject width 0.9sw; # using the scene width Note: Querying the width and height of any object is always supported, provided that the object has been graphically rendered. Symbolic score The following messages are accepted by the components types gmn | gmnstream | gmnf . scoreMsg ComplexDiagram( Choice (0, Sequence ('page', NonTerminal('int32')), Sequence ('dpage', NonTerminal('int32')), Sequence ('pageFormat', NonTerminal('float32'), NonTerminal('float32')), Sequence ('columns', NonTerminal('int32')), Sequence ('rows', NonTerminal('int32')), Sequence ('get', Choice (0, 'pageCount', 'systemCount'))) ).addTo() page : set the score current page dpage : moves the score current page pageFormat : set the page format. The parameters are the page width and height. Note that the message has no effect when the score already includes a \\pageformat tag. columns : for multi pages display: set the number of columns. rows : for multi pages display: set the number of rows. pageCount : a read only attribute, gives the score pages count. systemCount : a read only attribute, gives the number of systems on each of the score pages. The result is given as a list systems count ordered by page number (index 0 is page 1, etc.). Example Displaying a multi-pages score on two pages starting at page 3: /ITL/scene/myScore columns 2 ; /ITL/scene/myScore page 3 ; gmnstreamMsg ComplexDiagram( Choice (0, Sequence ('write', NonTerminal('gmnCode')), 'clear') ).addTo() write : add the gmn code to the current gmn stream clear : reinitialize the stream Example Writing a score in 3 steps: /ITL/scene/myScore set gmnstream \"[ c\"; /ITL/scene/myScore write \" d e\"; /ITL/scene/myScore write \" f]\"; Piano roll The following messages are accepted by the components types pianoroll | pianorollstream | pianorollf . pianorollMsg ComplexDiagram( Choice (0, Sequence ('keyboard', NonTerminal('int32')), Sequence ('autoVoicesColoration', NonTerminal('int32')), Sequence ('measureBars', NonTerminal('int32')), Sequence ('voiceColor', Optional (Sequence (NonTerminal('int32'), Optional (NonTerminal('color')) )) ), Sequence ('pitchLines', Optional ('Notes') ), Sequence ('clipTime', Optional (Sequence (NonTerminal('time'), NonTerminal('time'))) ), Sequence ('clipPitch', Optional (Sequence (NonTerminal('int32'), NonTerminal('int32'))) )) ).addTo() keyboard : display the keyboard on left of piano roll. Default value to 0. autoVoicesColoration : enable voices automatic coloration. If voiceColor is used for a voice, automatic voices coloration do nothing for it. Default value to 0. measureBars : Display measure bars on piano roll. Default value to 0. voiceColor : set a color to a voice. The parameters are voice number (start to 1), and RGBA color (See section colormsg ). If not color is present, voice color is reset to default color. If voice number and color are not present, reset all voices to default color. pitchLines : Display pitch lines on pianoroll. Parameters are a note list in english notation (A A# B ...) with case insensitive. Default to all lines. An ' empty ' note (i.e. the litteral ' empty ' string) can be used to hide all lines. clipTime : set time limits for piano roll (See section time to set a time). The two times have to be wrote in the same format. If no time is present, time limits are reset to default. clipPitch : Set pitch limits to piano roll. The pitch is in midi format. If no value is present, pitch limits are reset to default. Example Set a color on voice 2 with transparency and display C and F pitch lines: /ITL/scene/myPianoroll voiceColor 2 154 234 45 100; /ITL/scene/myPianoroll pitchLines 'C' 'F'; Removes the pitch lines: /ITL/scene/myPianoroll pitchLines empty; Piano roll streams support the same messages than Guido streams: pianorollstreamMsg ComplexDiagram( Choice (0, Sequence ('write', NonTerminal('gmnCode')), 'clear') ).addTo() write : add the gmn code to the current gmn stream clear : reinitialize the stream Example Writing a pianoroll in 3 steps: /ITL/scene/myPianoroll set pianorollstream \"[ c\"; /ITL/scene/myPianoroll write \" d e\"; /ITL/scene/myPianoroll write \" f]\"; Audio and Video Media objects ( audio video ) have their own internal time and duration that is independent from the INScore time and duration. This time is controlled using specific messages. media ComplexDiagram( Choice (0, Sequence ('play', NonTerminal('int32')), Sequence (NonTerminal('volume'), NonTerminal('float32')), Sequence (NonTerminal('rate'), NonTerminal('float32')), Sequence (NonTerminal('vdate'), Choice (0, Sequence (Comment ('1'), NonTerminal('int32')), Sequence (Comment ('2'), Sequence (NonTerminal('int32'), NonTerminal('int32'))), Sequence (Comment ('3'), NonTerminal('float'))))) ).addTo() play start or stop playing the media. Default value is 0. volume sets the audio volume. Default and maximum value is 1. rate sets the media playing rate. Default value is 1. vdate sets the current video frame or audio position. Default value is 0. Arguments are the following: 1) : a value in milliseconds. 2) : a musical time expressed as a rational. Note that musical time is converted to milliseconds using a tempo value of 60. 3) : a musical time expressed as a float. A media position may be updated while the media is playing. Media objects support also specific queries: mediaGet ComplexDiagram( Choice (0, 'mls', 'vduration') ).addTo() mls gives the media absolute duration in milliseconds. vduration gives the media duration in musical time. The returned value is a rational computed using the current rate, according to a tempo value of 60. A media object supports specific events (see section typespecevents for more details). Example Playing a video at half speed: /ITL/scene/video set video \"Video.mp4\"; /ITL/scene/video rate 0.5; /ITL/scene/video play 1\"; Note: Depending on the video encoding and on the platform renderer, setting the video current position using the vdate message may be aligned to key frames. Supported audio and video formats are highly dependent on the platform, as well as media specific features (e.g. setting the playing rate that may or may not be supported, or may behave differently). SVG Objects The following message is accepted by the SVG components (types svg | svgf ). svgMsg ComplexDiagram( Choice (0, Sequence ('animate', NonTerminal('int32')), Sequence (NonTerminal('get'), 'animated')) ).addTo() animate : start or stop the svg animation (provided the SVG is animated). The parameter is a boolean value (default is 0). animated : a get parameter only: returns whether the svg is animated or not. Note: SVG objects are rendered using the Qt SVG Renderer and suffer the Qt limitations. For example and with Qt 5.5, xlinks are not supported. Rectangles Rectangles (type rect ) accept a radius message that can be used to draw rounded rectangles. radiusMsg ComplexDiagram( Sequence ('radius', NonTerminal('float32'), NonTerminal('float32')) ).addTo() radius : followed by 2 values that specify the radius on the x and y axis (default is 0 0). The values express a percentage of the object dimensions, thus the value's range is [0, 100]. Arcs Arcs are portions of ellipses. Although an arc is specified by it's set message, it supports additional messages to control the start angles and the arc extension individually. An additional close message affects the drawing of the arc. arcMsg ComplexDiagram( Choice (0, Sequence ('start', NonTerminal('float32')), Sequence ('range', NonTerminal('float32')), Sequence ('dstart', NonTerminal('float32')), Sequence ('drange', NonTerminal('float32')), Sequence ('close', NonTerminal('int32'))) ).addTo() start : set the start angle of the arc. range : set the arc extension in degrees counter-clockwise. dstart : move the start angle of the arc from the value given as parameter. drange : move the arc range from the value given as parameter. close : by default, only the curve of an arc is drawn. When the close attribute is set, lines from the arc borders to the center of the ellipse are also drawn. The close parameter is read as a boolean value. Angles are in degrees and express counter-clockwise directions. The 'grid' object The grid object provides a pre-defined time to graphic mapping organized in columns and row. By default, it is not visible (white, transparent) but supports all the attributes of rectangles (color, pen, effects, etc.). Each element of a grid has a duration that is computed as the grid duration divided by the total number of elements ( columns x rows) and is placed in the time space from the date 0 to the end of the grid duration. gridMsg ComplexDiagram( Choice (0, Sequence ('columns', NonTerminal('int32')), Sequence ('rows', NonTerminal('int32')), Sequence ('xborder', NonTerminal('float')), Sequence ('yborder', NonTerminal('float')), Sequence ('order', Choice (0, 'leftright', 'topbottom'))) ).addTo() columns set the number of columns of the grid, rows set the number of rows of the grid, xborder set the horizontal spacing between the elements of the grid (default is 0.), yborder set the vertical spacing between the elements of the grid (default is 0.), order defines the time order of the elements. By default, elements are organized from left to right first and from top to bottom next ( leftright ). The topbottom parameter changes this order from top to bottom first and from left to right next. Example Creating a 10 x 10 grid organized from top to bottom with a border: /ITL/scene/grid set grid 10 10 ; /ITL/scene/grid xborder 3. ; /ITL/scene/grid yborder 3. ; /ITL/scene/grid order topbottom ; Arrows Specific arrows message is accepted by the component type line . It add capability to draw arrow heads to the begining and the end of a line object. arrowsheadMsg ComplexDiagram( Sequence ('arrows', NonTerminal('arrowStyleBegin'), NonTerminal('arrowStyleEnd')) ).addTo() arrowStyleBegin Set the arrow head of the begining of the line. arrowStyleEnd Set the arrow head of the end of the line. arrowStyle ComplexDiagram( Choice (0, 'none', 'triangle', 'diamond', 'disk') ).addTo() The arrow style default value is none . Textual objects Font control Specific font messages are accepted by txt html txtf and htmlf components. fontMsg ComplexDiagram( Choice (0, Sequence ('fontSize', NonTerminal('int32')), Sequence ('fontFamily', NonTerminal('string')), Sequence ('fontStyle', NonTerminal('style')), Sequence ('fontWeight', NonTerminal('weight'))) ).addTo() fontStyle ComplexDiagram( Choice (0, 'normal', 'italic', 'oblique') ).addTo() fontWeight ComplexDiagram( Choice (0, 'light', 'demibold', 'normal', 'bold', 'black') ).addTo() fontSize controls the font size in pixel. The default value is 13px. fontFamily controls the font family. The default value is 'Arial'. If a non existing value is used, system default font is used. fontStyle controls the pen style. The font style default value is normal . weightValue controls the font weight. The font weight default value is normal . Example Setting a text object with a font family Times and bold weight: /ITL/scene/text set txt \"text sample\"; /ITL/scene/text fontFamily Times; /ITL/scene/text fontWeight bold; Writing Textual objects support writing in a stream-like way. txtwrite ComplexDiagram( Sequence ('write', OneOrMore (NonTerminal('arg'))) ).addTo() write : append the arg list formatted as a string to the textual content. Example /ITL/scene/text set txt \"Hello\"; /ITL/scene/text write \"world!\"; Getting the text A specific text query is provided to get the textual content. Example /ITL/scene/text get text; The 'debug' nodes Each component includes a static debug nodes provided to give information about components. debugMsg ComplexDiagram( Choice (0, Sequence ('map', NonTerminal('int32')), Sequence ('name', NonTerminal('int32'))) ).addTo() map is used to display the time to graphic mapping. The parameter is a int value: 0 prevents mapping display, 1 displays only the bounding boxes and 2 displays also the dates along with the boxes. Default is 0 (no map). name is used to display both the object name and bounding box. The parameter is a boolean value. Default is 0.","title":"Specific Messages"},{"location":"refs/8-specificMsg/#type-specific-messages","text":"Some of the messages are accepted only by specific components. This section describes the messages associated to specific objects types.","title":"Type specific messages"},{"location":"refs/8-specificMsg/#brush-control","text":"Brush styles brushStyle message is accepted by the following components: rect ellipse polygon curve layer . brushMsg ComplexDiagram( Sequence ('brushStyle', Choice (0, 'solid', 'dense1', 'dense2', 'dense3', 'dense4', 'dense5', 'dense6', 'dense7', 'none', 'hor', 'ver', 'cross', 'bdiag', 'fdiag', 'diagCross')) ).addTo() brushStyle controls the brush style (see figure brushstyle ). The brush style default value is solid . For the layer object, the brush style default value is none . Example Setting a rectangle style : /ITL/scene/rect set rect 0.5 0.5 ; /ITL/scene/rect brushStyle dense4;","title":"Brush control"},{"location":"refs/8-specificMsg/#width-and-height-control","text":"width and height messages are accepted by the almost all components except textual components (see section textscore ). widthMsg ComplexDiagram( Choice (0, Sequence ('width', NonTerminal('dimension')), Sequence ('height', NonTerminal('dimension'))) ).addTo() dimension ComplexDiagram( Sequence (NonTerminal('float32'), Choice (0, Comment ('1'), Sequence (Comment ('2'), Choice (0, 'sw', 'sh')))) ).addTo() 1 : a single float value express the dimension in the inscore coordinate system. 2 : a float value suffixed with sw or sh express a dimension relative to the actual scene dimension. sw stands for 'scene width' and sh for 'scene height'. Such dimension dynamically adjusted to any change in the scene dimension. Example /ITL/scene/myObject width 1; # using the inscore coordinate system /ITL/scene/myObject width 0.9sw; # using the scene width Note: Querying the width and height of any object is always supported, provided that the object has been graphically rendered.","title":"Width and height control"},{"location":"refs/8-specificMsg/#symbolic-score","text":"The following messages are accepted by the components types gmn | gmnstream | gmnf . scoreMsg ComplexDiagram( Choice (0, Sequence ('page', NonTerminal('int32')), Sequence ('dpage', NonTerminal('int32')), Sequence ('pageFormat', NonTerminal('float32'), NonTerminal('float32')), Sequence ('columns', NonTerminal('int32')), Sequence ('rows', NonTerminal('int32')), Sequence ('get', Choice (0, 'pageCount', 'systemCount'))) ).addTo() page : set the score current page dpage : moves the score current page pageFormat : set the page format. The parameters are the page width and height. Note that the message has no effect when the score already includes a \\pageformat tag. columns : for multi pages display: set the number of columns. rows : for multi pages display: set the number of rows. pageCount : a read only attribute, gives the score pages count. systemCount : a read only attribute, gives the number of systems on each of the score pages. The result is given as a list systems count ordered by page number (index 0 is page 1, etc.). Example Displaying a multi-pages score on two pages starting at page 3: /ITL/scene/myScore columns 2 ; /ITL/scene/myScore page 3 ; gmnstreamMsg ComplexDiagram( Choice (0, Sequence ('write', NonTerminal('gmnCode')), 'clear') ).addTo() write : add the gmn code to the current gmn stream clear : reinitialize the stream Example Writing a score in 3 steps: /ITL/scene/myScore set gmnstream \"[ c\"; /ITL/scene/myScore write \" d e\"; /ITL/scene/myScore write \" f]\";","title":"Symbolic score"},{"location":"refs/8-specificMsg/#piano-roll","text":"The following messages are accepted by the components types pianoroll | pianorollstream | pianorollf . pianorollMsg ComplexDiagram( Choice (0, Sequence ('keyboard', NonTerminal('int32')), Sequence ('autoVoicesColoration', NonTerminal('int32')), Sequence ('measureBars', NonTerminal('int32')), Sequence ('voiceColor', Optional (Sequence (NonTerminal('int32'), Optional (NonTerminal('color')) )) ), Sequence ('pitchLines', Optional ('Notes') ), Sequence ('clipTime', Optional (Sequence (NonTerminal('time'), NonTerminal('time'))) ), Sequence ('clipPitch', Optional (Sequence (NonTerminal('int32'), NonTerminal('int32'))) )) ).addTo() keyboard : display the keyboard on left of piano roll. Default value to 0. autoVoicesColoration : enable voices automatic coloration. If voiceColor is used for a voice, automatic voices coloration do nothing for it. Default value to 0. measureBars : Display measure bars on piano roll. Default value to 0. voiceColor : set a color to a voice. The parameters are voice number (start to 1), and RGBA color (See section colormsg ). If not color is present, voice color is reset to default color. If voice number and color are not present, reset all voices to default color. pitchLines : Display pitch lines on pianoroll. Parameters are a note list in english notation (A A# B ...) with case insensitive. Default to all lines. An ' empty ' note (i.e. the litteral ' empty ' string) can be used to hide all lines. clipTime : set time limits for piano roll (See section time to set a time). The two times have to be wrote in the same format. If no time is present, time limits are reset to default. clipPitch : Set pitch limits to piano roll. The pitch is in midi format. If no value is present, pitch limits are reset to default. Example Set a color on voice 2 with transparency and display C and F pitch lines: /ITL/scene/myPianoroll voiceColor 2 154 234 45 100; /ITL/scene/myPianoroll pitchLines 'C' 'F'; Removes the pitch lines: /ITL/scene/myPianoroll pitchLines empty; Piano roll streams support the same messages than Guido streams: pianorollstreamMsg ComplexDiagram( Choice (0, Sequence ('write', NonTerminal('gmnCode')), 'clear') ).addTo() write : add the gmn code to the current gmn stream clear : reinitialize the stream Example Writing a pianoroll in 3 steps: /ITL/scene/myPianoroll set pianorollstream \"[ c\"; /ITL/scene/myPianoroll write \" d e\"; /ITL/scene/myPianoroll write \" f]\";","title":"Piano roll"},{"location":"refs/8-specificMsg/#audio-and-video","text":"Media objects ( audio video ) have their own internal time and duration that is independent from the INScore time and duration. This time is controlled using specific messages. media ComplexDiagram( Choice (0, Sequence ('play', NonTerminal('int32')), Sequence (NonTerminal('volume'), NonTerminal('float32')), Sequence (NonTerminal('rate'), NonTerminal('float32')), Sequence (NonTerminal('vdate'), Choice (0, Sequence (Comment ('1'), NonTerminal('int32')), Sequence (Comment ('2'), Sequence (NonTerminal('int32'), NonTerminal('int32'))), Sequence (Comment ('3'), NonTerminal('float'))))) ).addTo() play start or stop playing the media. Default value is 0. volume sets the audio volume. Default and maximum value is 1. rate sets the media playing rate. Default value is 1. vdate sets the current video frame or audio position. Default value is 0. Arguments are the following: 1) : a value in milliseconds. 2) : a musical time expressed as a rational. Note that musical time is converted to milliseconds using a tempo value of 60. 3) : a musical time expressed as a float. A media position may be updated while the media is playing. Media objects support also specific queries: mediaGet ComplexDiagram( Choice (0, 'mls', 'vduration') ).addTo() mls gives the media absolute duration in milliseconds. vduration gives the media duration in musical time. The returned value is a rational computed using the current rate, according to a tempo value of 60. A media object supports specific events (see section typespecevents for more details). Example Playing a video at half speed: /ITL/scene/video set video \"Video.mp4\"; /ITL/scene/video rate 0.5; /ITL/scene/video play 1\"; Note: Depending on the video encoding and on the platform renderer, setting the video current position using the vdate message may be aligned to key frames. Supported audio and video formats are highly dependent on the platform, as well as media specific features (e.g. setting the playing rate that may or may not be supported, or may behave differently).","title":"Audio and Video"},{"location":"refs/8-specificMsg/#svg-objects","text":"The following message is accepted by the SVG components (types svg | svgf ). svgMsg ComplexDiagram( Choice (0, Sequence ('animate', NonTerminal('int32')), Sequence (NonTerminal('get'), 'animated')) ).addTo() animate : start or stop the svg animation (provided the SVG is animated). The parameter is a boolean value (default is 0). animated : a get parameter only: returns whether the svg is animated or not. Note: SVG objects are rendered using the Qt SVG Renderer and suffer the Qt limitations. For example and with Qt 5.5, xlinks are not supported.","title":"SVG Objects"},{"location":"refs/8-specificMsg/#rectangles","text":"Rectangles (type rect ) accept a radius message that can be used to draw rounded rectangles. radiusMsg ComplexDiagram( Sequence ('radius', NonTerminal('float32'), NonTerminal('float32')) ).addTo() radius : followed by 2 values that specify the radius on the x and y axis (default is 0 0). The values express a percentage of the object dimensions, thus the value's range is [0, 100].","title":"Rectangles"},{"location":"refs/8-specificMsg/#arcs","text":"Arcs are portions of ellipses. Although an arc is specified by it's set message, it supports additional messages to control the start angles and the arc extension individually. An additional close message affects the drawing of the arc. arcMsg ComplexDiagram( Choice (0, Sequence ('start', NonTerminal('float32')), Sequence ('range', NonTerminal('float32')), Sequence ('dstart', NonTerminal('float32')), Sequence ('drange', NonTerminal('float32')), Sequence ('close', NonTerminal('int32'))) ).addTo() start : set the start angle of the arc. range : set the arc extension in degrees counter-clockwise. dstart : move the start angle of the arc from the value given as parameter. drange : move the arc range from the value given as parameter. close : by default, only the curve of an arc is drawn. When the close attribute is set, lines from the arc borders to the center of the ellipse are also drawn. The close parameter is read as a boolean value. Angles are in degrees and express counter-clockwise directions.","title":"Arcs"},{"location":"refs/8-specificMsg/#the-grid-object","text":"The grid object provides a pre-defined time to graphic mapping organized in columns and row. By default, it is not visible (white, transparent) but supports all the attributes of rectangles (color, pen, effects, etc.). Each element of a grid has a duration that is computed as the grid duration divided by the total number of elements ( columns x rows) and is placed in the time space from the date 0 to the end of the grid duration. gridMsg ComplexDiagram( Choice (0, Sequence ('columns', NonTerminal('int32')), Sequence ('rows', NonTerminal('int32')), Sequence ('xborder', NonTerminal('float')), Sequence ('yborder', NonTerminal('float')), Sequence ('order', Choice (0, 'leftright', 'topbottom'))) ).addTo() columns set the number of columns of the grid, rows set the number of rows of the grid, xborder set the horizontal spacing between the elements of the grid (default is 0.), yborder set the vertical spacing between the elements of the grid (default is 0.), order defines the time order of the elements. By default, elements are organized from left to right first and from top to bottom next ( leftright ). The topbottom parameter changes this order from top to bottom first and from left to right next. Example Creating a 10 x 10 grid organized from top to bottom with a border: /ITL/scene/grid set grid 10 10 ; /ITL/scene/grid xborder 3. ; /ITL/scene/grid yborder 3. ; /ITL/scene/grid order topbottom ;","title":"The 'grid' object"},{"location":"refs/8-specificMsg/#arrows","text":"Specific arrows message is accepted by the component type line . It add capability to draw arrow heads to the begining and the end of a line object. arrowsheadMsg ComplexDiagram( Sequence ('arrows', NonTerminal('arrowStyleBegin'), NonTerminal('arrowStyleEnd')) ).addTo() arrowStyleBegin Set the arrow head of the begining of the line. arrowStyleEnd Set the arrow head of the end of the line. arrowStyle ComplexDiagram( Choice (0, 'none', 'triangle', 'diamond', 'disk') ).addTo() The arrow style default value is none .","title":"Arrows"},{"location":"refs/8-specificMsg/#textual-objects","text":"","title":"Textual objects"},{"location":"refs/8-specificMsg/#font-control","text":"Specific font messages are accepted by txt html txtf and htmlf components. fontMsg ComplexDiagram( Choice (0, Sequence ('fontSize', NonTerminal('int32')), Sequence ('fontFamily', NonTerminal('string')), Sequence ('fontStyle', NonTerminal('style')), Sequence ('fontWeight', NonTerminal('weight'))) ).addTo() fontStyle ComplexDiagram( Choice (0, 'normal', 'italic', 'oblique') ).addTo() fontWeight ComplexDiagram( Choice (0, 'light', 'demibold', 'normal', 'bold', 'black') ).addTo() fontSize controls the font size in pixel. The default value is 13px. fontFamily controls the font family. The default value is 'Arial'. If a non existing value is used, system default font is used. fontStyle controls the pen style. The font style default value is normal . weightValue controls the font weight. The font weight default value is normal . Example Setting a text object with a font family Times and bold weight: /ITL/scene/text set txt \"text sample\"; /ITL/scene/text fontFamily Times; /ITL/scene/text fontWeight bold;","title":"Font control"},{"location":"refs/8-specificMsg/#writing","text":"Textual objects support writing in a stream-like way. txtwrite ComplexDiagram( Sequence ('write', OneOrMore (NonTerminal('arg'))) ).addTo() write : append the arg list formatted as a string to the textual content. Example /ITL/scene/text set txt \"Hello\"; /ITL/scene/text write \"world!\";","title":"Writing"},{"location":"refs/8-specificMsg/#getting-the-text","text":"A specific text query is provided to get the textual content. Example /ITL/scene/text get text;","title":"Getting the text"},{"location":"refs/8-specificMsg/#the-debug-nodes","text":"Each component includes a static debug nodes provided to give information about components. debugMsg ComplexDiagram( Choice (0, Sequence ('map', NonTerminal('int32')), Sequence ('name', NonTerminal('int32'))) ).addTo() map is used to display the time to graphic mapping. The parameter is a int value: 0 prevents mapping display, 1 displays only the bounding boxes and 2 displays also the dates along with the boxes. Default is 0 (no map). name is used to display both the object name and bounding box. The parameter is a boolean value. Default is 0.","title":"The 'debug' nodes"},{"location":"refs/9-ITL/","text":"Application messages Application messages are accepted by the static OSC address /ITL . Application management ITLMsg ComplexDiagram( Choice (0, 'quit', Sequence ('scenes', OneOrMore (NonTerminal('string'))), Sequence ('rootPath', NonTerminal('path')), Sequence ('preprocess', NonTerminal('file')), Sequence ('mouse', Choice (0, 'show', 'hide')), Sequence ('defaultShow', NonTerminal('int32')), Sequence ('load', NonTerminal('filePath')), Sequence ('read', NonTerminal('buffer')), Sequence ('require', NonTerminal('float'), NonTerminal('oscMsg')), Sequence ('compatibility', NonTerminal('float')), Sequence ('errorAddress', NonTerminal('string')), Sequence ('time', NonTerminal('int32')), Sequence ('ticks', NonTerminal('int32')), Sequence ('rate', NonTerminal('int32')), 'hello', NonTerminal('forwardingMsg')) ).addTo() quit : requests the client application to quit. scenes : creates a set of scenes. Arguments is a list of scene names. rootPath : rootPath of an INScore application is the default path where the application reads or writes a file when a relative path is used for this file. The default value is the user home directory. Sending the rootPath message without parameter resets the application path to its default value. preprocess : evaluates the input file script and print the result to the log window. mouse : hide or show the mouse pointer. defaultShow : changes the default show status for new objects. The default defaultShow value is 1. load : loads a file previously saved using the save message (see section common ). Note that the load operation appends the new objects to the existing scene. When necessary, it is the sender responsibility to clear the scene before loading a file. URL are supported for the file path (see section filebasedrsrc ); read : read a buffer that is expected to contain a valid inscore script. require : check that the current INScore version number is equal or greater to the number given as argument. The version number is given as a float value. A message is associated to the require message, which is triggered when the check fails. See section interaction for more details. compatibility : preserve INScore previous behavior. The argument corresponds to a version number, INScore will preserve the corresponding behavior (objects scaling, default size, etc.). errorAddress : set the OSC address of error messages. Default is error: (which is not a valid OSC address but preserved for compatibility reasons). rate : changes the time task rate. Note that null values are ignored. The default rate value is 10. time : sets the application current time. The time is expressed in milliseconds. ticks : sets the application current ticks count. The ticks count indicates the number of time tasks performed by the application. hello : query the host IP number. The message is intended for ITL applications discovery. Answer to the query has the following format: IP inPort outPort errPort where IP is sent as a string and port numbers as integer values. forwardingMsg : application support message forwading and filtering. See section Forwarding . Example when sending the message: /ITL hello; the application will answer with the following message: /ITL 192.168.0.5 7000 7001 7002 when it runs on a host which IP address is 192.168.0.5 using the default port numbers. Ports management ITLPortsMsg ComplexDiagram( Choice (0, Sequence ('port', NonTerminal('int32')), Sequence ('outport', NonTerminal('int32')), Sequence ('errport', NonTerminal('int32'))) ).addTo() Changes the UDP port numbers: port defines the listening port number, outport defines the port used to send replies to queries, errport defines the port used to send error messages. The int32 parameter should be a positive value in the range [1024-49150] . The default port , outport and errport values are 7000, 7001 and 7002. Note: Error messages are sent as a single string. System support ITLSystem ComplexDiagram( Sequence ('browse', NonTerminal('file')) ).addTo() browse open the file given as parameter using the system default browser. The message supports URLs that can be of type http:// , https:// or file:// . It supports also direct reference to a local file (e.g. myfile.html) that is translated into file:// url using the application rootPath. Application level queries The application supports the get messages for its parameters (see section getsect ). In addition, it provides the following messages to query version numbers or IP address. ITLRequest ComplexDiagram( Sequence ('get', Choice (0, 'version', 'guido-version', 'musicxml-version', 'IP', 'scount')) ).addTo() version : version number request. guido-version : Guido engine version number request. musicxml-version : MusicXML and Guido converter version numbers request. Returns \"not available\" when the library is not found. IP : the host IP address. scount : gives the count of scenes. Example Querying INScore version: /ITL get version; will give the following as output: /ITL version 1.34 Application static nodes The application level provides the static nodes stats , debug , log and ssl , available at /ITL/stats /ITL/debug , /ITL/log and /ITL/ssl . The 'stats' nodes ITLStats ComplexDiagram( Choice (0, 'get', 'reset') ).addTo() get gives the count of handled messages at OSC and UDP levels: the UDP count indicates the count of messages received from the network, the OSC count includes the UDP count and the messages received internally. reset resets the counters to zero. Note that querying the stats node increments at least the OSC the counter. Example Answer to a get message addressed to /ITL/stats /ITL/stats osc 15 udp 10 The 'debug' nodes The debug node is used to activate debugging information. ITLdebug ComplexDiagram( Sequence ('osc', NonTerminal('int23')) ).addTo() switch the debug mode ON or OFF. The parameter is interpreted as a boolean value. When in debug mode, INScore sends verbose messages to the OSC error port for every message that can't be correctly handled. Debugging is ON by default. Example Error messages generated on error port in debug mode: error: incorrect OSC address: /ITL/stat error: incorrect parameters: /ITL/scene/foo unknown 0.1 error: incorrect parameters: /ITL/scene/foo x \"incorrectType\" The 'log' nodes The log node controls a console window that display all the messages sent to the OSC error port. Typical content is given by the example above. ITLLog ComplexDiagram( Choice (0, Sequence ('show', NonTerminal('int32')), 'clear', 'foreground', Sequence ('wrap', NonTerminal('int32')), Sequence ('write', OneOrMore (NonTerminal('arg'))), Sequence ('save', NonTerminal('string')), Sequence ('level', NonTerminal('int32')), Sequence ('scale', NonTerminal('float32'))) ).addTo() show show or hides the console. The parameter is a boolean value. clear clear the console window. foreground put the console window to front. wrap control line wrapping of the console. The parameter is a boolean value. write write the arg list formatted as a string to the log window. save save the current log content to a file. The parameter is a file name. When expressed as a relative path, the file is saved under the current application root path. level set the log level. Expected values are: 0 : no log 1 : log errors (default value) 2 : log errors and output of get messages scale scales the log window content. Default value is 1.0. The 'plugins' nodes The plugins node controls the search path for plugins. See section plugins for more information on plugins and search strategies. ITLPlugin ComplexDiagram( Choice (0, Sequence ('path', NonTerminal('folder')), 'reset') ).addTo() path add folder as a user path. The system will look for plugins in this folder first. reset clear the current user path. The 'ssl' node The ssl node is provided to manage certificates for encrypted communication with remote hosts. See section SSL for more details and section Forwarding for communication scheme.","title":"Application Messages"},{"location":"refs/9-ITL/#application-messages","text":"Application messages are accepted by the static OSC address /ITL .","title":"Application messages"},{"location":"refs/9-ITL/#application-management","text":"ITLMsg ComplexDiagram( Choice (0, 'quit', Sequence ('scenes', OneOrMore (NonTerminal('string'))), Sequence ('rootPath', NonTerminal('path')), Sequence ('preprocess', NonTerminal('file')), Sequence ('mouse', Choice (0, 'show', 'hide')), Sequence ('defaultShow', NonTerminal('int32')), Sequence ('load', NonTerminal('filePath')), Sequence ('read', NonTerminal('buffer')), Sequence ('require', NonTerminal('float'), NonTerminal('oscMsg')), Sequence ('compatibility', NonTerminal('float')), Sequence ('errorAddress', NonTerminal('string')), Sequence ('time', NonTerminal('int32')), Sequence ('ticks', NonTerminal('int32')), Sequence ('rate', NonTerminal('int32')), 'hello', NonTerminal('forwardingMsg')) ).addTo() quit : requests the client application to quit. scenes : creates a set of scenes. Arguments is a list of scene names. rootPath : rootPath of an INScore application is the default path where the application reads or writes a file when a relative path is used for this file. The default value is the user home directory. Sending the rootPath message without parameter resets the application path to its default value. preprocess : evaluates the input file script and print the result to the log window. mouse : hide or show the mouse pointer. defaultShow : changes the default show status for new objects. The default defaultShow value is 1. load : loads a file previously saved using the save message (see section common ). Note that the load operation appends the new objects to the existing scene. When necessary, it is the sender responsibility to clear the scene before loading a file. URL are supported for the file path (see section filebasedrsrc ); read : read a buffer that is expected to contain a valid inscore script. require : check that the current INScore version number is equal or greater to the number given as argument. The version number is given as a float value. A message is associated to the require message, which is triggered when the check fails. See section interaction for more details. compatibility : preserve INScore previous behavior. The argument corresponds to a version number, INScore will preserve the corresponding behavior (objects scaling, default size, etc.). errorAddress : set the OSC address of error messages. Default is error: (which is not a valid OSC address but preserved for compatibility reasons). rate : changes the time task rate. Note that null values are ignored. The default rate value is 10. time : sets the application current time. The time is expressed in milliseconds. ticks : sets the application current ticks count. The ticks count indicates the number of time tasks performed by the application. hello : query the host IP number. The message is intended for ITL applications discovery. Answer to the query has the following format: IP inPort outPort errPort where IP is sent as a string and port numbers as integer values. forwardingMsg : application support message forwading and filtering. See section Forwarding . Example when sending the message: /ITL hello; the application will answer with the following message: /ITL 192.168.0.5 7000 7001 7002 when it runs on a host which IP address is 192.168.0.5 using the default port numbers.","title":"Application management"},{"location":"refs/9-ITL/#ports-management","text":"ITLPortsMsg ComplexDiagram( Choice (0, Sequence ('port', NonTerminal('int32')), Sequence ('outport', NonTerminal('int32')), Sequence ('errport', NonTerminal('int32'))) ).addTo() Changes the UDP port numbers: port defines the listening port number, outport defines the port used to send replies to queries, errport defines the port used to send error messages. The int32 parameter should be a positive value in the range [1024-49150] . The default port , outport and errport values are 7000, 7001 and 7002. Note: Error messages are sent as a single string.","title":"Ports management"},{"location":"refs/9-ITL/#system-support","text":"ITLSystem ComplexDiagram( Sequence ('browse', NonTerminal('file')) ).addTo() browse open the file given as parameter using the system default browser. The message supports URLs that can be of type http:// , https:// or file:// . It supports also direct reference to a local file (e.g. myfile.html) that is translated into file:// url using the application rootPath.","title":"System support"},{"location":"refs/9-ITL/#application-level-queries","text":"The application supports the get messages for its parameters (see section getsect ). In addition, it provides the following messages to query version numbers or IP address. ITLRequest ComplexDiagram( Sequence ('get', Choice (0, 'version', 'guido-version', 'musicxml-version', 'IP', 'scount')) ).addTo() version : version number request. guido-version : Guido engine version number request. musicxml-version : MusicXML and Guido converter version numbers request. Returns \"not available\" when the library is not found. IP : the host IP address. scount : gives the count of scenes. Example Querying INScore version: /ITL get version; will give the following as output: /ITL version 1.34","title":"Application level queries"},{"location":"refs/9-ITL/#application-static-nodes","text":"The application level provides the static nodes stats , debug , log and ssl , available at /ITL/stats /ITL/debug , /ITL/log and /ITL/ssl .","title":"Application static nodes"},{"location":"refs/9-ITL/#the-stats-nodes","text":"ITLStats ComplexDiagram( Choice (0, 'get', 'reset') ).addTo() get gives the count of handled messages at OSC and UDP levels: the UDP count indicates the count of messages received from the network, the OSC count includes the UDP count and the messages received internally. reset resets the counters to zero. Note that querying the stats node increments at least the OSC the counter. Example Answer to a get message addressed to /ITL/stats /ITL/stats osc 15 udp 10","title":"The 'stats' nodes"},{"location":"refs/9-ITL/#the-debug-nodes","text":"The debug node is used to activate debugging information. ITLdebug ComplexDiagram( Sequence ('osc', NonTerminal('int23')) ).addTo() switch the debug mode ON or OFF. The parameter is interpreted as a boolean value. When in debug mode, INScore sends verbose messages to the OSC error port for every message that can't be correctly handled. Debugging is ON by default. Example Error messages generated on error port in debug mode: error: incorrect OSC address: /ITL/stat error: incorrect parameters: /ITL/scene/foo unknown 0.1 error: incorrect parameters: /ITL/scene/foo x \"incorrectType\"","title":"The 'debug' nodes"},{"location":"refs/9-ITL/#the-log-nodes","text":"The log node controls a console window that display all the messages sent to the OSC error port. Typical content is given by the example above. ITLLog ComplexDiagram( Choice (0, Sequence ('show', NonTerminal('int32')), 'clear', 'foreground', Sequence ('wrap', NonTerminal('int32')), Sequence ('write', OneOrMore (NonTerminal('arg'))), Sequence ('save', NonTerminal('string')), Sequence ('level', NonTerminal('int32')), Sequence ('scale', NonTerminal('float32'))) ).addTo() show show or hides the console. The parameter is a boolean value. clear clear the console window. foreground put the console window to front. wrap control line wrapping of the console. The parameter is a boolean value. write write the arg list formatted as a string to the log window. save save the current log content to a file. The parameter is a file name. When expressed as a relative path, the file is saved under the current application root path. level set the log level. Expected values are: 0 : no log 1 : log errors (default value) 2 : log errors and output of get messages scale scales the log window content. Default value is 1.0.","title":"The 'log' nodes"},{"location":"refs/9-ITL/#the-plugins-nodes","text":"The plugins node controls the search path for plugins. See section plugins for more information on plugins and search strategies. ITLPlugin ComplexDiagram( Choice (0, Sequence ('path', NonTerminal('folder')), 'reset') ).addTo() path add folder as a user path. The system will look for plugins in this folder first. reset clear the current user path.","title":"The 'plugins' nodes"},{"location":"refs/9-ITL/#the-ssl-node","text":"The ssl node is provided to manage certificates for encrypted communication with remote hosts. See section SSL for more details and section Forwarding for communication scheme.","title":"The 'ssl' node"},{"location":"web/1-introduction/","text":"Introduction Since version 1.27, the INScore engine is available as Javascript libraries: a WebAssembly [WASM] library providing all the services of the abstract INScore model, a Javascript library providing an HTML view of the INScore model. The web environment provides a very different runtime context than a native application: it is much more modular; due to the absence of a 'concrete machine' a number of INScore primitives do not make sense in a web environment; finally it provides new rendering capabilities with CSS. This document is intended to present the differences between the native and web versions of INScore. A special section is also devoted to the implementation of INScore Web in standalone HTML pages.","title":"Introduction"},{"location":"web/1-introduction/#introduction","text":"Since version 1.27, the INScore engine is available as Javascript libraries: a WebAssembly [WASM] library providing all the services of the abstract INScore model, a Javascript library providing an HTML view of the INScore model. The web environment provides a very different runtime context than a native application: it is much more modular; due to the absence of a 'concrete machine' a number of INScore primitives do not make sense in a web environment; finally it provides new rendering capabilities with CSS. This document is intended to present the differences between the native and web versions of INScore. A special section is also devoted to the implementation of INScore Web in standalone HTML pages.","title":"Introduction"},{"location":"web/2-mainDiffs/","text":"Main differences The OSC protocol is not supported in the Web version. As a result, the mode of communication with the INScore engine is different (see section communication ) and may also depend on the application that uses this engine. By default: the OSC output and error ports are redirected to the Javascript console. drag & drop works like in the native version: you can drop files or text to an INScore scene (an HTML div in the Web version). The log window (address /ITL/log ) is dependent on the host application. By default, input messages addressed to the log node are directed to the Javascript console. Optional components As the architecture of the web version is completely modular, the available objects depend on the host application: e.g. a page which wants to use objects in symbolic notation (type gmn ) will have to include the Guido library. This architecture allows applications to be optimized to fit their needs. It also facilitates the extension of the INScore engine. The table componentTbl presents the current supported components. Component Name Dependent types Guido Engine libGUIDOEngine.js gmn , gmnf , gmnstream , pianoroll , pianorollf , pianorollstream MusicXML library libmusicxml.js musicxml , musicxmlf use of MusicXML implies to have also the Guido Engine Faust compiler libfaust-wasm.js faust , faustf FaustLibrary.js Components required by specific objects Using files in a script You can use file based objects in an INScore script but the file path is interpreted differently: when using an absolute path, it refers to the document root of the HTTP server, when using a relative path, it refers to the location of the HTML page Note: Browsers infer a MIME type from the file extension and generally, download any file which extension is not recognized (this behavior depends on the browser you are using). It is therefore recommended to use a .txt extension for any textual resource with non-standard extension. For example, a score.gmn file could be renamed and used as score.gmn.txt .","title":"Global changes"},{"location":"web/2-mainDiffs/#main-differences","text":"The OSC protocol is not supported in the Web version. As a result, the mode of communication with the INScore engine is different (see section communication ) and may also depend on the application that uses this engine. By default: the OSC output and error ports are redirected to the Javascript console. drag & drop works like in the native version: you can drop files or text to an INScore scene (an HTML div in the Web version). The log window (address /ITL/log ) is dependent on the host application. By default, input messages addressed to the log node are directed to the Javascript console.","title":"Main differences"},{"location":"web/2-mainDiffs/#optional-components","text":"As the architecture of the web version is completely modular, the available objects depend on the host application: e.g. a page which wants to use objects in symbolic notation (type gmn ) will have to include the Guido library. This architecture allows applications to be optimized to fit their needs. It also facilitates the extension of the INScore engine. The table componentTbl presents the current supported components. Component Name Dependent types Guido Engine libGUIDOEngine.js gmn , gmnf , gmnstream , pianoroll , pianorollf , pianorollstream MusicXML library libmusicxml.js musicxml , musicxmlf use of MusicXML implies to have also the Guido Engine Faust compiler libfaust-wasm.js faust , faustf FaustLibrary.js Components required by specific objects","title":"Optional components"},{"location":"web/2-mainDiffs/#using-files-in-a-script","text":"You can use file based objects in an INScore script but the file path is interpreted differently: when using an absolute path, it refers to the document root of the HTTP server, when using a relative path, it refers to the location of the HTML page Note: Browsers infer a MIME type from the file extension and generally, download any file which extension is not recognized (this behavior depends on the browser you are using). It is therefore recommended to use a .txt extension for any textual resource with non-standard extension. For example, a score.gmn file could be renamed and used as score.gmn.txt .","title":"Using files in a script"},{"location":"web/3-unsupported/","text":"Unsupported Unsupported objects The table unsupportedTbl presents the objects that are not supported: Type Comment fileWatcher unsupported httpd unsupported server websocket unsupported server Faust plugins deprecated and redesigned (see section faustObjects ) Gesture follower unsupported Unsupported objects The following components are not yet implemented: graphic signals objects: graph , fastgraph , radialgraph Pianoroll stream: pianorollstream Misc.: grid Memory image: memimg Sensors: acceleromter , gyroscope , compass , etc. Unsupported messages A number of messages are not supported in the web version, either because they do not make sense in the runtime context or because they cannot be implemented. Common messages export , exportAll : not implemented shear , dshear : not implemented effect : colorize : not implemented edit : not implemented Application messages quit : do not make sense in the web environment rootPath : not implemented mouse : not yet implemented read : not implemented port , outport , errport : do not make sense without OSC Application log window As mentioned above, the log window (address /ITL/log ) is dependent on the host application. By default, input messages addressed to the log node are directed to the Javascript console. clear : dependent on the host application (do nothing by default) save : not supported foreground : dependent on the host application (do nothing by default) wrap : dependent on the host application (do nothing by default) scale : dependent on the host application (do nothing by default) write : dependent on the host application (write to the Javascript console by default) Scene messages foreground : dependent on the host application (do nothing by default) frameless windowOpacity : not supported Type specific messages brushstyle : not yet implemented Piano roll messages: not yet implemented Video get messages: not yet implemented SVG animate : not yet implemented Arc close : not yet implemented Line arrows : not yet implemented debug node: not yet implemented Symbolic score: columns rows : not supported pageFormat : not yet implemented get : pageCount systemCount : not yet implemented Synchronization The following synchronisation modes are not yet supported: Stretch modes: h , hv Events The following events are not yet supported: Touch events: touchBegin , touchEnd , touchUpdate Url events: success , error , cancel Score event: pageCount export : not supported since the export message is not supported endPaint : not supported","title":"Unsupported messages"},{"location":"web/3-unsupported/#unsupported","text":"","title":"Unsupported"},{"location":"web/3-unsupported/#unsupported-objects","text":"The table unsupportedTbl presents the objects that are not supported: Type Comment fileWatcher unsupported httpd unsupported server websocket unsupported server Faust plugins deprecated and redesigned (see section faustObjects ) Gesture follower unsupported Unsupported objects The following components are not yet implemented: graphic signals objects: graph , fastgraph , radialgraph Pianoroll stream: pianorollstream Misc.: grid Memory image: memimg Sensors: acceleromter , gyroscope , compass , etc.","title":"Unsupported objects"},{"location":"web/3-unsupported/#unsupported-messages","text":"A number of messages are not supported in the web version, either because they do not make sense in the runtime context or because they cannot be implemented.","title":"Unsupported messages"},{"location":"web/3-unsupported/#common-messages","text":"export , exportAll : not implemented shear , dshear : not implemented effect : colorize : not implemented edit : not implemented","title":"Common messages"},{"location":"web/3-unsupported/#application-messages","text":"quit : do not make sense in the web environment rootPath : not implemented mouse : not yet implemented read : not implemented port , outport , errport : do not make sense without OSC","title":"Application messages"},{"location":"web/3-unsupported/#application-log-window","text":"As mentioned above, the log window (address /ITL/log ) is dependent on the host application. By default, input messages addressed to the log node are directed to the Javascript console. clear : dependent on the host application (do nothing by default) save : not supported foreground : dependent on the host application (do nothing by default) wrap : dependent on the host application (do nothing by default) scale : dependent on the host application (do nothing by default) write : dependent on the host application (write to the Javascript console by default)","title":"Application log window"},{"location":"web/3-unsupported/#scene-messages","text":"foreground : dependent on the host application (do nothing by default) frameless windowOpacity : not supported","title":"Scene messages"},{"location":"web/3-unsupported/#type-specific-messages","text":"brushstyle : not yet implemented Piano roll messages: not yet implemented Video get messages: not yet implemented SVG animate : not yet implemented Arc close : not yet implemented Line arrows : not yet implemented debug node: not yet implemented Symbolic score: columns rows : not supported pageFormat : not yet implemented get : pageCount systemCount : not yet implemented","title":"Type specific messages"},{"location":"web/3-unsupported/#synchronization","text":"The following synchronisation modes are not yet supported: Stretch modes: h , hv","title":"Synchronization"},{"location":"web/3-unsupported/#events","text":"The following events are not yet supported: Touch events: touchBegin , touchEnd , touchUpdate Url events: success , error , cancel Score event: pageCount export : not supported since the export message is not supported endPaint : not supported","title":"Events"},{"location":"web/4-behavior/","text":"Behavioral changes Some messages behave differently with the Web version. save : download the INScore content to the file given as argument. You should find this file in your download folder.","title":"Behavioral changes"},{"location":"web/4-behavior/#behavioral-changes","text":"Some messages behave differently with the Web version. save : download the INScore content to the file given as argument. You should find this file in your download folder.","title":"Behavioral changes"},{"location":"web/5-newMessages/","text":"Specific new messages Leveraging CSS Cascading Style Sheets [CSS] are a powerful way to control the appearance of elements on a web page. The Web version of INScore provides a specific class message to use CSS in parallel to the standard mechanisms. This message is supported by all the INScore objects. classMsg ComplexDiagram( Sequence ('class', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('className'))))) ).addTo() 1: without argument, remove all class settings 2: set the CSS classes of an object Note: If a class message has not the expected effect, it's likely because the CSS properties of the target object are set by the standard INScore mechanisms (like color, border, font-size, etc.). As the own attributes of an object have precedence over the class of the object, the properties of the class are then ignored. You can force the properties of the class by adding the CSS rule !important which will override all previous styling rules for that specific property.","title":"Specific messages"},{"location":"web/5-newMessages/#specific-new-messages","text":"","title":"Specific new messages"},{"location":"web/5-newMessages/#leveraging-css","text":"Cascading Style Sheets [CSS] are a powerful way to control the appearance of elements on a web page. The Web version of INScore provides a specific class message to use CSS in parallel to the standard mechanisms. This message is supported by all the INScore objects. classMsg ComplexDiagram( Sequence ('class', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('className'))))) ).addTo() 1: without argument, remove all class settings 2: set the CSS classes of an object Note: If a class message has not the expected effect, it's likely because the CSS properties of the target object are set by the standard INScore mechanisms (like color, border, font-size, etc.). As the own attributes of an object have precedence over the class of the object, the properties of the class are then ignored. You can force the properties of the class by adding the CSS rule !important which will override all previous styling rules for that specific property.","title":"Leveraging CSS"},{"location":"web/6-MIDI/","text":"MIDI support A midi node is automatically created at application level ( /ITL/midi ). Before using the MIDI features, the midi node must be explicitly initialized using the init message. On success, the ready event is triggered, otherwise an error event is triggered. Example /ITL/midi watch ready ( do something to use the MIDI interface ); /ITL/midi watch error ( do something else ); /ITL/midi init; MIDI events MIDI is supported using a specific event that you can configure using the watch message. Before using MIDI, you should check that your browser is supporting the Web MIDI API. watchMIDI ComplexDiagram( Sequence ('watch', 'midi', NonTerminal('midifilter')) ).addTo() A filter is used to select the MIDI messages that will trigger the event. midifilter ComplexDiagram( Choice (0, Optional ( '*'), Sequence (Optional ( Sequence ('chan', NonTerminal('int32'))), Choice (0, NonTerminal('midikey'), Sequence ('prog', NonTerminal('int32')), Sequence ('ctrl', NonTerminal('int32'), NonTerminal('midivalue'))))) ).addTo() an empty filter can be used to stop watching MIDI input '*' denotes any MIDI message (no filter at all) chan : an optional channel number may be used to select only the MIDI messages on a given MIDI channel midikey: is used to select key on/off messages according to their values and to an optional velocity. prog : is used to select program change messages. A program change number is expected as next argument. ctrl : is used to select control change messages. A control change number is expected as next argument. Example Accept all MIDI messages that are on channel 0 /ITL/scene/obj watch midi chan 0 (inscore messages list); midikey ComplexDiagram( Sequence (Choice (0, 'keyon', 'keyoff'), NonTerminal('midivalue'), Optional ( Sequence ('vel', NonTerminal('midivalue')))) ).addTo() A MIDI key is either keyon or keyoff . It may be followed by an optional velocity selector. A MIDI value is either literal values or a range of values. midivalue ComplexDiagram( Choice (0, NonTerminal('literal'), NonTerminal('range')) ).addTo() literal ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('int32')), Sequence (Comment ('2'), '[', OneOrMore (NonTerminal('int32')), ']')) ).addTo() Literal values are: 1: a single value, 2: a list of space separated values enclosed in brackets, All the values must be in the MIDI data range (0-127). Example Accepting MIDI key on messages for 3 specific pitches. /ITL/scene/obj watch midi keyon [60 62 64] (inscore messages list); Range may be used when a value is within the specified range, or enters or leaves the range. range ComplexDiagram( Choice (0, Sequence (Comment ('1'), '(', NonTerminal('int32'), '-', NonTerminal('int32'), ')'), Sequence (Comment ('2'), Sequence (')', NonTerminal('int32'), '-', NonTerminal('int32'), '(')), Sequence (Comment ('3'), Sequence ('[', NonTerminal('int32'), '-', NonTerminal('int32'), ']'))) ).addTo() 1: trigger the event when the value enters the range. 2: trigger the event when the value leaves the range. 3: trigger the event when the value is within the range. Example Accepting keyon MIDI messages only when entering and leaving the range 60 - 67; /ITL/scene/obj watch midi keyon '[60-67]' (inscore messages list); /ITL/scene/obj watch midi keyon ']60-67[' (inscore messages list); MIDI verbose mode In order to facilitate the detection of messages sent by a MIDI interface, a 'verbose' mode allows incoming messages to be displayed on the browser console. To enable or disable verbose mode, a specific message must be sent to the /ITL/midi object: verbMIDI ComplexDiagram( Sequence ('verbose', NonTerminal('int32')) ).addTo() The parameter is a numerical value that controls which MIDI events are displayed: 0: disable the verbose mode 1: displays the channel MIDI events (Real-time and system exclusive events are filtered out). 2: displays all the MIDI events Example /ITL/midi verbose 1; Activates the MIDI verbose mode.","title":"MIDI support"},{"location":"web/6-MIDI/#midi-support","text":"A midi node is automatically created at application level ( /ITL/midi ). Before using the MIDI features, the midi node must be explicitly initialized using the init message. On success, the ready event is triggered, otherwise an error event is triggered. Example /ITL/midi watch ready ( do something to use the MIDI interface ); /ITL/midi watch error ( do something else ); /ITL/midi init;","title":"MIDI support"},{"location":"web/6-MIDI/#midi-events","text":"MIDI is supported using a specific event that you can configure using the watch message. Before using MIDI, you should check that your browser is supporting the Web MIDI API. watchMIDI ComplexDiagram( Sequence ('watch', 'midi', NonTerminal('midifilter')) ).addTo() A filter is used to select the MIDI messages that will trigger the event. midifilter ComplexDiagram( Choice (0, Optional ( '*'), Sequence (Optional ( Sequence ('chan', NonTerminal('int32'))), Choice (0, NonTerminal('midikey'), Sequence ('prog', NonTerminal('int32')), Sequence ('ctrl', NonTerminal('int32'), NonTerminal('midivalue'))))) ).addTo() an empty filter can be used to stop watching MIDI input '*' denotes any MIDI message (no filter at all) chan : an optional channel number may be used to select only the MIDI messages on a given MIDI channel midikey: is used to select key on/off messages according to their values and to an optional velocity. prog : is used to select program change messages. A program change number is expected as next argument. ctrl : is used to select control change messages. A control change number is expected as next argument. Example Accept all MIDI messages that are on channel 0 /ITL/scene/obj watch midi chan 0 (inscore messages list); midikey ComplexDiagram( Sequence (Choice (0, 'keyon', 'keyoff'), NonTerminal('midivalue'), Optional ( Sequence ('vel', NonTerminal('midivalue')))) ).addTo() A MIDI key is either keyon or keyoff . It may be followed by an optional velocity selector. A MIDI value is either literal values or a range of values. midivalue ComplexDiagram( Choice (0, NonTerminal('literal'), NonTerminal('range')) ).addTo() literal ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('int32')), Sequence (Comment ('2'), '[', OneOrMore (NonTerminal('int32')), ']')) ).addTo() Literal values are: 1: a single value, 2: a list of space separated values enclosed in brackets, All the values must be in the MIDI data range (0-127). Example Accepting MIDI key on messages for 3 specific pitches. /ITL/scene/obj watch midi keyon [60 62 64] (inscore messages list); Range may be used when a value is within the specified range, or enters or leaves the range. range ComplexDiagram( Choice (0, Sequence (Comment ('1'), '(', NonTerminal('int32'), '-', NonTerminal('int32'), ')'), Sequence (Comment ('2'), Sequence (')', NonTerminal('int32'), '-', NonTerminal('int32'), '(')), Sequence (Comment ('3'), Sequence ('[', NonTerminal('int32'), '-', NonTerminal('int32'), ']'))) ).addTo() 1: trigger the event when the value enters the range. 2: trigger the event when the value leaves the range. 3: trigger the event when the value is within the range. Example Accepting keyon MIDI messages only when entering and leaving the range 60 - 67; /ITL/scene/obj watch midi keyon '[60-67]' (inscore messages list); /ITL/scene/obj watch midi keyon ']60-67[' (inscore messages list);","title":"MIDI events"},{"location":"web/6-MIDI/#midi-verbose-mode","text":"In order to facilitate the detection of messages sent by a MIDI interface, a 'verbose' mode allows incoming messages to be displayed on the browser console. To enable or disable verbose mode, a specific message must be sent to the /ITL/midi object: verbMIDI ComplexDiagram( Sequence ('verbose', NonTerminal('int32')) ).addTo() The parameter is a numerical value that controls which MIDI events are displayed: 0: disable the verbose mode 1: displays the channel MIDI events (Real-time and system exclusive events are filtered out). 2: displays all the MIDI events Example /ITL/midi verbose 1; Activates the MIDI verbose mode.","title":"MIDI verbose mode"},{"location":"web/7-audioObjects/","text":"Audio Audio objects Audio objects are connectable objects i.e. objects which output can be connected to the input of another audio object. In the INScore model, the following objects are audio objects: audio , video , faust (see section faustObjects ) and audioio (see section audioioObjects ). Audio objects support the following messages: audioMsgs ComplexDiagram( Sequence (Choice (0, 'connect', 'disconnect'), OneOrMore (Choice (0, Sequence (Comment ('1'), NonTerminal('destination')), Sequence (Comment ('2'), NonTerminal('int32'), ':', NonTerminal('destination'), ':', NonTerminal('int32'))))) ).addTo() connect : connect the outputs of the object to the destination inputs. destination must be another audio object. Without numeric prefix and suffix [1], the connexion may be subject of up or down mixing as specified by the Web Audio API . The destination supports regular expressions. The second form [2] connects an output channel to the a destination input channel. The first number refers to the target object channel, the second one to the destination channel. Channels are indexed from 1, using 0 is equivalent to all channels (that are then mixed together). See the examples below. disconnect : disconnect the outputs of the object from the destination inputs. Note that errors (e.g. no existing connection with the destination) are silently ignored. Example Connect the first channel of an audio object to the second channel of the audio output : /ITL/scene/obj connect '1:audioOutput:2'; Connect all channels of an audio object to the first channel of the audio output : /ITL/scene/obj connect '0:audioOutput:1'; Note: The messages /ITL/scene/obj connect '0:dest:0'; is equivalent to /ITL/scene/obj connect dest; Note: The connect message assumes that the source and destination are located in the same hierarchy (i.e. they have the same parent). audiogetMsgs ComplexDiagram( Sequence ('get', Choice (0, 'connect', 'in', 'out')) ).addTo() in : gives the number of inputs of the audio object out : gives the number of outputs of the audio object Faust objects Faust is a functional programming language for sound synthesis and audio processing. Faust objects are available, providing that the Faust library has been loaded. Warning A page containing Faust objects require an https connection, unless it runs on localhost. Creating a Faust object The faust or faustf types must be used to create a Faust object. Note: The faust type exists with the native version but to load a pre-compiled DSP. faustdsp and faustdspf types are not supported. setFaust ComplexDiagram( Sequence ('set', Choice (0, Sequence (Comment ('1'), 'faust', Optional ( NonTerminal('int32')), NonTerminal('dspCode')), Sequence (Comment ('2'), 'faustf', Optional ( NonTerminal('int32')), NonTerminal('dspFile')), Sequence (Comment ('3'), 'faustw', Optional ( NonTerminal('int32')), NonTerminal('wasmFile'), NonTerminal('jsonFile')))) ).addTo() The expected arguments of the set message are: an optional integer that indicates a number of voices used to create a polyphonic DSP (see section webFaustPoly ). Note that when present, a polyphonic DSP is created even if equal to 1. 1: Faust DSP code (see the Faust language for more information). 2: a Faust DSP file. 3: a Faust pre-compiled wasm file and the associated json file. Note that theses files can be generated using the get wasm message (see section webFaustMsgs ). By default, a Faust DSP appears as a browsable block diagram. Note: The Faust language uses characters that have a special meaning in HTML: for example, with the split operator <: , the ' < ' character will be interpreted as an opening HTML tag and you should use HTML escapes (e.g. &lt; instead of < ). This is necessary for inline DSP code only, DSP files are not concerned. Faust messages Faust objects are active by default, i.e. the output signals is computed whatever the audio connection state. However, it is possible to disable the signals computation when it is not needed (e.g. for objects that are only temporarily active), which allows a large number of faust objects to be embedded in a score, while saving a significant CPU. The compute message is provided in this intend. faustMsgs ComplexDiagram( Choice (0, Sequence ('compute', NonTerminal('int32')), Sequence ('autoOff', NonTerminal('int32'))) ).addTo() compute : start or stop computing the audio signals. The parameter is a boolean value. Default value is 1. autoOff : automatically switch buttons Faust UI elements back to off. The parameter is a boolean value. Default value is 0. Faust objects support the audio objects messages plus additional query messages: faustgetMsgs ComplexDiagram( Sequence ('get', Choice (0, 'ui', 'wasm')) ).addTo() ui : gives the Faust processor parameters (see section webFaustParams ) i.e. for each parameter: its OSC address followed by the parameter UI type, a label, the minimum and maximum values and the parameter step. wasm : generates the Faust dsp as a precompiled wasm file with the associated json file. The Faust object name is used for the files name. On output, the files xxx.wasm and xxx.json should be present in the local download folder (where xxx is the Faust object name). Faust objects parameters A Faust DSP code can declare UI elements that are used by architecture files to build controllers providing users with dynamic control of the DSP parameters. In INScore, DSP UI elements are used to extend the Faust object address space. For example, when a DSP code declares a UI element named 'Volume', a Faust object which address is /ITL/scene/dsp is extended as /ITL/scene/dsp/Volume . Faust parameters support two types of messages: faustParamMsgs ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('float32')), Sequence (Comment ('2'), 'get')) ).addTo() 1: set the parameter value 2: gives the parameter value Polyphonic objects Polyphonic objects (i.e. Faust objects created using the optional voice number) support additional messages: faustPolyMsgs ComplexDiagram( Choice (0, Sequence (Choice (0, 'keyOn', 'keyOff'), NonTerminal('chan'), NonTerminal('pitch'), NonTerminal('vel')), 'allNotesOff') ).addTo() keyOn and keyOff messages take 3 integer parameters: a MIDI channel, the note pitch and the velocity. allNotesOff : similar to MIDI all notes off message Audio Input / Output Audio input / output objects are provided as audio object (see section audioObjects ) to represent the physical audio inputs and outputs, in order to homogenize the connection process. An audio input / output type is audioio . It is created with a number of inputs and outputs as arguments. audioioMsgs ComplexDiagram( Sequence ('set', 'audioio', NonTerminal('int32'), NonTerminal('int32')) ).addTo() Note: The current Javascript implementation automatically creates an audio input objet named audioInput and an audio output object named audioOutput . Thus the names audioInput and audioOutput are reserved and you must not use them. audioOutput and audioInput are created on audio request only, i.e. when an audio object is created ( audio , video or faust ). Note: About I/O OSC addresses Since audio connections can only be made between objects that are in the same hierarchy, audioOutput and audioInput objects are created in all hierarchies that contain audio objects. For example, by creating an faust object in the /ITL/scene/folder hierarchy, audio I/O will be created at /ITL/scene/folder/audioInput and /ITL/scene/folder/audioOutput . Thus audio I/O objects may appear at different levels of a scene. Audio Input By default, the audioInput object is created with 0 inputs. It must be explicitly initialized using the init message. On success, the ready event is triggered and the number of input channels is set, otherwise an error event is triggered. This initialization is intended to avoid capturing the audio input when not used. Example /ITL/scene/audioInput watch ready ( do something to use the audio input ); /ITL/scene/audioInput watch error ( do something else ); /ITL/scene/audioInput init;","title":"Audio objects"},{"location":"web/7-audioObjects/#audio","text":"","title":"Audio"},{"location":"web/7-audioObjects/#audio-objects","text":"Audio objects are connectable objects i.e. objects which output can be connected to the input of another audio object. In the INScore model, the following objects are audio objects: audio , video , faust (see section faustObjects ) and audioio (see section audioioObjects ). Audio objects support the following messages: audioMsgs ComplexDiagram( Sequence (Choice (0, 'connect', 'disconnect'), OneOrMore (Choice (0, Sequence (Comment ('1'), NonTerminal('destination')), Sequence (Comment ('2'), NonTerminal('int32'), ':', NonTerminal('destination'), ':', NonTerminal('int32'))))) ).addTo() connect : connect the outputs of the object to the destination inputs. destination must be another audio object. Without numeric prefix and suffix [1], the connexion may be subject of up or down mixing as specified by the Web Audio API . The destination supports regular expressions. The second form [2] connects an output channel to the a destination input channel. The first number refers to the target object channel, the second one to the destination channel. Channels are indexed from 1, using 0 is equivalent to all channels (that are then mixed together). See the examples below. disconnect : disconnect the outputs of the object from the destination inputs. Note that errors (e.g. no existing connection with the destination) are silently ignored. Example Connect the first channel of an audio object to the second channel of the audio output : /ITL/scene/obj connect '1:audioOutput:2'; Connect all channels of an audio object to the first channel of the audio output : /ITL/scene/obj connect '0:audioOutput:1'; Note: The messages /ITL/scene/obj connect '0:dest:0'; is equivalent to /ITL/scene/obj connect dest; Note: The connect message assumes that the source and destination are located in the same hierarchy (i.e. they have the same parent). audiogetMsgs ComplexDiagram( Sequence ('get', Choice (0, 'connect', 'in', 'out')) ).addTo() in : gives the number of inputs of the audio object out : gives the number of outputs of the audio object","title":"Audio objects"},{"location":"web/7-audioObjects/#faust-objects","text":"Faust is a functional programming language for sound synthesis and audio processing. Faust objects are available, providing that the Faust library has been loaded. Warning A page containing Faust objects require an https connection, unless it runs on localhost.","title":"Faust objects"},{"location":"web/7-audioObjects/#creating-a-faust-object","text":"The faust or faustf types must be used to create a Faust object. Note: The faust type exists with the native version but to load a pre-compiled DSP. faustdsp and faustdspf types are not supported. setFaust ComplexDiagram( Sequence ('set', Choice (0, Sequence (Comment ('1'), 'faust', Optional ( NonTerminal('int32')), NonTerminal('dspCode')), Sequence (Comment ('2'), 'faustf', Optional ( NonTerminal('int32')), NonTerminal('dspFile')), Sequence (Comment ('3'), 'faustw', Optional ( NonTerminal('int32')), NonTerminal('wasmFile'), NonTerminal('jsonFile')))) ).addTo() The expected arguments of the set message are: an optional integer that indicates a number of voices used to create a polyphonic DSP (see section webFaustPoly ). Note that when present, a polyphonic DSP is created even if equal to 1. 1: Faust DSP code (see the Faust language for more information). 2: a Faust DSP file. 3: a Faust pre-compiled wasm file and the associated json file. Note that theses files can be generated using the get wasm message (see section webFaustMsgs ). By default, a Faust DSP appears as a browsable block diagram. Note: The Faust language uses characters that have a special meaning in HTML: for example, with the split operator <: , the ' < ' character will be interpreted as an opening HTML tag and you should use HTML escapes (e.g. &lt; instead of < ). This is necessary for inline DSP code only, DSP files are not concerned.","title":"Creating a Faust object"},{"location":"web/7-audioObjects/#faust-messages","text":"Faust objects are active by default, i.e. the output signals is computed whatever the audio connection state. However, it is possible to disable the signals computation when it is not needed (e.g. for objects that are only temporarily active), which allows a large number of faust objects to be embedded in a score, while saving a significant CPU. The compute message is provided in this intend. faustMsgs ComplexDiagram( Choice (0, Sequence ('compute', NonTerminal('int32')), Sequence ('autoOff', NonTerminal('int32'))) ).addTo() compute : start or stop computing the audio signals. The parameter is a boolean value. Default value is 1. autoOff : automatically switch buttons Faust UI elements back to off. The parameter is a boolean value. Default value is 0. Faust objects support the audio objects messages plus additional query messages: faustgetMsgs ComplexDiagram( Sequence ('get', Choice (0, 'ui', 'wasm')) ).addTo() ui : gives the Faust processor parameters (see section webFaustParams ) i.e. for each parameter: its OSC address followed by the parameter UI type, a label, the minimum and maximum values and the parameter step. wasm : generates the Faust dsp as a precompiled wasm file with the associated json file. The Faust object name is used for the files name. On output, the files xxx.wasm and xxx.json should be present in the local download folder (where xxx is the Faust object name).","title":"Faust messages"},{"location":"web/7-audioObjects/#faust-objects-parameters","text":"A Faust DSP code can declare UI elements that are used by architecture files to build controllers providing users with dynamic control of the DSP parameters. In INScore, DSP UI elements are used to extend the Faust object address space. For example, when a DSP code declares a UI element named 'Volume', a Faust object which address is /ITL/scene/dsp is extended as /ITL/scene/dsp/Volume . Faust parameters support two types of messages: faustParamMsgs ComplexDiagram( Choice (0, Sequence (Comment ('1'), NonTerminal('float32')), Sequence (Comment ('2'), 'get')) ).addTo() 1: set the parameter value 2: gives the parameter value","title":"Faust objects parameters"},{"location":"web/7-audioObjects/#polyphonic-objects","text":"Polyphonic objects (i.e. Faust objects created using the optional voice number) support additional messages: faustPolyMsgs ComplexDiagram( Choice (0, Sequence (Choice (0, 'keyOn', 'keyOff'), NonTerminal('chan'), NonTerminal('pitch'), NonTerminal('vel')), 'allNotesOff') ).addTo() keyOn and keyOff messages take 3 integer parameters: a MIDI channel, the note pitch and the velocity. allNotesOff : similar to MIDI all notes off message","title":"Polyphonic objects"},{"location":"web/7-audioObjects/#audio-input-output","text":"Audio input / output objects are provided as audio object (see section audioObjects ) to represent the physical audio inputs and outputs, in order to homogenize the connection process. An audio input / output type is audioio . It is created with a number of inputs and outputs as arguments. audioioMsgs ComplexDiagram( Sequence ('set', 'audioio', NonTerminal('int32'), NonTerminal('int32')) ).addTo() Note: The current Javascript implementation automatically creates an audio input objet named audioInput and an audio output object named audioOutput . Thus the names audioInput and audioOutput are reserved and you must not use them. audioOutput and audioInput are created on audio request only, i.e. when an audio object is created ( audio , video or faust ). Note: About I/O OSC addresses Since audio connections can only be made between objects that are in the same hierarchy, audioOutput and audioInput objects are created in all hierarchies that contain audio objects. For example, by creating an faust object in the /ITL/scene/folder hierarchy, audio I/O will be created at /ITL/scene/folder/audioInput and /ITL/scene/folder/audioOutput . Thus audio I/O objects may appear at different levels of a scene.","title":"Audio Input / Output"},{"location":"web/7-audioObjects/#audio-input","text":"By default, the audioInput object is created with 0 inputs. It must be explicitly initialized using the init message. On success, the ready event is triggered and the number of input channels is set, otherwise an error event is triggered. This initialization is intended to avoid capturing the audio input when not used. Example /ITL/scene/audioInput watch ready ( do something to use the audio input ); /ITL/scene/audioInput watch error ( do something else ); /ITL/scene/audioInput init;","title":"Audio Input"},{"location":"web/8-communication/","text":"Communication scheme INScore forwarding mechanism supports http and ws protocols since version 1.27. Since these protocols are connection based, a counterpart connect message is provided with the Web version. connectMsg ComplexDiagram( Sequence ('connect', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('remoteHost'))))) ).addTo() 1) removes the existing set of connections, 2) connect to a list of remote hosts. Once the connection is established, the local INScore engine may receive messages from the remote hosts. To establish the connection, the remote hosts must have set a forwarding mechanism using the same protocol with the same port number. remoteHost ComplexDiagram( OneOrMore (Sequence (Choice (0, Sequence (Comment ('1'), 'http://'), Sequence (Comment ('2'), 'https://'), Sequence (Comment ('3'), 'ws://')), NonTerminal('hostname'), ':', NonTerminal('portnum'))) ).addTo() 1) uses http as communication protocol, 2) uses https , 3) uses websockets . Web messages format Messages emitted by the http and ws forwarding mechanism and received by connected clients are encoded in JSON and transmitted as base64 encoded packets. The JSON format is the following: { 'id' : number , 'method' : 'post' , 'data' : textual inscore messages } id : is a packet unique identifier (currently unused) method : value must be 'post' data : must contain a valid inscore script Although the native version of INScore supports this format for the http , https and ws protocols, nothing prohibits another application to control INScore web pages, provided that the format described above is respected.","title":"Communication"},{"location":"web/8-communication/#communication-scheme","text":"INScore forwarding mechanism supports http and ws protocols since version 1.27. Since these protocols are connection based, a counterpart connect message is provided with the Web version. connectMsg ComplexDiagram( Sequence ('connect', Choice (0, Comment ('1'), Sequence (Comment ('2'), OneOrMore (NonTerminal('remoteHost'))))) ).addTo() 1) removes the existing set of connections, 2) connect to a list of remote hosts. Once the connection is established, the local INScore engine may receive messages from the remote hosts. To establish the connection, the remote hosts must have set a forwarding mechanism using the same protocol with the same port number. remoteHost ComplexDiagram( OneOrMore (Sequence (Choice (0, Sequence (Comment ('1'), 'http://'), Sequence (Comment ('2'), 'https://'), Sequence (Comment ('3'), 'ws://')), NonTerminal('hostname'), ':', NonTerminal('portnum'))) ).addTo() 1) uses http as communication protocol, 2) uses https , 3) uses websockets .","title":"Communication scheme"},{"location":"web/8-communication/#web-messages-format","text":"Messages emitted by the http and ws forwarding mechanism and received by connected clients are encoded in JSON and transmitted as base64 encoded packets. The JSON format is the following: { 'id' : number , 'method' : 'post' , 'data' : textual inscore messages } id : is a packet unique identifier (currently unused) method : value must be 'post' data : must contain a valid inscore script Although the native version of INScore supports this format for the http , https and ws protocols, nothing prohibits another application to control INScore web pages, provided that the format described above is respected.","title":"Web messages format"}]}
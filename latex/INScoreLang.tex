
\documentclass[a4paper,twoside]{report}
\usepackage{INScore}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage{pslatex}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{rail}
\usepackage{makeidx}
\usepackage{color}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{multicol}
\usepackage{textcomp}


\definecolor{mycolor}{rgb}{0.384,0.0,0.145}
\hypersetup{
	colorlinks=true,
	linkcolor= mycolor
}


\setlength\parskip{\medskipamount}

\makeatletter
\railparam{\addtolength{\itemsep}{-3ex}}

%\newcommand{\toplevel}[1]	{\section{#1}}
%\newcommand{\sublevel}[1]	{\subsection{#1}}
%\newcommand{\subsublevel}[1]	{\subsubsection{#1}}

\newcommand{\toplevel}[1]	{\chapter{#1}}
\newcommand{\sublevel}[1]	{\section{#1}}
\newcommand{\subsublevel}[1]	{\subsection{#1}}

\newcommand{\fullref}[1]	{\ref{#1} p.\pageref{#1}}

\providecommand{\boldsymbol}[1]{\mbox{\boldmath $#1$}}
\newcommand{\OSC}[1]		{\texttt{#1}}
\newcommand{\values}[1]		{\texttt{#1}}
\newcommand{\oldexample}	{\hspace*{1cm}}
\newcommand{\example}		{\textbf{\hspace{-1.5cm}\textbf{\textsc{Example }}}}
\newcommand{\note}	[1]		{\vspace{2mm}\textbf{\hspace{-0.9cm}\textbf{\textsc{Note #1}}}}
\newcommand{\warning}[1]	{\vspace{2mm}\textbf{\hspace{-1.5cm}\textbf{\textsc{Warning #1}}}}

\renewcommand{\seealso}		{\textbf{See also: }}

\newcommand{\osctype}[1]	{\textbf{\texttt{{\small #1}}}}
\newcommand{\oscint}		{\osctype{int32}}
\newcommand{\oscfloat}		{\osctype{float32}}
\newcommand{\oscstring}		{\osctype{string}}
\newcommand{\rational}		{\osctype{rational}}
\newcommand{\lowTilde} 		{\texttildelow}
\newcommand{\icomment} 		{\#}

\let\olditemize\itemize
\let\oldenditemize\enditemize
\renewenvironment{itemize} 	{\olditemize \setlength{\itemsep}{1mm}}{\oldenditemize}


\setlength\parskip{2pt}
\setlength\railnamesep{-1mm}
\railterm{int32, float32, string}
\railalias{int32}{\oscint}
\railalias{float32}{\oscfloat}
\railalias{string}{\oscstring}


\definecolor{mygrey}{gray}{0.93}
\newcommand{\sample}	[1]			{\vspace{-2mm}\begin{center}\colorbox{mygrey}{
								\begin{minipage}[t]{0.9\columnwidth} 
								{\small \texttt{#1}}
								\end{minipage}}\end{center}}
\newcommand{\samplev}[1]			{\begin{center}\colorbox{mygrey}{
								\begin{minipage}[t]{\columnwidth} 
								{\small \texttt{#1}}
								\end{minipage}}\end{center}}
\newcommand{\sampleindent}	{ \hspace{0.5cm} }


\makeatother
\makeindex


\begin{document}

\title{INScore v.1.27 \\ - \\ Scripting language}

\author{D. Fober\\ GRAME\\ Centre national de cr√©ation musicale\\
{\small <fober@grame.fr>} \\
%\vspace{2mm}
%ANR-08-CORD-010
}

\maketitle

%\vspace*{17.5cm}
 

{\small INScore research and development has been funded by the French National Research Agency [ANR]\\ Interlude project [ANR- 08-CORD-010] and INEDIT project [ANR-12-CORD-0009].}
  

\pagestyle{empty}
\cleardoublepage
\tableofcontents

\thispagestyle{empty}
\pagestyle{plain}

\newpage

\setcounter{page}{1}


%===============================
%:Scripting
\toplevel{INScore Scripting Language}
\label{scripting}

%===============================
%:    Introduction
\sublevel{Introduction}
\label{introduction}

INScore scripting language is based on a textual version of OSC messages, extended with variables, Javascript sections and Mathematical expressions.
INScore scripts files are expected to carry a \OSC{.inscore} extension. You can drop them to the INScoreViewer application or to any opened INScore scene.

The application or scene state can be saved (using the \OSC{save} message) as files containing textual OSC messages. These files can be edited or created from scratch using any text editor. 

%===============================
%:    Statements
\sublevel{Statements}
\label{scriptstatement}
An INScore file is a list of textual expressions. An expression is:
\begin{itemize}
\item a message: basically a textual OSC message extended to support URL like addresses and variables as parameters.
\item a variable declaration.
\item a foreign language script that may generate messages as output.
\item an end marker '\OSC{\_\_END\_\_}' to declare a script end. After the marker, the remaining part of the script will be ignored.
\end{itemize}

\index{Scripting!expressions}

\begin{rail}
expression :  
		 	message ";"
		| 	variabledecl ";"
		| 	script
		|   end
\end{rail}

Messages and variables declarations must be followed by a semicolon that is used as statements separator.

%===============================
%:    Messages
\sublevel{Messages}
\label{scriptmsgs}

Messages are basic OSC messages that support an OSC address extension scheme and relative addresses that are described below.
Messages parameters can be replaced by variables that are evaluated at parsing level. Variables are described in section \ref{scriptvar}.

Using the address extension scheme, a script may be designed to initialize an INScore scene and external applications as well, including on remote hosts.

\subsublevel{Extended OSC addresses}
\label{extaddress}





\example\\
Initializing a score and an external application listening on port 12000 and running on a remote host named \OSC{host.adomain.net}.
\sample{/ITL/scene/score set gmnf 'myscore.gmn';\\
host.adomain.net:12000/run 1;
}

Relative addresses have been introduced to provide more flexibility in the score design process. A relative address starts with '\OSC{./}'. It is evaluated in the context of the message receiver: a legal OSC address is dynamically constructed using the receiver address that is used to prefix the relative address. 

\example
\sample{the relative address \hspace*{3mm}./score \\
addressed to \hspace*{15.4mm}/ITL/scene/layer\\
will be evaluted as \hspace*{4mm}/ITL/scene/layer/score
}

The receiver context may be:
\begin{itemize}
\item the INScore application address (i.e. \OSC{/ITL}) for messages enclosed in a file loaded at application level (using the \OSC{load} message addressed to the application) or for files dropped to the application or given as arguments of the INScoreViewer application.
\item a scene address for messages enclosed in a file loaded at scene level (using the \OSC{load} message addressed to a scene) or for files or messages dropped to a scene window.
\item any object address when the messages are passed as arguments of an \OSC{eval} message (see section \fullref{miscmsgs}).
\end{itemize}

\example\\
Using a set of messages in different contexts:
\sample{score = (\\
\hspace*{5mm}./score set gmn '[a f g]', \\
\hspace*{5mm}./score scale 2.\\
);\\
/ITL/scene/l1 eval \$score;\\
/ITL/scene/l2 eval \$score;
}

\note{}\\
Legal OSC addresses that are given as argument of an \OSC{eval} message are not affected by the evaluation.


%===============================
%:    types
\sublevel{Types}
\label{scripttypes}

Using OSC, the message parameters are typed by the OSC protocol. 
With their textual version, any parameter is converted to an OSC type (i.e. int32, float or string) at parsing level.
A special attention must be given to strings in order to discriminate addresses and parameters. Strings intended as parameters must:
\begin{itemize}
\item be quoted, using single or double quotes. Note that an ambiguous quote included in a string can be escaped using a '\verb+\+'.
\item or make use of the following characters set: \OSC{[-a-zA-Z0-9]+} or \OSC{[\_a-zA-Z][\_a-zA-Z0-9]*}.
 \end{itemize}

\example \\
Different string parameter
\sample{/ITL/scene/text set txt "Hello world";  \icomment string including a space must be quoted \\
/ITL/scene/img set file 'anImage.png';  \icomment dots must be quoted too \\
/ITL/scene/foo set txt no\_quotes\_needed;
}


%===============================
%:    Variables
\sublevel{Variables}
\label{scriptvar}

A variable declaration associates a name with a list of parameters or a list of messages.
Parameters must follow the rules given in section \ref{scripttypes}. They may include previously declared variables. A message list must be enclosed in parenthesis and a comma must be used as messages separator.

\index{Scripting! variable}

\begin{rail} 
variabledecl : 'ident' '=' ( (param | variable) +
					| '(' (message + ',') ')' ) ';'
\end{rail}

\example \\
Variables declarations
\sample{color = 200 200 200; \\
colorwithalpha = \$color 100; \icomment using another variable \\
msgsvar= ( \hspace*{2.7cm}  \icomment a variable referring to a message list \\
\hspace*{1cm} localhost:7001/world "Hello world", \\
\hspace*{1cm} localhost:7001/world "how are you ?" );
}


A variable may be used in place of any message parameter. A reference to a variable must have the form \OSC{\$ident} where \OSC{ident} is a previously declared variable. A variable is evaluated at parsing level and replaced by its content.

\example \\
Using a variable to share a common position:
\sample{x = 0.5;\\
/ITL/scene/a x \$x;\\
/ITL/scene/b x \$x;
}

Variables can be used in interaction messages as well, which may also use the variables available in the interaction context (see section \fullref{interactvar}). To differentiate between a \emph{script} and an \emph{interaction} variable, the latter must be quoted to be passed as strings and to prevent their evaluation by the parser. 

\example \\
Using variables in interaction messages: \$sx is evaluated at event occurrence	and \$y is evaluated at parsing level.
\sample{y = 0.5;\\
/ITL/scene/foo watch mouseDown (/ITL/scene/foo "\$sx" \$y);
}

%===============================
%:    Environnement variables
\sublevel{Environnement variables}
\label{envvar}

Environnement variables are predefined variables available in a script context. They provide information related to the current context. Current environment variables are:
\begin{itemize}
\item \textbf{\OSC{OSName}}: gives the current operating system name. The value is among \OSC{"MacOS"}, \OSC{"Windows"}, \OSC{"Linux"}, \OSC{"Android"} and \OSC{"iOS"}.
\item \textbf{\OSC{OSId}} : gives the current operating system as a numeric identifier. Returned value is (in alphabetic order): 
\begin{itemize}
\item 1 for Android
\item 2 for iOS.
\item 3 for Linux, 
\item 4 for MacOS, 
\item 5 for Windows, 
\end{itemize}
\end{itemize}

\note\\
There is nothing to prevent overriding of an environment variable. It's the script responsibility to handle variable names collisions.


%===============================
%:    Message based parameters
\sublevel{Message based parameters}
\label{scriptmsgparam}

Similarly to message based variables (see section \fullref{msgvar}), a message parameter may also use the result of a \OSC{get} message as parameters specified like a message based variable.
The message must be enclosed in parameters with a leading \$ sign.

\index{Scripting! message based parameters}

\begin{rail} 
msgparam : '(' (message) ')'
\end{rail}

\example \\
Displaying INScore version using a message parameter:
\sample{/ITL/scene/version set  txt "INScore version is" \$(/ITL get version);}

\note{}\\
Message based parameters are evaluated by the parser. Thus when the system state is modified by a script before a message parameter, these modifications won't be visible at the time of the parameter evaluation because all the messages will be processed by the next time task. For example:\\
\sample{/ITL/scene/obj x 0.1;\\
/ITL/scene/foo x \$(/ITL/scene/foo get x);
}
x position of \OSC{/ITL/scene/foo} will be set to x position of \OSC{/ITL/scene/obj} at the time of the script evaluation (that may be different to 0.1).

%===============================
%:    languages
\sublevel{Languages}
\label{scriptlang}

\index{Scripting!javascript}
%\index{Scripting!lua}

INScore supports Javascript and Lua as scripting languages. Javascript is embedded by default (using the Qt Javascript engine). INScore needs to be recompiled to embed the Lua engine\footnote{\url{http://www.lua.org/}}. A script section is indicated similarly to a Javascript section in html i.e. enclosed in an opening \OSC{<?} and a closing \OSC{?>}.

\index{Scripting! javascript}
%\index{Scripting! lua}

\begin{rail} 
script : '<?' ('javascript' | 'lua') script '?>'
\end{rail}

The principle of using an embedded programming language in script files is the following: \emph{javascript} or \emph{lua} sections are given to the corresponding engine and are expected to produce INScore messages on output.
These messages are then parsed as if replacing the corresponding script section.

Note that INScore variables are exported to the current language environment.

\example
\sample{
<?javascript \\
\hspace*{3mm} "/ITL/scene/version set 'txt' 'Javascript v."  + version() + "';"; \\
\hspace*{1mm} ?>
}

A single persistent context is created at application level and shared to each scene.

\note Lua support is going to be deprecated and should be removed in a future release.

%===============================
%:    The Javascript objects
\subsublevel{The Javascript object}
\label{jsobj}

The Javascript engine is available at runtime at the address \OSC{/ITL/\textit{scene}/javascript}. It has a \OSC{run} method that takes a javascript string as parameter.

\index{Scripting! javascript! run}

\begin{rail} 
javascript :  'run' 'code'
\end{rail}

The \OSC{run} method evaluates the code. Similarly to javascript sections in scripts, the output of the evaluation is expected to be a string containing valid INScore messages that are next executed. 
Actually, including a javascript section in a script is equivalent to send the \OSC{run} message with the same code as parameter to the javascript object.

The Javascript engine is based on the Qt5 Javascrip engine, extended with additional functions:
\begin{itemize}
\item \textbf{\OSC{version()}} : gives the javascript engine version number as a string.
\item \textbf{\OSC{print(val1 [, val2 [, ...]])}} : print the arguments to the OSC standard output. The arguments list is prefixed by 'javascript:'. The function is provided for debug purpose.
\item \textbf{\OSC{readfile(file)}} : read a file and returns its content as a string. The file name could be specified as an absolute or relative path. When relative, the file is searched in the application current \OSC{rootPath} (see section \fullref{applmgmt}).
\item \textbf{\OSC{post(address [,...])}} : build an OSC message and post it for delayed processing i.e. to be processed by the next time task. \OSC{address} is an OSC or an extended OSC address. Optional arguments are the message parameters.
\item \textbf{\OSC{osname()}} : gives the current operating system name. Returned value is among \OSC{"MacOS"}, \OSC{"Windows"}, \OSC{"Linux"}, \OSC{"Android"} and \OSC{"iOS"}.
\item \textbf{\OSC{osid()}} : gives the current operating system as a num√©ric identifiant. Returned value is (in alphabetic order): 
\begin{itemize}
\item 1 for Android
\item 2 for iOS.
\item 3 for Linux, 
\item 4 for MacOS, 
\item 5 for Windows, 
\end{itemize}
\end{itemize}


\example
\sample{
<?javascript \\
\hspace*{3mm} post ("/ITL/scene/obj", "dalpha", -1);";\\ 
\hspace*{3mm} \# The message /ITL/scene/obj dalpha -1 \\
\hspace*{3mm} \# will be evaluated by the next time task. \\
?>
}

\example
\sample{
<?javascript \\
\hspace*{3mm} \# declare a function foo() \\
\hspace*{3mm} function foo(arg) \{\\ 
\hspace*{6mm}  return "/ITL/scene/obj set txt foo called with " + arg + ";"; \\
\hspace*{3mm} \} \\
?>\\
\\
\# call the foo function \\
<?javascript foo(1)?>\\
\\
\# or call the foo function using the run message \\
/ITL/scene/javascript run "foo(1)";
}

%===============================
%:Math expressions
\input{MathExpressions/mathexpressions.tex}

%===============================
%:Score expressions
%\input{scorexpressions.tex}

%===============================
%:Appendix
\toplevel{Appendices}
\label{appendices}
\input{yacc.tex}

\input{tokens.tex}


\printindex

\end{document}
